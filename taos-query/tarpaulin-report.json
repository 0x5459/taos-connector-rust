{"files":[{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","2.0","src","connector","odbc","examples","rust","main","src","main.rs"],"content":"extern crate odbc;\n// Use this crate and set environmet variable RUST_LOG=odbc to see ODBC warnings\nextern crate env_logger;\nuse odbc::*;\nuse odbc_safe::AutocommitOn;\nuse std::env;\n\nfn main() {\n\n    env_logger::init();\n\n    let conn_str = env::var(\"DSN\").unwrap();\n    match connect(&conn_str) {\n        Ok(()) => println!(\"Success\"),\n        Err(diag) => println!(\"Error: {}\", diag),\n    }\n}\n\nfn connect(conn_str: &str) -> std::result::Result<(), DiagnosticRecord> {\n\n    let env = create_environment_v3().map_err(|e| e.unwrap())?;\n\n    let conn = env.connect_with_connection_string(conn_str)?;\n    execute_statement(&conn)\n}\n\nfn execute_statement<'env>(conn: &Connection<'env, AutocommitOn>) -> Result<()> {\n    let stmt = Statement::with_parent(conn)?;\n\n    match stmt.exec_direct(\"select * from m.t\")? {\n        Data(mut stmt) => {\n            let cols = stmt.num_result_cols()?;\n            println!(\"cols: {}\", cols);\n            while let Some(mut cursor) = stmt.fetch()? {\n                for i in 1..(cols + 1) {\n                    match cursor.get_data::<&str>(i as u16)? {\n                        Some(val) => print!(\" {}\", val),\n                        None => print!(\" NULL\"),\n                    }\n                }\n                println!(\"\");\n            }\n        }\n        NoData(_) => println!(\"Query executed, no data returned\"),\n    }\n\n    Ok(())\n}\n\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","examples","connect.rs"],"content":"use libtaos::*;\n\nfn taos_connect() -> Result<Taos, Error> {\n    TaosCfgBuilder::default()\n        .ip(\"localhost\")\n        .user(\"root\")\n        .pass(\"taosdata\")\n        // .db(\"log\") // remove comment if you want to connect to database log by default.\n        .port(6030u16)\n        .build()\n        .expect(\"TaosCfg builder error\")\n        .connect()\n}\n\nfn main() {\n    #[allow(unused_variables)]\n    let taos = taos_connect().unwrap();\n    println!(\"Connected\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","examples","stmt_example.rs"],"content":"use bstr::BString;\nuse libtaos::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.create_database(\"power\").await?;\n    taos.use_database(\"power\").await?;\n    taos.exec(\"CREATE STABLE meters (ts TIMESTAMP, current FLOAT, voltage INT, phase FLOAT) TAGS (location BINARY(64), groupId INT)\").await?;\n    let mut stmt = taos.stmt(\"INSERT INTO ? USING meters TAGS(?, ?) VALUES(?, ?, ?, ?)\")?;\n    // bind table name and tags\n    stmt.set_tbname_tags(\n        \"d1001\",\n        [\n            Field::Binary(BString::from(\"California.SanFrancisco\")),\n            Field::Int(2),\n        ],\n    )?;\n    // bind values.\n    let values = vec![\n        Field::Timestamp(Timestamp::new(1648432611249, TimestampPrecision::Milli)),\n        Field::Float(10.3),\n        Field::Int(219),\n        Field::Float(0.31),\n    ];\n    stmt.bind(&values)?;\n    // bind one more row\n    let values2 = vec![\n        Field::Timestamp(Timestamp::new(1648432611749, TimestampPrecision::Milli)),\n        Field::Float(12.6),\n        Field::Int(218),\n        Field::Float(0.33),\n    ];\n    stmt.bind(&values2)?;\n    // execute\n    stmt.execute()?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","examples","subscribe_demo.rs"],"content":"fn main() {\n  \n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","examples","connect.rs"],"content":"use libtaos::*;\n\nfn taos_connect() -> Result<Taos, Error> {\n    TaosCfgBuilder::default()\n        .ip(\"localhost\")\n        .user(\"root\")\n        .pass(\"taosdata\")\n        // .db(\"log\") // remove comment if you want to connect to database log by default.\n        .port(6030u16)\n        .build()\n        .expect(\"TaosCfg builder error\")\n        .connect()\n}\n\n#[tokio::main]\nasync fn main() {\n    #[allow(unused_variables)]\n    let taos = taos_connect().expect(\"connect error\");\n    println!(\"Connected\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","examples","insert_example.rs"],"content":"use libtaos::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.create_database(\"power\").await?;\n    taos.exec(\"CREATE STABLE power.meters (ts TIMESTAMP, current FLOAT, voltage INT, phase FLOAT) TAGS (location BINARY(64), groupId INT)\").await?;\n    let sql = \"INSERT INTO power.d1001 USING power.meters TAGS(California.SanFrancisco, 2) VALUES ('2018-10-03 14:38:05.000', 10.30000, 219, 0.31000) ('2018-10-03 14:38:15.000', 12.60000, 218, 0.33000) ('2018-10-03 14:38:16.800', 12.30000, 221, 0.31000)\n    power.d1002 USING power.meters TAGS(California.SanFrancisco, 3) VALUES ('2018-10-03 14:38:16.650', 10.30000, 218, 0.25000)\n    power.d1003 USING power.meters TAGS(California.LosAngeles, 2) VALUES ('2018-10-03 14:38:05.500', 11.80000, 221, 0.28000) ('2018-10-03 14:38:16.600', 13.40000, 223, 0.29000)\n    power.d1004 USING power.meters TAGS(California.LosAngeles, 3) VALUES ('2018-10-03 14:38:05.000', 10.80000, 223, 0.29000) ('2018-10-03 14:38:06.500', 11.50000, 221, 0.35000)\";\n    let result = taos.query(sql).await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n\n// output:\n// TaosQueryData { column_meta: [ColumnMeta { name: \"affected_rows\", type_: Int, bytes: 4 }], rows: [[Int(8)]] }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","examples","query_example.rs"],"content":"use libtaos::*;\n\nfn taos_connect() -> Result<Taos, Error> {\n    TaosCfgBuilder::default()\n        .ip(\"localhost\")\n        .user(\"root\")\n        .pass(\"taosdata\")\n        .db(\"power\")\n        .port(6030u16)\n        .build()\n        .expect(\"TaosCfg builder error\")\n        .connect()\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let taos = taos_connect().expect(\"connect error\");\n    let result = taos.query(\"SELECT ts, current FROM meters LIMIT 2\").await?;\n    // print column names\n    let meta: Vec<ColumnMeta> = result.column_meta;\n    for column in meta {\n        print!(\"{}\\t\", column.name)\n    }\n    println!();\n    // print rows\n    let rows: Vec<Vec<Field>> = result.rows;\n    for row in rows {\n        for field in row {\n            print!(\"{}\\t\", field);\n        }\n        println!();\n    }\n    Ok(())\n}\n\n// output:\n// ts      current\n// 2022-03-28 09:56:51.249 10.3\n// 2022-03-28 09:56:51.749 12.6\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","examples","influxdb_line_example.rs"],"content":"use libtaos::schemaless::*;\nuse libtaos::*;\n\nfn main() {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.raw_query(\"CREATE DATABASE test\").unwrap();\n    taos.raw_query(\"USE test\").unwrap();\n    let lines = [\"meters,location=California.LosAngeles,groupid=2 current=11.8,voltage=221,phase=0.28 1648432611249\",\n    \"meters,location=California.LosAngeles,groupid=2 current=13.4,voltage=223,phase=0.29 1648432611250\",\n    \"meters,location=California.LosAngeles,groupid=3 current=10.8,voltage=223,phase=0.29 1648432611249\",\n    \"meters,location=California.LosAngeles,groupid=3 current=11.3,voltage=221,phase=0.35 1648432611250\"];\n    let affected_rows = taos\n        .schemaless_insert(\n            &lines,\n            TSDB_SML_LINE_PROTOCOL,\n            TSDB_SML_TIMESTAMP_MILLISECONDS,\n        )\n        .unwrap();\n    println!(\"affected_rows={}\", affected_rows);\n}\n\n// run with:  cargo run --example influxdb_line_example\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","examples","opentsdb_json_example.rs"],"content":"use libtaos::schemaless::*;\nuse libtaos::*;\n\nfn main() {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.raw_query(\"CREATE DATABASE test\").unwrap();\n    taos.raw_query(\"USE test\").unwrap();\n    let lines = [\n        r#\"[{\"metric\": \"meters.current\", \"timestamp\": 1648432611249, \"value\": 10.3, \"tags\": {\"location\": \"California.SanFrancisco\", \"groupid\": 2}},\n        {\"metric\": \"meters.voltage\", \"timestamp\": 1648432611249, \"value\": 219, \"tags\": {\"location\": \"California.LosAngeles\", \"groupid\": 1}},\n        {\"metric\": \"meters.current\", \"timestamp\": 1648432611250, \"value\": 12.6, \"tags\": {\"location\": \"California.SanFrancisco\", \"groupid\": 2}},\n        {\"metric\": \"meters.voltage\", \"timestamp\": 1648432611250, \"value\": 221, \"tags\": {\"location\": \"California.LosAngeles\", \"groupid\": 1}}]\"#,\n    ];\n\n    let affected_rows = taos\n        .schemaless_insert(\n            &lines,\n            TSDB_SML_JSON_PROTOCOL,\n            TSDB_SML_TIMESTAMP_NOT_CONFIGURED,\n        )\n        .unwrap();\n    println!(\"affected_rows={}\", affected_rows); // affected_rows=4\n}\n\n// run with:  cargo run --example opentsdb_json_example\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","examples","opentsdb_telnet_example.rs"],"content":"use libtaos::schemaless::*;\nuse libtaos::*;\n\nfn main() {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.raw_query(\"CREATE DATABASE test\").unwrap();\n    taos.raw_query(\"USE test\").unwrap();\n    let lines = [\n        \"meters.current 1648432611249 10.3 location=California.SanFrancisco groupid=2\",\n        \"meters.current 1648432611250 12.6 location=California.SanFrancisco groupid=2\",\n        \"meters.current 1648432611249 10.8 location=California.LosAngeles groupid=3\",\n        \"meters.current 1648432611250 11.3 location=California.LosAngeles groupid=3\",\n        \"meters.voltage 1648432611249 219 location=California.SanFrancisco groupid=2\",\n        \"meters.voltage 1648432611250 218 location=California.SanFrancisco groupid=2\",\n        \"meters.voltage 1648432611249 221 location=California.LosAngeles groupid=3\",\n        \"meters.voltage 1648432611250 217 location=California.LosAngeles groupid=3\",\n    ];\n    let affected_rows = taos\n        .schemaless_insert(\n            &lines,\n            TSDB_SML_TELNET_PROTOCOL,\n            TSDB_SML_TIMESTAMP_NOT_CONFIGURED,\n        )\n        .unwrap();\n    println!(\"affected_rows={}\", affected_rows); // affected_rows=8\n}\n\n// run with:  cargo run --example opentsdb_telnet_example\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","build.rs"],"content":"extern crate bindgen;\n\nuse std::env;\nuse std::path::PathBuf;\n\nfn main() {\n    // Tell cargo to tell rustc to link the system bzip2\n    // shared library.\n    println!(\"cargo:rustc-link-lib=taos\");\n\n    // Tell cargo to invalidate the built crate whenever the wrapper changes\n    println!(\"cargo:rerun-if-changed=wrapper.h\");\n\n    // The bindgen::Builder is the main entry point\n    // to bindgen, and lets you build up options for\n    // the resulting bindings.\n    let bindings = bindgen::Builder::default()\n        // The input header we would like to generate\n        // bindings for.\n        .header(\"wrapper.h\")\n        // Tell cargo to invalidate the built crate whenever any of the\n        // included header files changed.\n        .parse_callbacks(Box::new(bindgen::CargoCallbacks))\n        // Finish the builder and generate the bindings.\n        .generate()\n        // Unwrap the Result and panic on failure.\n        .expect(\"Unable to generate bindings\");\n\n    // Write the bindings to the $OUT_DIR/bindings.rs file.\n    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"bindings.rs\"))\n        .expect(\"Couldn't write bindings!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","examples","demo.rs"],"content":"use libtdengine::tdengine::{clean_up, Tdengine};\nuse libtdengine::utils;\nuse std::process;\n\nfn main() {\n    let tde = Tdengine::new(\"127.0.0.1:6030\", \"root\", \"taosdata\", \"log\", 0).unwrap_or_else(|err| {\n        eprintln!(\"Can't create Tdengine: {}\", err);\n        process::exit(1)\n    });\n\n    assert_eq!(tde.query(\"drop database demo\").is_ok(), true);\n    assert_eq!(tde.query(\"create database demo\").is_ok(), true);\n    assert_eq!(tde.query(\"use demo\").is_ok(), true);\n    assert_eq!(\n        tde.query(\"create table m1 (ts timestamp, speed int)\")\n            .is_ok(),\n        true\n    );\n\n    for i in 0..10 {\n        assert_eq!(\n            tde.query(format!(\"insert into m1 values (now+{}s, {})\", i, i).as_str())\n                .is_ok(),\n            true\n        );\n    }\n    let rows = tde.query(\"select * from m1\").unwrap_or_else(|err| {\n        eprintln!(\"select error: {}\", err);\n        process::exit(1);\n    });\n    for row in rows {\n        println!(\"{}\", utils::format_row(&row));\n    }\n    // drop manually before clean up\n    drop(tde);\n    // cleanup before program exit\n    clean_up();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","examples","subscribe.rs"],"content":"use libtdengine::subscriber::Subscriber;\nuse libtdengine::tdengine::{clean_up, Tdengine};\nuse std::process;\n\nfn main() {\n    let td = Tdengine::new(\"127.0.0.1\", \"root\", \"taosdata\", \"demo\", 0).unwrap_or_else(|err| {\n        eprintln!(\"Can't create Tdengine: {}\", err);\n        process::exit(1)\n    });\n\n    let mut subscriber =\n        Subscriber::subscribe(td.taos(), 0, \"topic_test\", \"select * from m1;\", 1000)\n            .unwrap_or_else(|err| {\n                eprintln!(\"Can't create Subscriber: {}\", err);\n                process::exit(1)\n            });\n\n    loop {\n        let rows = match subscriber.consume() {\n            Ok(rows) => rows,\n            Err(err) => {\n                eprintln!(\"consume exit: {}\", err);\n                break;\n            }\n        };\n\n        // example code\n        for row in rows {\n            println!(\"({}, {})\", row[0].as_i64(), row[1].as_i32());\n        }\n        println!(\"====================\");\n    }\n    drop(td);\n    clean_up();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","bindings.rs"],"content":"/* automatically generated by rust-bindgen 0.55.1 */\n\npub const _STDINT_H: u32 = 1;\npub const _FEATURES_H: u32 = 1;\npub const __USE_ANSI: u32 = 1;\npub const _BSD_SOURCE: u32 = 1;\npub const _SVID_SOURCE: u32 = 1;\npub const __USE_ISOC11: u32 = 1;\npub const __USE_ISOC99: u32 = 1;\npub const __USE_ISOC95: u32 = 1;\npub const _POSIX_SOURCE: u32 = 1;\npub const _POSIX_C_SOURCE: u32 = 200809;\npub const __USE_POSIX_IMPLICITLY: u32 = 1;\npub const __USE_POSIX: u32 = 1;\npub const __USE_POSIX2: u32 = 1;\npub const __USE_POSIX199309: u32 = 1;\npub const __USE_POSIX199506: u32 = 1;\npub const __USE_XOPEN2K: u32 = 1;\npub const __USE_XOPEN2K8: u32 = 1;\npub const _ATFILE_SOURCE: u32 = 1;\npub const __USE_MISC: u32 = 1;\npub const __USE_BSD: u32 = 1;\npub const __USE_SVID: u32 = 1;\npub const __USE_ATFILE: u32 = 1;\npub const __USE_FORTIFY_LEVEL: u32 = 0;\npub const _STDC_PREDEF_H: u32 = 1;\npub const __STDC_IEC_559__: u32 = 1;\npub const __STDC_IEC_559_COMPLEX__: u32 = 1;\npub const __STDC_ISO_10646__: u32 = 201103;\npub const __STDC_NO_THREADS__: u32 = 1;\npub const __GNU_LIBRARY__: u32 = 6;\npub const __GLIBC__: u32 = 2;\npub const __GLIBC_MINOR__: u32 = 17;\npub const __GLIBC_HAVE_LONG_LONG: u32 = 1;\npub const _SYS_CDEFS_H: u32 = 1;\npub const __WORDSIZE: u32 = 64;\npub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;\npub const __SYSCALL_WORDSIZE: u32 = 64;\npub const _BITS_WCHAR_H: u32 = 1;\npub const __WCHAR_MIN: i32 = -2147483648;\npub const __WCHAR_MAX: u32 = 2147483647;\npub const INT8_MIN: i32 = -128;\npub const INT16_MIN: i32 = -32768;\npub const INT32_MIN: i32 = -2147483648;\npub const INT8_MAX: u32 = 127;\npub const INT16_MAX: u32 = 32767;\npub const INT32_MAX: u32 = 2147483647;\npub const UINT8_MAX: u32 = 255;\npub const UINT16_MAX: u32 = 65535;\npub const UINT32_MAX: u32 = 4294967295;\npub const INT_LEAST8_MIN: i32 = -128;\npub const INT_LEAST16_MIN: i32 = -32768;\npub const INT_LEAST32_MIN: i32 = -2147483648;\npub const INT_LEAST8_MAX: u32 = 127;\npub const INT_LEAST16_MAX: u32 = 32767;\npub const INT_LEAST32_MAX: u32 = 2147483647;\npub const UINT_LEAST8_MAX: u32 = 255;\npub const UINT_LEAST16_MAX: u32 = 65535;\npub const UINT_LEAST32_MAX: u32 = 4294967295;\npub const INT_FAST8_MIN: i32 = -128;\npub const INT_FAST16_MIN: i64 = -9223372036854775808;\npub const INT_FAST32_MIN: i64 = -9223372036854775808;\npub const INT_FAST8_MAX: u32 = 127;\npub const INT_FAST16_MAX: u64 = 9223372036854775807;\npub const INT_FAST32_MAX: u64 = 9223372036854775807;\npub const UINT_FAST8_MAX: u32 = 255;\npub const UINT_FAST16_MAX: i32 = -1;\npub const UINT_FAST32_MAX: i32 = -1;\npub const INTPTR_MIN: i64 = -9223372036854775808;\npub const INTPTR_MAX: u64 = 9223372036854775807;\npub const UINTPTR_MAX: i32 = -1;\npub const PTRDIFF_MIN: i64 = -9223372036854775808;\npub const PTRDIFF_MAX: u64 = 9223372036854775807;\npub const SIG_ATOMIC_MIN: i32 = -2147483648;\npub const SIG_ATOMIC_MAX: u32 = 2147483647;\npub const SIZE_MAX: i32 = -1;\npub const WCHAR_MIN: i32 = -2147483648;\npub const WCHAR_MAX: u32 = 2147483647;\npub const WINT_MIN: u32 = 0;\npub const WINT_MAX: u32 = 4294967295;\npub const TSDB_DATA_TYPE_NULL: u32 = 0;\npub const TSDB_DATA_TYPE_BOOL: u32 = 1;\npub const TSDB_DATA_TYPE_TINYINT: u32 = 2;\npub const TSDB_DATA_TYPE_SMALLINT: u32 = 3;\npub const TSDB_DATA_TYPE_INT: u32 = 4;\npub const TSDB_DATA_TYPE_BIGINT: u32 = 5;\npub const TSDB_DATA_TYPE_FLOAT: u32 = 6;\npub const TSDB_DATA_TYPE_DOUBLE: u32 = 7;\npub const TSDB_DATA_TYPE_BINARY: u32 = 8;\npub const TSDB_DATA_TYPE_TIMESTAMP: u32 = 9;\npub const TSDB_DATA_TYPE_NCHAR: u32 = 10;\npub type int_least8_t = ::std::os::raw::c_schar;\npub type int_least16_t = ::std::os::raw::c_short;\npub type int_least32_t = ::std::os::raw::c_int;\npub type int_least64_t = ::std::os::raw::c_long;\npub type uint_least8_t = ::std::os::raw::c_uchar;\npub type uint_least16_t = ::std::os::raw::c_ushort;\npub type uint_least32_t = ::std::os::raw::c_uint;\npub type uint_least64_t = ::std::os::raw::c_ulong;\npub type int_fast8_t = ::std::os::raw::c_schar;\npub type int_fast16_t = ::std::os::raw::c_long;\npub type int_fast32_t = ::std::os::raw::c_long;\npub type int_fast64_t = ::std::os::raw::c_long;\npub type uint_fast8_t = ::std::os::raw::c_uchar;\npub type uint_fast16_t = ::std::os::raw::c_ulong;\npub type uint_fast32_t = ::std::os::raw::c_ulong;\npub type uint_fast64_t = ::std::os::raw::c_ulong;\npub type intmax_t = ::std::os::raw::c_long;\npub type uintmax_t = ::std::os::raw::c_ulong;\npub type TAOS = ::std::os::raw::c_void;\npub type TAOS_ROW = *mut *mut ::std::os::raw::c_void;\npub type TAOS_RES = ::std::os::raw::c_void;\npub type TAOS_SUB = ::std::os::raw::c_void;\npub type TAOS_STREAM = ::std::os::raw::c_void;\npub type TAOS_STMT = ::std::os::raw::c_void;\npub const TSDB_OPTION_TSDB_OPTION_LOCALE: TSDB_OPTION = 0;\npub const TSDB_OPTION_TSDB_OPTION_CHARSET: TSDB_OPTION = 1;\npub const TSDB_OPTION_TSDB_OPTION_TIMEZONE: TSDB_OPTION = 2;\npub const TSDB_OPTION_TSDB_OPTION_CONFIGDIR: TSDB_OPTION = 3;\npub const TSDB_OPTION_TSDB_OPTION_SHELL_ACTIVITY_TIMER: TSDB_OPTION = 4;\npub const TSDB_OPTION_TSDB_MAX_OPTIONS: TSDB_OPTION = 5;\npub type TSDB_OPTION = ::std::os::raw::c_uint;\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct taosField {\n    pub name: [::std::os::raw::c_char; 65usize],\n    pub type_: u8,\n    pub bytes: i16,\n}\n#[test]\nfn bindgen_test_layout_taosField() {\n    assert_eq!(\n        ::std::mem::size_of::<taosField>(),\n        68usize,\n        concat!(\"Size of: \", stringify!(taosField))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<taosField>(),\n        2usize,\n        concat!(\"Alignment of \", stringify!(taosField))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<taosField>())).name as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(taosField),\n            \"::\",\n            stringify!(name)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<taosField>())).type_ as *const _ as usize },\n        65usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(taosField),\n            \"::\",\n            stringify!(type_)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<taosField>())).bytes as *const _ as usize },\n        66usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(taosField),\n            \"::\",\n            stringify!(bytes)\n        )\n    );\n}\npub type TAOS_FIELD = taosField;\nextern \"C\" {\n    pub fn taos_init();\n}\nextern \"C\" {\n    pub fn taos_cleanup();\n}\nextern \"C\" {\n    pub fn taos_options(\n        option: TSDB_OPTION,\n        arg: *const ::std::os::raw::c_void,\n        ...\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_connect(\n        ip: *const ::std::os::raw::c_char,\n        user: *const ::std::os::raw::c_char,\n        pass: *const ::std::os::raw::c_char,\n        db: *const ::std::os::raw::c_char,\n        port: u16,\n    ) -> *mut TAOS;\n}\nextern \"C\" {\n    pub fn taos_close(taos: *mut TAOS);\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct TAOS_BIND {\n    pub buffer_type: ::std::os::raw::c_int,\n    pub buffer: *mut ::std::os::raw::c_void,\n    pub buffer_length: usize,\n    pub length: *mut usize,\n    pub is_null: *mut ::std::os::raw::c_int,\n    pub is_unsigned: ::std::os::raw::c_int,\n    pub error: *mut ::std::os::raw::c_int,\n}\n#[test]\nfn bindgen_test_layout_TAOS_BIND() {\n    assert_eq!(\n        ::std::mem::size_of::<TAOS_BIND>(),\n        56usize,\n        concat!(\"Size of: \", stringify!(TAOS_BIND))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<TAOS_BIND>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(TAOS_BIND))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<TAOS_BIND>())).buffer_type as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(buffer_type)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<TAOS_BIND>())).buffer as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(buffer)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<TAOS_BIND>())).buffer_length as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(buffer_length)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<TAOS_BIND>())).length as *const _ as usize },\n        24usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(length)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<TAOS_BIND>())).is_null as *const _ as usize },\n        32usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(is_null)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<TAOS_BIND>())).is_unsigned as *const _ as usize },\n        40usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(is_unsigned)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<TAOS_BIND>())).error as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(error)\n        )\n    );\n}\nextern \"C\" {\n    pub fn taos_stmt_init(taos: *mut TAOS) -> *mut TAOS_STMT;\n}\nextern \"C\" {\n    pub fn taos_stmt_prepare(\n        stmt: *mut TAOS_STMT,\n        sql: *const ::std::os::raw::c_char,\n        length: ::std::os::raw::c_ulong,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_bind_param(\n        stmt: *mut TAOS_STMT,\n        bind: *mut TAOS_BIND,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_add_batch(stmt: *mut TAOS_STMT) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_execute(stmt: *mut TAOS_STMT) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_use_result(stmt: *mut TAOS_STMT) -> *mut TAOS_RES;\n}\nextern \"C\" {\n    pub fn taos_stmt_close(stmt: *mut TAOS_STMT) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_query(taos: *mut TAOS, sql: *const ::std::os::raw::c_char) -> *mut TAOS_RES;\n}\nextern \"C\" {\n    pub fn taos_fetch_row(res: *mut TAOS_RES) -> TAOS_ROW;\n}\nextern \"C\" {\n    pub fn taos_result_precision(res: *mut TAOS_RES) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_free_result(res: *mut TAOS_RES);\n}\nextern \"C\" {\n    pub fn taos_field_count(tres: *mut TAOS_RES) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_num_fields(res: *mut TAOS_RES) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_affected_rows(res: *mut TAOS_RES) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_fetch_fields(res: *mut TAOS_RES) -> *mut TAOS_FIELD;\n}\nextern \"C\" {\n    pub fn taos_select_db(\n        taos: *mut TAOS,\n        db: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_print_row(\n        str_: *mut ::std::os::raw::c_char,\n        row: TAOS_ROW,\n        fields: *mut TAOS_FIELD,\n        num_fields: ::std::os::raw::c_int,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stop_query(res: *mut TAOS_RES);\n}\nextern \"C\" {\n    pub fn taos_fetch_block(res: *mut TAOS_RES, rows: *mut TAOS_ROW) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_validate_sql(\n        taos: *mut TAOS,\n        sql: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_fetch_lengths(res: *mut TAOS_RES) -> *mut ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_get_server_info(taos: *mut TAOS) -> *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn taos_get_client_info() -> *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn taos_errstr(tres: *mut TAOS_RES) -> *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn taos_errno(tres: *mut TAOS_RES) -> ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_query_a(\n        taos: *mut TAOS,\n        sql: *const ::std::os::raw::c_char,\n        fp: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                code: ::std::os::raw::c_int,\n            ),\n        >,\n        param: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn taos_fetch_rows_a(\n        res: *mut TAOS_RES,\n        fp: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                numOfRows: ::std::os::raw::c_int,\n            ),\n        >,\n        param: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn taos_fetch_row_a(\n        res: *mut TAOS_RES,\n        fp: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                row: TAOS_ROW,\n            ),\n        >,\n        param: *mut ::std::os::raw::c_void,\n    );\n}\npub type TAOS_SUBSCRIBE_CALLBACK = ::std::option::Option<\n    unsafe extern \"C\" fn(\n        tsub: *mut TAOS_SUB,\n        res: *mut TAOS_RES,\n        param: *mut ::std::os::raw::c_void,\n        code: ::std::os::raw::c_int,\n    ),\n>;\nextern \"C\" {\n    pub fn taos_subscribe(\n        taos: *mut TAOS,\n        restart: ::std::os::raw::c_int,\n        topic: *const ::std::os::raw::c_char,\n        sql: *const ::std::os::raw::c_char,\n        fp: TAOS_SUBSCRIBE_CALLBACK,\n        param: *mut ::std::os::raw::c_void,\n        interval: ::std::os::raw::c_int,\n    ) -> *mut TAOS_SUB;\n}\nextern \"C\" {\n    pub fn taos_consume(tsub: *mut TAOS_SUB) -> *mut TAOS_RES;\n}\nextern \"C\" {\n    pub fn taos_unsubscribe(tsub: *mut TAOS_SUB, keepProgress: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn taos_open_stream(\n        taos: *mut TAOS,\n        sql: *const ::std::os::raw::c_char,\n        fp: ::std::option::Option<\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                row: TAOS_ROW,\n            ),\n        >,\n        stime: i64,\n        param: *mut ::std::os::raw::c_void,\n        callback: ::std::option::Option<unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)>,\n    ) -> *mut TAOS_STREAM;\n}\nextern \"C\" {\n    pub fn taos_close_stream(tstr: *mut TAOS_STREAM);\n}\nextern \"C\" {\n    pub fn taos_load_table_info(\n        taos: *mut TAOS,\n        tableNameList: *const ::std::os::raw::c_char,\n    ) -> ::std::os::raw::c_int;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","lib.rs"],"content":"#![allow(unused)]\n#![allow(non_camel_case_types)]\n\n#[path = \"bindings.rs\"]\npub mod bindings;\n#[path = \"subscriber.rs\"]\npub mod subscriber;\n#[path = \"tdengine.rs\"]\npub mod tdengine;\n#[path = \"utils.rs\"]\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","subscriber.rs"],"content":"use crate::bindings::*;\nuse crate::utils;\n\nuse std::os::raw::{c_int, c_void};\nuse std::ptr;\n\npub struct Subscriber {\n    tsub: *mut c_void,\n    fields: *mut taosField,\n    fcount: c_int,\n}\n\nimpl Subscriber {\n    pub fn subscribe(\n        taos: *mut c_void,\n        restart: i32,\n        topic: &str,\n        sql: &str,\n        interval: i32,\n    ) -> Result<Subscriber, &'static str> {\n        unsafe {\n            let mut tsub = taos_subscribe(\n                taos,\n                restart as c_int,\n                utils::str_into_raw(topic),\n                utils::str_into_raw(sql),\n                None,\n                ptr::null_mut(),\n                interval as c_int,\n            );\n            if tsub.is_null() {\n                return Err(utils::raw_into_str(taos_errstr(tsub)));\n            }\n\n            Ok(Subscriber {\n                tsub: tsub,\n                fields: ptr::null_mut(), // init\n                fcount: 0,               // init\n            })\n        }\n    }\n\n    pub fn consume(self: &mut Subscriber) -> Result<Vec<utils::Row>, &'static str> {\n        unsafe {\n            let taos_res = taos_consume(self.tsub);\n            if taos_res.is_null() {\n                return Err(utils::raw_into_str(taos_errstr(self.tsub)));\n            }\n            if self.fields.is_null() {\n                self.fields = taos_fetch_fields(taos_res);\n                // fetch err msg\n                if self.fields.is_null() {\n                    return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                }\n            }\n\n            if self.fcount == 0 {\n                self.fcount = taos_field_count(taos_res);\n                if self.fcount == 0 {\n                    return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                }\n                println!(\"{} fields\", self.fcount);\n            }\n\n            let mut rows: Vec<utils::Row> = Vec::<utils::Row>::new();\n            loop {\n                let taos_row = taos_fetch_row(taos_res);\n                if taos_row.is_null() {\n                    // chek retcode\n                    if taos_errno(taos_res) != 0 {\n                        return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                    }\n                    break;\n                }\n\n                // example code for taos_print_row\n                //let mut buf: Vec<c_char> = vec![0; 4096];\n                //taos_print_row(buf.as_mut_ptr(), taos_row, self.fields, self.fcount);\n                //println!(\n                //    \"internal print {}\",\n                //    CStr::from_ptr(buf.as_ptr()).to_str().unwrap()\n                //);\n\n                let raw_row = std::slice::from_raw_parts(taos_row, self.fcount as usize);\n                let row = utils::raw_into_row(self.fields, self.fcount, raw_row);\n                rows.push(row);\n            }\n            println!(\"{} rows fetched\", rows.len());\n            Ok(rows)\n        }\n    }\n\n    pub fn unsubscribe(self: &Subscriber, keep_progress: i32) {\n        unsafe { taos_unsubscribe(self.tsub, keep_progress as c_int) }\n    }\n\n    pub fn print_row(self: &Subscriber, row: &utils::Row) {\n        println!(\"format row: {}\", utils::format_row(row));\n    }\n}\n\nimpl Drop for Subscriber {\n    fn drop(&mut self) {\n        unsafe {\n            taos_unsubscribe(self.tsub, 1);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","tdengine.rs"],"content":"use crate::bindings::*;\nuse crate::utils;\n\nuse std::os::raw::c_void;\n\npub struct Tdengine {\n    conn: *mut c_void, // tdengine conn\n}\n\nimpl Tdengine {\n    pub fn new(\n        ip: &str, // host ip\n        username: &str,\n        passwd: &str,\n        db: &str,\n        port: i32, // tdengine port\n    ) -> Result<Tdengine, &'static str> {\n        unsafe {\n            taos_init();\n            let mut conn = taos_connect(\n                utils::str_into_raw(ip),\n                utils::str_into_raw(username),\n                utils::str_into_raw(passwd),\n                utils::str_into_raw(db),\n                port as u16,\n            );\n            if conn.is_null() {\n                Err(utils::raw_into_str(taos_errstr(conn)))\n            } else {\n                println!(\"connected to {}:{} user:{}, db:{}\", ip, port, username, db);\n                Ok(Tdengine { conn })\n            }\n        }\n    }\n\n    pub fn query(self: &Tdengine, s: &str) -> Result<Vec<utils::Row>, &'static str> {\n        unsafe {\n            let taos_res = taos_query(self.conn, utils::str_into_raw(s));\n            // check retcode\n            if taos_errno(taos_res) != 0 {\n                let err = utils::raw_into_str(taos_errstr(taos_res));\n                println!(\"query '{}' error: {}\", s, err);\n                return Err(err);\n            }\n            println!(\"query '{}' ok\", s);\n            let mut rows: Vec<utils::Row> = Vec::<utils::Row>::new();\n            let fields = taos_fetch_fields(taos_res);\n            let fcount = taos_field_count(taos_res);\n            loop {\n                let taos_row = taos_fetch_row(taos_res);\n                if taos_row.is_null() {\n                    // check retcode\n                    if taos_errno(taos_res) != 0 {\n                        return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                    }\n                    break;\n                }\n\n                let raw_row = std::slice::from_raw_parts(taos_row, fcount as usize);\n                let row = utils::raw_into_row(fields, fcount, raw_row);\n                rows.push(row);\n            }\n            taos_free_result(taos_res);\n            println!(\"{} rows fetched\", rows.len());\n            Ok(rows)\n        }\n    }\n\n    pub fn taos(self: &Tdengine) -> *mut c_void {\n        self.conn\n    }\n}\n\nimpl Drop for Tdengine {\n    fn drop(&mut self) {\n        unsafe {\n            taos_close(self.conn);\n            // we will not do clean up here\n        }\n    }\n}\n\npub fn clean_up() {\n    unsafe {\n        taos_cleanup();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","utils.rs"],"content":"use crate::bindings;\n\nuse std::ffi::{CStr, CString};\nuse std::fmt;\nuse std::os::raw::{c_char, c_int, c_void};\n\n// #[derive(Debug)]\npub enum Field {\n    tinyInt(i8),\n    smallInt(i16),\n    normalInt(i32),\n    bigInt(i64),\n    float(f32),\n    double(f64),\n    string(String),\n    boolType(bool),\n}\n\nimpl fmt::Display for Field {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match &*self {\n            Field::tinyInt(v) => write!(f, \"{}\", v),\n            Field::smallInt(v) => write!(f, \"{}\", v),\n            Field::normalInt(v) => write!(f, \"{}\", v),\n            Field::bigInt(v) => write!(f, \"{}\", v),\n            Field::float(v) => write!(f, \"{}\", v),\n            Field::double(v) => write!(f, \"{}\", v),\n            Field::tinyInt(v) => write!(f, \"{}\", v),\n            Field::boolType(v) => write!(f, \"{}\", v),\n            Field::string(v) => write!(f, \"{}\", v),\n        }\n    }\n}\n\nmacro_rules! impl_as_fields {\n    ($fn:ident, $pattern:pat => $v:expr, $type:ty) => {\n        pub fn $fn(&self) -> $type {\n            match *self {\n                $pattern => $v,\n                _ => {\n                    println!(\"unexpected $type value {}\", self);\n                    Default::default()\n                }\n            }\n        }\n    };\n}\n\nimpl Field {\n    impl_as_fields!(as_i8, Field::tinyInt(v) => v, i8);\n    impl_as_fields!(as_i16, Field::smallInt(v) => v, i16);\n    impl_as_fields!(as_i32, Field::normalInt(v) => v, i32);\n    impl_as_fields!(as_i64, Field::bigInt(v) => v, i64);\n    impl_as_fields!(as_f32, Field::float(v) => v, f32);\n    impl_as_fields!(as_f64, Field::double(v) => v, f64);\n    impl_as_fields!(as_bool, Field::boolType(v) => v, bool);\n\n    pub fn as_string(&self) -> String {\n        match &*self {\n            Field::string(v) => v.to_string(),\n            _ => {\n                println!(\"unexpected string value {}\", self);\n                \"\".to_string()\n            }\n        }\n    }\n}\n\npub type Row = Vec<Field>;\n\npub fn format_row(row: &Row) -> String {\n    let mut s = String::new();\n    for field in row {\n        s.push_str(format!(\"{} \", field).as_str());\n    }\n    s\n}\n\npub fn str_into_raw(s: &str) -> *mut c_char {\n    if s.is_empty() {\n        0 as *mut c_char\n    } else {\n        CString::new(s).unwrap().into_raw()\n    }\n}\n\npub fn raw_into_str<'a>(raw: *mut c_char) -> &'static str {\n    unsafe { CStr::from_ptr(raw).to_str().unwrap() }\n}\n\npub fn raw_into_field(raw: *mut bindings::TAOS_FIELD, fcount: c_int) -> Vec<bindings::taosField> {\n    let mut fields: Vec<bindings::taosField> = Vec::new();\n\n    for i in 0..fcount as isize {\n        fields.push(bindings::taosField {\n            name: unsafe { *raw.offset(i as isize) }.name,\n            bytes: unsafe { *raw.offset(i as isize) }.bytes,\n            type_: unsafe { *raw.offset(i as isize) }.type_,\n        });\n    }\n    fields\n}\n\npub fn raw_into_row(\n    fields: *mut bindings::TAOS_FIELD,\n    fcount: c_int,\n    raw_row: &[*mut c_void],\n) -> Row {\n    let mut row: Row = Vec::new();\n    let fields = raw_into_field(fields, fcount);\n\n    for (i, field) in fields.iter().enumerate() {\n        unsafe {\n            match field.type_ as u32 {\n                bindings::TSDB_DATA_TYPE_TINYINT => {\n                    row.push(Field::tinyInt(*(raw_row[i] as *mut i8)));\n                }\n                bindings::TSDB_DATA_TYPE_SMALLINT => {\n                    row.push(Field::smallInt(*(raw_row[i] as *mut i16)));\n                }\n                bindings::TSDB_DATA_TYPE_INT => {\n                    row.push(Field::normalInt(*(raw_row[i] as *mut i32)));\n                }\n                bindings::TSDB_DATA_TYPE_BIGINT | bindings::TSDB_DATA_TYPE_TIMESTAMP => {\n                    row.push(Field::bigInt(*(raw_row[i] as *mut i64)));\n                }\n                bindings::TSDB_DATA_TYPE_FLOAT => {\n                    row.push(Field::float(*(raw_row[i] as *mut f32)));\n                }\n                bindings::TSDB_DATA_TYPE_DOUBLE => {\n                    row.push(Field::double(*(raw_row[i] as *mut f64)));\n                }\n                bindings::TSDB_DATA_TYPE_NCHAR => {\n                    let a = CStr::from_ptr(raw_row[i] as *const c_char)\n                        .to_string_lossy()\n                        .into_owned();\n                    row.push(Field::string(a));\n                }\n                bindings::TSDB_DATA_TYPE_BOOL => {\n                    row.push(Field::boolType(*(raw_row[i] as *mut i8) != 0));\n                }\n                _ => println!(\"\"),\n            }\n        }\n    }\n    row\n}\n","traces":[{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","benches","serde.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse avro_rs::{\n    schema::Schema,\n    types::{Record, Value},\n    Reader, Writer,\n};\nuse criterion::{criterion_group, criterion_main, Criterion};\nuse std::time::Duration;\n\nconst RAW_SMALL_SCHEMA: &str = r#\"\n{\n  \"namespace\": \"test\",\n  \"type\": \"record\",\n  \"name\": \"Test\",\n  \"fields\": [\n    {\n      \"type\": {\n        \"type\": \"string\"\n      },\n      \"name\": \"field\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_BIG_SCHEMA: &str = r#\"\n{\n  \"namespace\": \"my.example\",\n  \"type\": \"record\",\n  \"name\": \"userInfo\",\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"username\"\n    },\n    {\n      \"default\": -1,\n      \"type\": \"int\",\n      \"name\": \"age\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"phone\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"housenum\"\n    },\n    {\n      \"default\": {},\n      \"type\": {\n        \"fields\": [\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"street\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"city\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"state_prov\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"country\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"zip\"\n          }\n        ],\n        \"type\": \"record\",\n        \"name\": \"mailing_address\"\n      },\n      \"name\": \"address\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_ADDRESS_SCHEMA: &str = r#\"\n{\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"street\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"city\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"state_prov\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"country\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"zip\"\n    }\n  ],\n  \"type\": \"record\",\n  \"name\": \"mailing_address\"\n}\n\"#;\n\nfn make_small_record() -> (Schema, Value) {\n    let small_schema = Schema::parse_str(RAW_SMALL_SCHEMA).unwrap();\n    let small_record = {\n        let mut small_record = Record::new(&small_schema).unwrap();\n        small_record.put(\"field\", \"foo\");\n        small_record.into()\n    };\n    (small_schema, small_record)\n}\n\nfn make_big_record() -> (Schema, Value) {\n    let big_schema = Schema::parse_str(RAW_BIG_SCHEMA).unwrap();\n    let address_schema = Schema::parse_str(RAW_ADDRESS_SCHEMA).unwrap();\n    let mut address = Record::new(&address_schema).unwrap();\n    address.put(\"street\", \"street\");\n    address.put(\"city\", \"city\");\n    address.put(\"state_prov\", \"state_prov\");\n    address.put(\"country\", \"country\");\n    address.put(\"zip\", \"zip\");\n\n    let big_record = {\n        let mut big_record = Record::new(&big_schema).unwrap();\n        big_record.put(\"username\", \"username\");\n        big_record.put(\"age\", 10i32);\n        big_record.put(\"phone\", \"000000000\");\n        big_record.put(\"housenum\", \"0000\");\n        big_record.put(\"address\", address);\n        big_record.into()\n    };\n\n    (big_schema, big_record)\n}\n\nfn make_records(record: Value, count: usize) -> Vec<Value> {\n    std::iter::repeat(record).take(count).collect()\n}\n\nfn write(schema: &Schema, records: &[Value]) -> Vec<u8> {\n    let mut writer = Writer::new(schema, Vec::new());\n    writer.extend_from_slice(records).unwrap();\n    writer.into_inner().unwrap()\n}\n\nfn read(schema: &Schema, bytes: &[u8]) {\n    let reader = Reader::with_schema(schema, bytes).unwrap();\n\n    for record in reader {\n        let _ = record.unwrap();\n    }\n}\n\nfn read_schemaless(bytes: &[u8]) {\n    let reader = Reader::new(bytes).unwrap();\n\n    for record in reader {\n        let _ = record.unwrap();\n    }\n}\n\nfn bench_write(\n    c: &mut Criterion,\n    make_record: impl Fn() -> (Schema, Value),\n    n_records: usize,\n    name: &str,\n) {\n    let (schema, record) = make_record();\n    let records = make_records(record, n_records);\n    c.bench_function(name, |b| b.iter(|| write(&schema, &records)));\n}\n\nfn bench_read(\n    c: &mut Criterion,\n    make_record: impl Fn() -> (Schema, Value),\n    n_records: usize,\n    name: &str,\n) {\n    let (schema, record) = make_record();\n    let records = make_records(record, n_records);\n    let bytes = write(&schema, &records);\n    c.bench_function(name, |b| b.iter(|| read(&schema, &bytes)));\n}\n\nfn bench_from_file(c: &mut Criterion, file_path: &str, name: &str) {\n    let bytes = std::fs::read(file_path).unwrap();\n    c.bench_function(name, |b| b.iter(|| read_schemaless(&bytes)));\n}\n\nfn bench_small_schema_write_1_record(c: &mut Criterion) {\n    bench_write(c, &make_small_record, 1, \"small schema, write 1 record\");\n}\n\nfn bench_small_schema_write_100_record(c: &mut Criterion) {\n    bench_write(\n        c,\n        &make_small_record,\n        100,\n        \"small schema, write 100 records\",\n    );\n}\n\nfn bench_small_schema_write_10_000_record(c: &mut Criterion) {\n    bench_write(\n        c,\n        &make_small_record,\n        10_000,\n        \"small schema, write 10k records\",\n    );\n}\n\nfn bench_small_schema_read_1_record(c: &mut Criterion) {\n    bench_read(c, &make_small_record, 1, \"small schema, read 1 record\");\n}\n\nfn bench_small_schema_read_100_record(c: &mut Criterion) {\n    bench_read(c, &make_small_record, 100, \"small schema, read 100 records\");\n}\n\nfn bench_small_schema_read_10_000_record(c: &mut Criterion) {\n    bench_read(\n        c,\n        &make_small_record,\n        10_000,\n        \"small schema, read 10k records\",\n    );\n}\n\nfn bench_big_schema_write_1_record(c: &mut Criterion) {\n    bench_write(c, &make_big_record, 1, \"big schema, write 1 record\");\n}\n\nfn bench_big_schema_write_100_record(c: &mut Criterion) {\n    bench_write(c, &make_big_record, 100, \"big schema, write 100 records\");\n}\n\nfn bench_big_schema_write_10_000_record(c: &mut Criterion) {\n    bench_write(c, &make_big_record, 10_000, \"big schema, write 10k records\");\n}\n\nfn bench_big_schema_read_1_record(c: &mut Criterion) {\n    bench_read(c, &make_big_record, 1, \"big schema, read 1 record\");\n}\n\nfn bench_big_schema_read_100_record(c: &mut Criterion) {\n    bench_read(c, &make_big_record, 100, \"big schema, read 100 records\");\n}\n\nfn bench_big_schema_read_10_000_record(c: &mut Criterion) {\n    bench_read(c, &make_big_record, 10_000, \"big schema, read 10k records\");\n}\n\nfn bench_big_schema_read_100_000_record(c: &mut Criterion) {\n    bench_read(\n        c,\n        &make_big_record,\n        100_000,\n        \"big schema, read 100k records\",\n    );\n}\n\n// This benchmark reads from the `benches/quickstop-null.avro` file, which was pulled from\n// the `goavro` project benchmarks:\n// https://github.com/linkedin/goavro/blob/master/fixtures/quickstop-null.avro\n// This was done for the sake of comparing this crate against the `goavro` implementation.\nfn bench_file_quickstop_null(c: &mut Criterion) {\n    bench_from_file(c, \"benches/quickstop-null.avro\", \"quickstop null file\");\n}\n\ncriterion_group!(\n    benches,\n    bench_small_schema_write_1_record,\n    bench_small_schema_write_100_record,\n    bench_small_schema_read_1_record,\n    bench_small_schema_read_100_record,\n    bench_big_schema_write_1_record,\n    bench_big_schema_write_100_record,\n    bench_big_schema_read_1_record,\n    bench_big_schema_read_100_record,\n);\n\ncriterion_group!(\n    name = long_benches;\n    config = Criterion::default().sample_size(20).measurement_time(Duration::from_secs(10));\n    targets =\n        bench_file_quickstop_null,\n        bench_small_schema_write_10_000_record,\n        bench_small_schema_read_10_000_record,\n        bench_big_schema_read_10_000_record,\n        bench_big_schema_write_10_000_record\n);\n\ncriterion_group!(\n    name = very_long_benches;\n    config = Criterion::default().sample_size(10).measurement_time(Duration::from_secs(20));\n    targets =\n        bench_big_schema_read_100_000_record,\n);\n\ncriterion_main!(benches, long_benches, very_long_benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","benches","serde_json.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse criterion::{criterion_group, criterion_main, Criterion};\nuse serde_json::Value;\nuse std::{collections::HashMap, iter::FromIterator};\n\nfn make_big_json_record() -> Value {\n    let address = HashMap::<_, _>::from_iter(vec![\n        (\"street\", \"street\"),\n        (\"city\", \"city\"),\n        (\"state_prov\", \"state_prov\"),\n        (\"country\", \"country\"),\n        (\"zip\", \"zip\"),\n    ]);\n    let address_json = serde_json::to_value(address).unwrap();\n    let big_record = HashMap::<_, _>::from_iter(vec![\n        (\"username\", serde_json::to_value(\"username\").unwrap()),\n        (\"age\", serde_json::to_value(10i32).unwrap()),\n        (\"phone\", serde_json::to_value(\"000000000\").unwrap()),\n        (\"housenum\", serde_json::to_value(\"0000\").unwrap()),\n        (\"address\", address_json),\n    ]);\n    serde_json::to_value(big_record).unwrap()\n}\n\nfn write_json(records: &[Value]) -> Vec<u8> {\n    serde_json::to_vec(records).unwrap()\n}\n\nfn read_json(bytes: &[u8]) {\n    let reader: serde_json::Value = serde_json::from_slice(bytes).unwrap();\n    for record in reader.as_array().unwrap() {\n        let _ = record;\n    }\n}\n\nfn bench_read_json(\n    c: &mut Criterion,\n    make_record: impl Fn() -> Value,\n    n_records: usize,\n    name: &str,\n) {\n    let records = std::iter::repeat(make_record())\n        .take(n_records)\n        .collect::<Vec<_>>();\n    let bytes = write_json(&records);\n    c.bench_function(name, |b| b.iter(|| read_json(&bytes)));\n}\n\nfn bench_big_schema_json_read_10_000_record(c: &mut Criterion) {\n    bench_read_json(\n        c,\n        &make_big_json_record,\n        10_000,\n        \"big schema, read 10k JSON records\",\n    );\n}\n\ncriterion_group!(\n    name = benches;\n    config = Criterion::default().sample_size(10);\n    targets = bench_big_schema_json_read_10_000_record,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","benches","single.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse avro_rs::{\n    schema::Schema,\n    to_avro_datum,\n    types::{Record, Value},\n};\nuse criterion::{criterion_group, criterion_main, Criterion};\n\nconst RAW_SMALL_SCHEMA: &str = r#\"\n{\n  \"namespace\": \"test\",\n  \"type\": \"record\",\n  \"name\": \"Test\",\n  \"fields\": [\n    {\n      \"type\": {\n        \"type\": \"string\"\n      },\n      \"name\": \"field\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_BIG_SCHEMA: &str = r#\"\n{\n  \"namespace\": \"my.example\",\n  \"type\": \"record\",\n  \"name\": \"userInfo\",\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"username\"\n    },\n    {\n      \"default\": -1,\n      \"type\": \"int\",\n      \"name\": \"age\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"phone\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"housenum\"\n    },\n    {\n      \"default\": {},\n      \"type\": {\n        \"fields\": [\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"street\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"city\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"state_prov\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"country\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"zip\"\n          }\n        ],\n        \"type\": \"record\",\n        \"name\": \"mailing_address\"\n      },\n      \"name\": \"address\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_ADDRESS_SCHEMA: &str = r#\"\n{\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"street\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"city\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"state_prov\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"country\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"zip\"\n    }\n  ],\n  \"type\": \"record\",\n  \"name\": \"mailing_address\"\n}\n\"#;\n\nfn make_small_record() -> (Schema, Value) {\n    let small_schema = Schema::parse_str(RAW_SMALL_SCHEMA).unwrap();\n    let small_record = {\n        let mut small_record = Record::new(&small_schema).unwrap();\n        small_record.put(\"field\", \"foo\");\n        small_record.into()\n    };\n\n    (small_schema, small_record)\n}\n\nfn make_big_record() -> (Schema, Value) {\n    let big_schema = Schema::parse_str(RAW_BIG_SCHEMA).unwrap();\n    let address_schema = Schema::parse_str(RAW_ADDRESS_SCHEMA).unwrap();\n    let mut address = Record::new(&address_schema).unwrap();\n    address.put(\"street\", \"street\");\n    address.put(\"city\", \"city\");\n    address.put(\"state_prov\", \"state_prov\");\n    address.put(\"country\", \"country\");\n    address.put(\"zip\", \"zip\");\n\n    let big_record = {\n        let mut big_record = Record::new(&big_schema).unwrap();\n        big_record.put(\"username\", \"username\");\n        big_record.put(\"age\", 10i32);\n        big_record.put(\"phone\", \"000000000\");\n        big_record.put(\"housenum\", \"0000\");\n        big_record.put(\"address\", address);\n        big_record.into()\n    };\n\n    (big_schema, big_record)\n}\n\nfn bench_small_schema_write_record(c: &mut Criterion) {\n    let (schema, record) = make_small_record();\n    c.bench_function(\"small record\", |b| {\n        b.iter(|| to_avro_datum(&schema, record.clone()))\n    });\n}\n\nfn bench_big_schema_write_record(c: &mut Criterion) {\n    let (schema, record) = make_big_record();\n    c.bench_function(\"big record\", |b| {\n        b.iter(|| to_avro_datum(&schema, record.clone()))\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_small_schema_write_record,\n    bench_big_schema_write_record\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","examples","benchmark.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse avro_rs::{\n    schema::Schema,\n    types::{Record, Value},\n    Reader, Writer,\n};\nuse std::time::{Duration, Instant};\n\nfn nanos(duration: Duration) -> u64 {\n    duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64\n}\n\nfn seconds(nanos: u64) -> f64 {\n    (nanos as f64) / 1_000_000_000f64\n}\n\n/*\nfn duration(nanos: u64) -> Duration {\n    Duration::new(nanos / 1_000_000_000, (nanos % 1_000_000_000) as u32)\n}\n*/\n\nfn benchmark(schema: &Schema, record: &Value, s: &str, count: usize, runs: usize) {\n    let mut records = Vec::new();\n    for __ in 0..count {\n        records.push(record.clone());\n    }\n\n    let mut durations = Vec::with_capacity(runs);\n\n    let mut bytes = None;\n    for _ in 0..runs {\n        let records = records.clone();\n\n        let start = Instant::now();\n        let mut writer = Writer::new(schema, Vec::new());\n        writer.extend(records.into_iter()).unwrap();\n\n        let duration = Instant::now().duration_since(start);\n        durations.push(duration);\n\n        bytes = Some(writer.into_inner().unwrap());\n    }\n\n    let total_duration_write = durations.into_iter().fold(0u64, |a, b| a + nanos(b));\n\n    // println!(\"Write: {} {} {:?}\", count, runs, seconds(total_duration));\n\n    let bytes = bytes.unwrap();\n\n    let mut durations = Vec::with_capacity(runs);\n\n    for _ in 0..runs {\n        let start = Instant::now();\n        let reader = Reader::with_schema(schema, &bytes[..]).unwrap();\n\n        let mut read_records = Vec::with_capacity(count);\n        for record in reader {\n            read_records.push(record);\n        }\n\n        let duration = Instant::now().duration_since(start);\n        durations.push(duration);\n\n        assert_eq!(count, read_records.len());\n    }\n\n    let total_duration_read = durations.into_iter().fold(0u64, |a, b| a + nanos(b));\n\n    // println!(\"Read: {} {} {:?}\", count, runs, seconds(total_duration));\n    let (s_w, s_r) = (seconds(total_duration_write), seconds(total_duration_read));\n\n    println!(\"{},{},{},{},{}\", count, runs, s, s_w, s_r);\n}\n\nfn main() {\n    let raw_small_schema = r#\"\n        {\"namespace\": \"test\", \"type\": \"record\", \"name\": \"Test\", \"fields\": [{\"type\": {\"type\": \"string\"}, \"name\": \"field\"}]}\n    \"#;\n\n    let raw_big_schema = r#\"\n        {\"namespace\": \"my.example\", \"type\": \"record\", \"name\": \"userInfo\", \"fields\": [{\"default\": \"NONE\", \"type\": \"string\", \"name\": \"username\"}, {\"default\": -1, \"type\": \"int\", \"name\": \"age\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"phone\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"housenum\"}, {\"default\": {}, \"type\": {\"fields\": [{\"default\": \"NONE\", \"type\": \"string\", \"name\": \"street\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"city\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"state_prov\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"country\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"zip\"}], \"type\": \"record\", \"name\": \"mailing_address\"}, \"name\": \"address\"}]}\n    \"#;\n\n    let small_schema = Schema::parse_str(raw_small_schema).unwrap();\n    let big_schema = Schema::parse_str(raw_big_schema).unwrap();\n\n    println!(\"{:?}\", small_schema);\n    println!(\"{:?}\", big_schema);\n\n    let mut small_record = Record::new(&small_schema).unwrap();\n    small_record.put(\"field\", \"foo\");\n    let small_record = small_record.into();\n\n    let raw_address_schema = r#\"{\"fields\": [{\"default\": \"NONE\", \"type\": \"string\", \"name\": \"street\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"city\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"state_prov\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"country\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"zip\"}], \"type\": \"record\", \"name\": \"mailing_address\"}\"#;\n    let address_schema = Schema::parse_str(raw_address_schema).unwrap();\n    let mut address = Record::new(&address_schema).unwrap();\n    address.put(\"street\", \"street\");\n    address.put(\"city\", \"city\");\n    address.put(\"state_prov\", \"state_prov\");\n    address.put(\"country\", \"country\");\n    address.put(\"zip\", \"zip\");\n\n    let mut big_record = Record::new(&big_schema).unwrap();\n    big_record.put(\"username\", \"username\");\n    big_record.put(\"age\", 10i32);\n    big_record.put(\"phone\", \"000000000\");\n    big_record.put(\"housenum\", \"0000\");\n    big_record.put(\"address\", address);\n    let big_record = big_record.into();\n\n    benchmark(&small_schema, &small_record, \"S\", 10_000, 1);\n    benchmark(&big_schema, &big_record, \"B\", 10_000, 1);\n\n    benchmark(&small_schema, &small_record, \"S\", 1, 100_000);\n    benchmark(&small_schema, &small_record, \"S\", 100, 1000);\n    benchmark(&small_schema, &small_record, \"S\", 10_000, 10);\n\n    benchmark(&big_schema, &big_record, \"B\", 1, 100_000);\n    benchmark(&big_schema, &big_record, \"B\", 100, 1000);\n    benchmark(&big_schema, &big_record, \"B\", 10_000, 10);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","examples","to_value.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n#[derive(Debug, serde::Serialize)]\nstruct Test {\n    a: i64,\n    b: &'static str,\n}\n\nfn main() -> anyhow::Result<()> {\n    let test = Test { a: 27, b: \"foo\" };\n    let value = avro_rs::to_value(test)?;\n    println!(\"{:?}\", value);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","codec.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for all supported compression codecs in Avro.\nuse crate::{types::Value, AvroResult, Error};\nuse libflate::deflate::{Decoder, Encoder};\nuse std::io::{Read, Write};\nuse strum_macros::{EnumString, IntoStaticStr};\n\n/// The compression codec used to compress blocks.\n#[derive(Clone, Copy, Debug, PartialEq, EnumString, IntoStaticStr)]\n#[strum(serialize_all = \"kebab_case\")]\npub enum Codec {\n    /// The `Null` codec simply passes through data uncompressed.\n    Null,\n    /// The `Deflate` codec writes the data block using the deflate algorithm\n    /// as specified in RFC 1951, and typically implemented using the zlib library.\n    /// Note that this format (unlike the \"zlib format\" in RFC 1950) does not have a checksum.\n    Deflate,\n    #[cfg(feature = \"snappy\")]\n    /// The `Snappy` codec uses Google's [Snappy](http://google.github.io/snappy/)\n    /// compression library. Each compressed block is followed by the 4-byte, big-endian\n    /// CRC32 checksum of the uncompressed data in the block.\n    Snappy,\n}\n\nimpl From<Codec> for Value {\n    fn from(value: Codec) -> Self {\n        Self::Bytes(<&str>::from(value).as_bytes().to_vec())\n    }\n}\n\nimpl Codec {\n    /// Compress a stream of bytes in-place.\n    pub fn compress(self, stream: &mut Vec<u8>) -> AvroResult<()> {\n        match self {\n            Codec::Null => (),\n            Codec::Deflate => {\n                let mut encoder = Encoder::new(Vec::new());\n                encoder.write_all(stream).map_err(Error::DeflateCompress)?;\n                // Deflate errors seem to just be io::Error\n                *stream = encoder\n                    .finish()\n                    .into_result()\n                    .map_err(Error::DeflateCompressFinish)?;\n            }\n            #[cfg(feature = \"snappy\")]\n            Codec::Snappy => {\n                use byteorder::ByteOrder;\n\n                let mut encoded: Vec<u8> = vec![0; snap::raw::max_compress_len(stream.len())];\n                let compressed_size = snap::raw::Encoder::new()\n                    .compress(&stream[..], &mut encoded[..])\n                    .map_err(Error::SnappyCompress)?;\n\n                let crc = crc::crc32::checksum_ieee(&stream[..]);\n                byteorder::BigEndian::write_u32(&mut encoded[compressed_size..], crc);\n                encoded.truncate(compressed_size + 4);\n\n                *stream = encoded;\n            }\n        };\n\n        Ok(())\n    }\n\n    /// Decompress a stream of bytes in-place.\n    pub fn decompress(self, stream: &mut Vec<u8>) -> AvroResult<()> {\n        *stream = match self {\n            Codec::Null => return Ok(()),\n            Codec::Deflate => {\n                let mut decoded = Vec::new();\n                let mut decoder = Decoder::new(&stream[..]);\n                decoder\n                    .read_to_end(&mut decoded)\n                    .map_err(Error::DeflateDecompress)?;\n                decoded\n            }\n            #[cfg(feature = \"snappy\")]\n            Codec::Snappy => {\n                use byteorder::ByteOrder;\n\n                let decompressed_size = snap::raw::decompress_len(&stream[..stream.len() - 4])\n                    .map_err(Error::GetSnappyDecompressLen)?;\n                let mut decoded = vec![0; decompressed_size];\n                snap::raw::Decoder::new()\n                    .decompress(&stream[..stream.len() - 4], &mut decoded[..])\n                    .map_err(Error::SnappyDecompress)?;\n\n                let expected = byteorder::BigEndian::read_u32(&stream[stream.len() - 4..]);\n                let actual = crc::crc32::checksum_ieee(&decoded);\n\n                if expected != actual {\n                    return Err(Error::SnappyCrc32 { expected, actual });\n                }\n                decoded\n            }\n        };\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    const INPUT: &[u8] = b\"theanswertolifetheuniverseandeverythingis42theanswertolifetheuniverseandeverythingis4theanswertolifetheuniverseandeverythingis2\";\n\n    #[test]\n    fn null_compress_and_decompress() {\n        let codec = Codec::Null;\n        let mut stream = INPUT.to_vec();\n        codec.compress(&mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n        codec.decompress(&mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n    }\n\n    #[test]\n    fn deflate_compress_and_decompress() {\n        let codec = Codec::Deflate;\n        let mut stream = INPUT.to_vec();\n        codec.compress(&mut stream).unwrap();\n        assert_ne!(INPUT, stream.as_slice());\n        assert!(INPUT.len() > stream.len());\n        codec.decompress(&mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n    }\n\n    #[cfg(feature = \"snappy\")]\n    #[test]\n    fn snappy_compress_and_decompress() {\n        let codec = Codec::Snappy;\n        let mut stream = INPUT.to_vec();\n        codec.compress(&mut stream).unwrap();\n        assert_ne!(INPUT, stream.as_slice());\n        assert!(INPUT.len() > stream.len());\n        codec.decompress(&mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n    }\n\n    #[test]\n    fn codec_to_str() {\n        assert_eq!(<&str>::from(Codec::Null), \"null\");\n        assert_eq!(<&str>::from(Codec::Deflate), \"deflate\");\n\n        #[cfg(feature = \"snappy\")]\n        assert_eq!(<&str>::from(Codec::Snappy), \"snappy\");\n    }\n\n    #[test]\n    fn codec_from_str() {\n        use std::str::FromStr;\n\n        assert_eq!(Codec::from_str(\"null\").unwrap(), Codec::Null);\n        assert_eq!(Codec::from_str(\"deflate\").unwrap(), Codec::Deflate);\n\n        #[cfg(feature = \"snappy\")]\n        assert_eq!(Codec::from_str(\"snappy\").unwrap(), Codec::Snappy);\n\n        assert!(Codec::from_str(\"not a codec\").is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","de.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for serde-compatible deserialization.\nuse crate::{types::Value, Error};\nuse serde::{\n    de::{self, DeserializeSeed, Visitor},\n    forward_to_deserialize_any, Deserialize,\n};\nuse std::{\n    collections::{\n        hash_map::{Keys, Values},\n        HashMap,\n    },\n    slice::Iter,\n};\n\npub struct Deserializer<'de> {\n    input: &'de Value,\n}\n\nstruct SeqDeserializer<'de> {\n    input: Iter<'de, Value>,\n}\n\nstruct MapDeserializer<'de> {\n    input_keys: Keys<'de, String, Value>,\n    input_values: Values<'de, String, Value>,\n}\n\nstruct StructDeserializer<'de> {\n    input: Iter<'de, (String, Value)>,\n    value: Option<&'de Value>,\n}\n\npub struct EnumUnitDeserializer<'a> {\n    input: &'a str,\n}\n\npub struct EnumDeserializer<'de> {\n    input: &'de [(String, Value)],\n}\n\nimpl<'de> Deserializer<'de> {\n    pub fn new(input: &'de Value) -> Self {\n        Deserializer { input }\n    }\n}\n\nimpl<'de> SeqDeserializer<'de> {\n    pub fn new(input: &'de [Value]) -> Self {\n        SeqDeserializer {\n            input: input.iter(),\n        }\n    }\n}\n\nimpl<'de> MapDeserializer<'de> {\n    pub fn new(input: &'de HashMap<String, Value>) -> Self {\n        MapDeserializer {\n            input_keys: input.keys(), // input.keys().map(|k| Value::String(k.clone())).collect::<Vec<_>>().iter(),\n            input_values: input.values(),\n            // keys: input.keys().map(|s| Value::String(s.to_owned())).collect::<Vec<Value>>(),\n            // values: input.values().map(|s| s.to_owned()).collect::<Vec<Value>>(),\n        }\n    }\n}\n\nimpl<'de> StructDeserializer<'de> {\n    pub fn new(input: &'de [(String, Value)]) -> Self {\n        StructDeserializer {\n            input: input.iter(),\n            value: None,\n        }\n    }\n}\n\nimpl<'a> EnumUnitDeserializer<'a> {\n    pub fn new(input: &'a str) -> Self {\n        EnumUnitDeserializer { input }\n    }\n}\n\nimpl<'de> EnumDeserializer<'de> {\n    pub fn new(input: &'de [(String, Value)]) -> Self {\n        EnumDeserializer { input }\n    }\n}\n\nimpl<'de> de::EnumAccess<'de> for EnumUnitDeserializer<'de> {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        Ok((\n            seed.deserialize(StringDeserializer {\n                input: self.input.to_owned(),\n            })?,\n            self,\n        ))\n    }\n}\n\nimpl<'de> de::VariantAccess<'de> for EnumUnitDeserializer<'de> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        Err(de::Error::custom(\"Unexpected Newtype variant\"))\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        Err(de::Error::custom(\"Unexpected tuple variant\"))\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        Err(de::Error::custom(\"Unexpected struct variant\"))\n    }\n}\n\nimpl<'de> de::EnumAccess<'de> for EnumDeserializer<'de> {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        self.input.first().map_or(\n            Err(de::Error::custom(\"A record must have a least one field\")),\n            |item| match (item.0.as_ref(), &item.1) {\n                (\"type\", Value::String(x)) => Ok((\n                    seed.deserialize(StringDeserializer {\n                        input: x.to_owned(),\n                    })?,\n                    self,\n                )),\n                (field, Value::String(_)) => Err(de::Error::custom(format!(\n                    \"Expected first field named 'type': got '{}' instead\",\n                    field\n                ))),\n                (_, _) => Err(de::Error::custom(\n                    \"Expected first field of type String for the type name\".to_string(),\n                )),\n            },\n        )\n    }\n}\n\nimpl<'de> de::VariantAccess<'de> for EnumDeserializer<'de> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        self.input.get(1).map_or(\n            Err(de::Error::custom(\n                \"Expected a newtype variant, got nothing instead.\",\n            )),\n            |item| seed.deserialize(&Deserializer::new(&item.1)),\n        )\n    }\n\n    fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.input.get(1).map_or(\n            Err(de::Error::custom(\n                \"Expected a tuple variant, got nothing instead.\",\n            )),\n            |item| de::Deserializer::deserialize_seq(&Deserializer::new(&item.1), visitor),\n        )\n    }\n\n    fn struct_variant<V>(\n        self,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.input.get(1).map_or(\n            Err(de::Error::custom(\"Expected a struct variant, got nothing\")),\n            |item| {\n                de::Deserializer::deserialize_struct(\n                    &Deserializer::new(&item.1),\n                    \"\",\n                    fields,\n                    visitor,\n                )\n            },\n        )\n    }\n}\n\nimpl<'a, 'de> de::Deserializer<'de> for &'a Deserializer<'de> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.input {\n            Value::Null => visitor.visit_unit(),\n            &Value::Boolean(b) => visitor.visit_bool(b),\n            Value::Int(i) | Value::Date(i) | Value::TimeMillis(i) => visitor.visit_i32(*i),\n            Value::Long(i)\n            | Value::TimeMicros(i)\n            | Value::TimestampMillis(i)\n            | Value::TimestampMicros(i) => visitor.visit_i64(*i),\n            &Value::Float(f) => visitor.visit_f32(f),\n            &Value::Double(d) => visitor.visit_f64(d),\n            Value::Union(u) => match **u {\n                Value::Null => visitor.visit_unit(),\n                Value::Boolean(b) => visitor.visit_bool(b),\n                Value::Int(i) => visitor.visit_i32(i),\n                Value::Long(i) => visitor.visit_i64(i),\n                Value::Float(f) => visitor.visit_f32(f),\n                Value::Double(d) => visitor.visit_f64(d),\n                _ => Err(de::Error::custom(\"Unsupported union\")),\n            },\n            Value::Record(ref fields) => visitor.visit_map(StructDeserializer::new(fields)),\n            Value::Array(ref fields) => visitor.visit_seq(SeqDeserializer::new(fields)),\n            value => Err(de::Error::custom(format!(\n                \"incorrect value of type: {:?}\",\n                crate::schema::SchemaKind::from(value)\n            ))),\n        }\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64\n    }\n\n    fn deserialize_char<V>(self, _: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        Err(de::Error::custom(\"avro does not support char\"))\n    }\n\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            Value::String(ref s) => visitor.visit_str(s),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) => ::std::str::from_utf8(bytes)\n                .map_err(|e| de::Error::custom(e.to_string()))\n                .and_then(|s| visitor.visit_str(s)),\n            Value::Uuid(ref u) => visitor.visit_str(&u.to_string()),\n            _ => Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            Value::String(ref s) => visitor.visit_string(s.to_owned()),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) => {\n                String::from_utf8(bytes.to_owned())\n                    .map_err(|e| de::Error::custom(e.to_string()))\n                    .and_then(|s| visitor.visit_string(s))\n            }\n            Value::Union(ref x) => match **x {\n                Value::String(ref s) => visitor.visit_string(s.to_owned()),\n                _ => Err(de::Error::custom(\"not a string|bytes|fixed\")),\n            },\n            _ => Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            Value::String(ref s) => visitor.visit_bytes(s.as_bytes()),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) => visitor.visit_bytes(bytes),\n            Value::Uuid(ref u) => visitor.visit_bytes(u.as_bytes()),\n            _ => Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            Value::String(ref s) => visitor.visit_byte_buf(s.clone().into_bytes()),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) => {\n                visitor.visit_byte_buf(bytes.to_owned())\n            }\n            _ => Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            Value::Union(ref inner) if inner.as_ref() == &Value::Null => visitor.visit_none(),\n            Value::Union(ref inner) => visitor.visit_some(&Deserializer::new(inner)),\n            _ => Err(de::Error::custom(\"not a union\")),\n        }\n    }\n\n    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            Value::Null => visitor.visit_unit(),\n            _ => Err(de::Error::custom(\"not a null\")),\n        }\n    }\n\n    fn deserialize_unit_struct<V>(\n        self,\n        _: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_unit(visitor)\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        _: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            Value::Array(ref items) => visitor.visit_seq(SeqDeserializer::new(items)),\n            Value::Union(ref inner) => match **inner {\n                Value::Array(ref items) => visitor.visit_seq(SeqDeserializer::new(items)),\n                _ => Err(de::Error::custom(\"not an array\")),\n            },\n            _ => Err(de::Error::custom(\"not an array\")),\n        }\n    }\n\n    fn deserialize_tuple<V>(self, _: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_tuple_struct<V>(\n        self,\n        _: &'static str,\n        _: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            Value::Map(ref items) => visitor.visit_map(MapDeserializer::new(items)),\n            _ => Err(de::Error::custom(\"not a map\")),\n        }\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        _: &'static str,\n        _: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            Value::Record(ref fields) => visitor.visit_map(StructDeserializer::new(fields)),\n            Value::Union(ref inner) => match **inner {\n                Value::Record(ref fields) => visitor.visit_map(StructDeserializer::new(fields)),\n                _ => Err(de::Error::custom(\"not a record\")),\n            },\n            _ => Err(de::Error::custom(\"not a record\")),\n        }\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        _: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.input {\n            // This branch can be anything...\n            Value::Record(ref fields) => visitor.visit_enum(EnumDeserializer::new(fields)),\n            // This has to be a unit Enum\n            Value::Enum(_index, ref field) => visitor.visit_enum(EnumUnitDeserializer::new(field)),\n            _ => Err(de::Error::custom(\"not an enum\")),\n        }\n    }\n\n    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_any(visitor)\n    }\n}\n\nimpl<'de> de::SeqAccess<'de> for SeqDeserializer<'de> {\n    type Error = Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.input.next() {\n            Some(item) => seed.deserialize(&Deserializer::new(item)).map(Some),\n            None => Ok(None),\n        }\n    }\n}\n\nimpl<'de> de::MapAccess<'de> for MapDeserializer<'de> {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n    where\n        K: DeserializeSeed<'de>,\n    {\n        match self.input_keys.next() {\n            Some(key) => seed\n                .deserialize(StringDeserializer {\n                    input: (*key).clone(),\n                })\n                .map(Some),\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        match self.input_values.next() {\n            Some(value) => seed.deserialize(&Deserializer::new(value)),\n            None => Err(de::Error::custom(\"should not happen - too many values\")),\n        }\n    }\n}\n\nimpl<'de> de::MapAccess<'de> for StructDeserializer<'de> {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n    where\n        K: DeserializeSeed<'de>,\n    {\n        match self.input.next() {\n            Some(item) => {\n                let (ref field, ref value) = *item;\n                self.value = Some(value);\n                seed.deserialize(StringDeserializer {\n                    input: field.clone(),\n                })\n                .map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        match self.value.take() {\n            Some(value) => seed.deserialize(&Deserializer::new(value)),\n            None => Err(de::Error::custom(\"should not happen - too many values\")),\n        }\n    }\n}\n\n#[derive(Clone)]\nstruct StringDeserializer {\n    input: String,\n}\n\nimpl<'de> de::Deserializer<'de> for StringDeserializer {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_string(self.input)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\n\n/// Interpret a `Value` as an instance of type `D`.\n///\n/// This conversion can fail if the structure of the `Value` does not match the\n/// structure expected by `D`.\npub fn from_value<'de, D: Deserialize<'de>>(value: &'de Value) -> Result<D, Error> {\n    let de = Deserializer::new(value);\n    D::deserialize(&de)\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::Serialize;\n    use uuid::Uuid;\n\n    use super::*;\n\n    #[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]\n    struct Test {\n        a: i64,\n        b: String,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestInner {\n        a: Test,\n        b: i32,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitExternalEnum {\n        a: UnitExternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    enum UnitExternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitInternalEnum {\n        a: UnitInternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(tag = \"t\")]\n    enum UnitInternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitAdjacentEnum {\n        a: UnitAdjacentEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum UnitAdjacentEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitUntaggedEnum {\n        a: UnitUntaggedEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(untagged)]\n    enum UnitUntaggedEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct TestSingleValueExternalEnum {\n        a: SingleValueExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    enum SingleValueExternalEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct TestStructExternalEnum {\n        a: StructExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    enum StructExternalEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct TestTupleExternalEnum {\n        a: TupleExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    enum TupleExternalEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    #[test]\n    fn test_from_value() {\n        let test = Value::Record(vec![\n            (\"a\".to_owned(), Value::Long(27)),\n            (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n        ]);\n        let expected = Test {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n        let final_value: Test = from_value(&test).unwrap();\n        assert_eq!(final_value, expected);\n\n        let test_inner = Value::Record(vec![\n            (\n                \"a\".to_owned(),\n                Value::Record(vec![\n                    (\"a\".to_owned(), Value::Long(27)),\n                    (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n                ]),\n            ),\n            (\"b\".to_owned(), Value::Int(35)),\n        ]);\n\n        let expected_inner = TestInner { a: expected, b: 35 };\n        let final_value: TestInner = from_value(&test_inner).unwrap();\n        assert_eq!(final_value, expected_inner)\n    }\n    #[test]\n    fn test_from_value_unit_enum() {\n        let expected = TestUnitExternalEnum {\n            a: UnitExternalEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\"a\".to_owned(), Value::Enum(0, \"Val1\".to_owned()))]);\n        let final_value: TestUnitExternalEnum = from_value(&test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit external enum\"\n        );\n\n        let expected = TestUnitInternalEnum {\n            a: UnitInternalEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n        let final_value: TestUnitInternalEnum = from_value(&test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit internal enum\"\n        );\n        let expected = TestUnitAdjacentEnum {\n            a: UnitAdjacentEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n        let final_value: TestUnitAdjacentEnum = from_value(&test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit adjacent enum\"\n        );\n        let expected = TestUnitUntaggedEnum {\n            a: UnitUntaggedEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\"a\".to_owned(), Value::Null)]);\n        let final_value: TestUnitUntaggedEnum = from_value(&test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit untagged enum\"\n        );\n    }\n\n    #[test]\n    fn test_from_value_single_value_enum() {\n        let expected = TestSingleValueExternalEnum {\n            a: SingleValueExternalEnum::Double(64.0),\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Double\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Double(64.0))),\n                ),\n            ]),\n        )]);\n        let final_value: TestSingleValueExternalEnum = from_value(&test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing single value external enum(union)\"\n        );\n    }\n\n    #[test]\n    fn test_from_value_struct_enum() {\n        let expected = TestStructExternalEnum {\n            a: StructExternalEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Record(vec![\n                        (\"x\".to_owned(), Value::Float(1.0)),\n                        (\"y\".to_owned(), Value::Float(2.0)),\n                    ]))),\n                ),\n            ]),\n        )]);\n        let final_value: TestStructExternalEnum = from_value(&test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"error deserializing struct external enum(union)\"\n        );\n    }\n\n    #[test]\n    fn test_from_value_tuple_enum() {\n        let expected = TestTupleExternalEnum {\n            a: TupleExternalEnum::Val1(1.0, 2.0),\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Array(vec![\n                        Value::Float(1.0),\n                        Value::Float(2.0),\n                    ]))),\n                ),\n            ]),\n        )]);\n        let final_value: TestTupleExternalEnum = from_value(&test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"error serializing tuple external enum(union)\"\n        );\n    }\n\n    type TestResult<T> = Result<T, Box<dyn std::error::Error>>;\n\n    #[test]\n    fn test_date() -> TestResult<()> {\n        let raw_value = 1;\n        let value = Value::Date(raw_value);\n        let result = crate::from_value::<i32>(&value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_time_millis() -> TestResult<()> {\n        let raw_value = 1;\n        let value = Value::TimeMillis(raw_value);\n        let result = crate::from_value::<i32>(&value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_time_micros() -> TestResult<()> {\n        let raw_value = 1;\n        let value = Value::TimeMicros(raw_value);\n        let result = crate::from_value::<i64>(&value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_timestamp_millis() -> TestResult<()> {\n        let raw_value = 1;\n        let value = Value::TimestampMillis(raw_value);\n        let result = crate::from_value::<i64>(&value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_timestamp_micros() -> TestResult<()> {\n        let raw_value = 1;\n        let value = Value::TimestampMicros(raw_value);\n        let result = crate::from_value::<i64>(&value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_from_value_uuid_str() -> TestResult<()> {\n        let raw_value = \"9ec535ff-3e2a-45bd-91d3-0a01321b5a49\";\n        let value = Value::Uuid(Uuid::parse_str(raw_value).unwrap());\n        let result = crate::from_value::<Uuid>(&value)?;\n        assert_eq!(result.to_string(), raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_from_value_uuid_slice() -> TestResult<()> {\n        let raw_value = &[4, 54, 67, 12, 43, 2, 2, 76, 32, 50, 87, 5, 1, 33, 43, 87];\n        let value = Value::Uuid(Uuid::from_slice(raw_value)?);\n        let result = crate::from_value::<Uuid>(&value)?;\n        assert_eq!(result.as_bytes(), raw_value);\n        Ok(())\n    }\n}\n","traces":[{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":158},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","decimal.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{AvroResult, Error};\nuse num_bigint::{BigInt, Sign};\n\n#[derive(Debug, Clone)]\npub struct Decimal {\n    value: BigInt,\n    len: usize,\n}\n\n// We only care about value equality, not byte length. Can two equal `BigInt`s have two different\n// byte lengths?\nimpl PartialEq for Decimal {\n    fn eq(&self, other: &Self) -> bool {\n        self.value == other.value\n    }\n}\n\nimpl Decimal {\n    pub(crate) fn len(&self) -> usize {\n        self.len\n    }\n\n    fn to_vec(&self) -> AvroResult<Vec<u8>> {\n        self.to_sign_extended_bytes_with_len(self.len)\n    }\n\n    pub(crate) fn to_sign_extended_bytes_with_len(&self, len: usize) -> AvroResult<Vec<u8>> {\n        let sign_byte = 0xFF * u8::from(self.value.sign() == Sign::Minus);\n        let mut decimal_bytes = vec![sign_byte; len];\n        let raw_bytes = self.value.to_signed_bytes_be();\n        let num_raw_bytes = raw_bytes.len();\n        let start_byte_index = len.checked_sub(num_raw_bytes).ok_or(Error::SignExtend {\n            requested: len,\n            needed: num_raw_bytes,\n        })?;\n        decimal_bytes[start_byte_index..].copy_from_slice(&raw_bytes);\n        Ok(decimal_bytes)\n    }\n}\n\nimpl std::convert::TryFrom<&Decimal> for Vec<u8> {\n    type Error = Error;\n\n    fn try_from(decimal: &Decimal) -> Result<Self, Self::Error> {\n        decimal.to_vec()\n    }\n}\n\nimpl<T: AsRef<[u8]>> From<T> for Decimal {\n    fn from(bytes: T) -> Self {\n        let bytes_ref = bytes.as_ref();\n        Self {\n            value: BigInt::from_signed_bytes_be(bytes_ref),\n            len: bytes_ref.len(),\n        }\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","decode.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{\n    decimal::Decimal,\n    duration::Duration,\n    schema::Schema,\n    types::Value,\n    util::{safe_len, zag_i32, zag_i64},\n    AvroResult, Error,\n};\nuse std::{collections::HashMap, convert::TryFrom, io::Read, str::FromStr};\nuse uuid::Uuid;\n\n#[inline]\nfn decode_long<R: Read>(reader: &mut R) -> AvroResult<Value> {\n    zag_i64(reader).map(Value::Long)\n}\n\n#[inline]\nfn decode_int<R: Read>(reader: &mut R) -> AvroResult<Value> {\n    zag_i32(reader).map(Value::Int)\n}\n\n#[inline]\nfn decode_len<R: Read>(reader: &mut R) -> AvroResult<usize> {\n    let len = zag_i64(reader)?;\n    safe_len(usize::try_from(len).map_err(|e| Error::ConvertI64ToUsize(e, len))?)\n}\n\n/// Decode the length of a sequence.\n///\n/// Maps and arrays are 0-terminated, 0i64 is also encoded as 0 in Avro reading a length of 0 means\n/// the end of the map or array.\nfn decode_seq_len<R: Read>(reader: &mut R) -> AvroResult<usize> {\n    let raw_len = zag_i64(reader)?;\n    safe_len(\n        usize::try_from(match raw_len.cmp(&0) {\n            std::cmp::Ordering::Equal => return Ok(0),\n            std::cmp::Ordering::Less => {\n                let _size = zag_i64(reader)?;\n                -raw_len\n            }\n            std::cmp::Ordering::Greater => raw_len,\n        })\n        .map_err(|e| Error::ConvertI64ToUsize(e, raw_len))?,\n    )\n}\n\n/// Decode a `Value` from avro format given its `Schema`.\npub fn decode<R: Read>(schema: &Schema, reader: &mut R) -> AvroResult<Value> {\n    match *schema {\n        Schema::Null => Ok(Value::Null),\n        Schema::Boolean => {\n            let mut buf = [0u8; 1];\n            reader\n                .read_exact(&mut buf[..])\n                .map_err(Error::ReadBoolean)?;\n\n            match buf[0] {\n                0u8 => Ok(Value::Boolean(false)),\n                1u8 => Ok(Value::Boolean(true)),\n                _ => Err(Error::BoolValue(buf[0])),\n            }\n        }\n        Schema::Decimal { ref inner, .. } => match &**inner {\n            Schema::Fixed { .. } => match decode(inner, reader)? {\n                Value::Fixed(_, bytes) => Ok(Value::Decimal(Decimal::from(bytes))),\n                value => Err(Error::FixedValue(value.into())),\n            },\n            Schema::Bytes => match decode(inner, reader)? {\n                Value::Bytes(bytes) => Ok(Value::Decimal(Decimal::from(bytes))),\n                value => Err(Error::BytesValue(value.into())),\n            },\n            schema => Err(Error::ResolveDecimalSchema(schema.into())),\n        },\n        Schema::Uuid => Ok(Value::Uuid(\n            Uuid::from_str(match decode(&Schema::String, reader)? {\n                Value::String(ref s) => s,\n                value => return Err(Error::GetUuidFromStringValue(value.into())),\n            })\n            .map_err(Error::ConvertStrToUuid)?,\n        )),\n        Schema::Int => decode_int(reader),\n        Schema::Date => zag_i32(reader).map(Value::Date),\n        Schema::TimeMillis => zag_i32(reader).map(Value::TimeMillis),\n        Schema::Long => decode_long(reader),\n        Schema::TimeMicros => zag_i64(reader).map(Value::TimeMicros),\n        Schema::TimestampMillis => zag_i64(reader).map(Value::TimestampMillis),\n        Schema::TimestampMicros => zag_i64(reader).map(Value::TimestampMicros),\n        Schema::Duration => {\n            let mut buf = [0u8; 12];\n            reader.read_exact(&mut buf).map_err(Error::ReadDuration)?;\n            Ok(Value::Duration(Duration::from(buf)))\n        }\n        Schema::Float => {\n            let mut buf = [0u8; std::mem::size_of::<f32>()];\n            reader.read_exact(&mut buf[..]).map_err(Error::ReadFloat)?;\n            Ok(Value::Float(f32::from_le_bytes(buf)))\n        }\n        Schema::Double => {\n            let mut buf = [0u8; std::mem::size_of::<f64>()];\n            reader.read_exact(&mut buf[..]).map_err(Error::ReadDouble)?;\n            Ok(Value::Double(f64::from_le_bytes(buf)))\n        }\n        Schema::Bytes => {\n            let len = decode_len(reader)?;\n            let mut buf = vec![0u8; len];\n            reader.read_exact(&mut buf).map_err(Error::ReadBytes)?;\n            Ok(Value::Bytes(buf))\n        }\n        Schema::String => {\n            let len = decode_len(reader)?;\n            let mut buf = vec![0u8; len];\n            reader.read_exact(&mut buf).map_err(Error::ReadString)?;\n\n            Ok(Value::String(\n                String::from_utf8(buf).map_err(Error::ConvertToUtf8)?,\n            ))\n        }\n        Schema::Fixed { size, .. } => {\n            let mut buf = vec![0u8; size];\n            reader\n                .read_exact(&mut buf)\n                .map_err(|e| Error::ReadFixed(e, size))?;\n            Ok(Value::Fixed(size, buf))\n        }\n        Schema::Array(ref inner) => {\n            let mut items = Vec::new();\n\n            loop {\n                let len = decode_seq_len(reader)?;\n                if len == 0 {\n                    break;\n                }\n\n                items.reserve(len);\n                for _ in 0..len {\n                    items.push(decode(inner, reader)?);\n                }\n            }\n\n            Ok(Value::Array(items))\n        }\n        Schema::Map(ref inner) => {\n            let mut items = HashMap::new();\n\n            loop {\n                let len = decode_seq_len(reader)?;\n                if len == 0 {\n                    break;\n                }\n\n                items.reserve(len);\n                for _ in 0..len {\n                    match decode(&Schema::String, reader)? {\n                        Value::String(key) => {\n                            let value = decode(inner, reader)?;\n                            items.insert(key, value);\n                        }\n                        value => return Err(Error::MapKeyType(value.into())),\n                    }\n                }\n            }\n\n            Ok(Value::Map(items))\n        }\n        Schema::Union(ref inner) => {\n            let index = zag_i64(reader)?;\n            let variants = inner.variants();\n            let variant = variants\n                .get(usize::try_from(index).map_err(|e| Error::ConvertI64ToUsize(e, index))?)\n                .ok_or_else(|| Error::GetUnionVariant {\n                    index,\n                    num_variants: variants.len(),\n                })?;\n            let value = decode(variant, reader)?;\n            Ok(Value::Union(Box::new(value)))\n        }\n        Schema::Record { ref fields, .. } => {\n            // Benchmarks indicate ~10% improvement using this method.\n            let mut items = Vec::with_capacity(fields.len());\n            for field in fields {\n                // TODO: This clone is also expensive. See if we can do away with it...\n                items.push((field.name.clone(), decode(&field.schema, reader)?));\n            }\n            Ok(Value::Record(items))\n        }\n        Schema::Enum { ref symbols, .. } => {\n            Ok(if let Value::Int(raw_index) = decode_int(reader)? {\n                let index = usize::try_from(raw_index)\n                    .map_err(|e| Error::ConvertI32ToUsize(e, raw_index))?;\n                if (0..=symbols.len()).contains(&index) {\n                    let symbol = symbols[index].clone();\n                    Value::Enum(raw_index, symbol)\n                } else {\n                    return Err(Error::GetEnumValue {\n                        index,\n                        nsymbols: symbols.len(),\n                    });\n                }\n            } else {\n                return Err(Error::GetEnumSymbol);\n            })\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        decode::decode,\n        schema::Schema,\n        types::{\n            Value,\n            Value::{Array, Int, Map},\n        },\n        Decimal,\n    };\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_decode_array_without_size() {\n        let mut input: &[u8] = &[6, 2, 4, 6, 0];\n        let result = decode(&Schema::Array(Box::new(Schema::Int)), &mut input);\n        assert_eq!(Array(vec!(Int(1), Int(2), Int(3))), result.unwrap());\n    }\n\n    #[test]\n    fn test_decode_array_with_size() {\n        let mut input: &[u8] = &[5, 6, 2, 4, 6, 0];\n        let result = decode(&Schema::Array(Box::new(Schema::Int)), &mut input);\n        assert_eq!(Array(vec!(Int(1), Int(2), Int(3))), result.unwrap());\n    }\n\n    #[test]\n    fn test_decode_map_without_size() {\n        let mut input: &[u8] = &[0x02, 0x08, 0x74, 0x65, 0x73, 0x74, 0x02, 0x00];\n        let result = decode(&Schema::Map(Box::new(Schema::Int)), &mut input);\n        let mut expected = HashMap::new();\n        expected.insert(String::from(\"test\"), Int(1));\n        assert_eq!(Map(expected), result.unwrap());\n    }\n\n    #[test]\n    fn test_decode_map_with_size() {\n        let mut input: &[u8] = &[0x01, 0x0C, 0x08, 0x74, 0x65, 0x73, 0x74, 0x02, 0x00];\n        let result = decode(&Schema::Map(Box::new(Schema::Int)), &mut input);\n        let mut expected = HashMap::new();\n        expected.insert(String::from(\"test\"), Int(1));\n        assert_eq!(Map(expected), result.unwrap());\n    }\n\n    #[test]\n    fn test_negative_decimal_value() {\n        use crate::{encode::encode, schema::Name};\n        use num_bigint::ToBigInt;\n        let inner = Box::new(Schema::Fixed {\n            size: 2,\n            name: Name::new(\"decimal\"),\n        });\n        let schema = Schema::Decimal {\n            inner,\n            precision: 4,\n            scale: 2,\n        };\n        let bigint = (-423).to_bigint().unwrap();\n        let value = Value::Decimal(Decimal::from(bigint.to_signed_bytes_be()));\n\n        let mut buffer = Vec::new();\n        encode(&value, &schema, &mut buffer);\n\n        let mut bytes = &buffer[..];\n        let result = decode(&schema, &mut bytes).unwrap();\n        assert_eq!(result, value);\n    }\n\n    #[test]\n    fn test_decode_decimal_with_bigger_than_necessary_size() {\n        use crate::{encode::encode, schema::Name};\n        use num_bigint::ToBigInt;\n        let inner = Box::new(Schema::Fixed {\n            size: 13,\n            name: Name::new(\"decimal\"),\n        });\n        let schema = Schema::Decimal {\n            inner,\n            precision: 4,\n            scale: 2,\n        };\n        let value = Value::Decimal(Decimal::from(\n            ((-423).to_bigint().unwrap()).to_signed_bytes_be(),\n        ));\n        let mut buffer = Vec::<u8>::new();\n\n        encode(&value, &schema, &mut buffer);\n        let mut bytes: &[u8] = &buffer[..];\n        let result = decode(&schema, &mut bytes).unwrap();\n        assert_eq!(result, value);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":127},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","duration.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse byteorder::LittleEndian;\nuse zerocopy::U32;\n\n/// A struct representing duration that hides the details of endianness and conversion between\n/// platform-native u32 and byte arrays.\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Duration {\n    months: Months,\n    days: Days,\n    millis: Millis,\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Months(U32<LittleEndian>);\n\nimpl Months {\n    pub fn new(months: u32) -> Self {\n        Self(U32::new(months))\n    }\n}\n\nimpl From<Months> for u32 {\n    fn from(days: Months) -> Self {\n        days.0.get()\n    }\n}\n\nimpl From<[u8; 4]> for Months {\n    fn from(bytes: [u8; 4]) -> Self {\n        Self(U32::from(bytes))\n    }\n}\n\nimpl AsRef<[u8; 4]> for Months {\n    fn as_ref(&self) -> &[u8; 4] {\n        self.0.as_ref()\n    }\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Days(U32<LittleEndian>);\n\nimpl Days {\n    pub fn new(days: u32) -> Self {\n        Self(U32::new(days))\n    }\n}\n\nimpl From<Days> for u32 {\n    fn from(days: Days) -> Self {\n        days.0.get()\n    }\n}\n\nimpl From<[u8; 4]> for Days {\n    fn from(bytes: [u8; 4]) -> Self {\n        Self(U32::from(bytes))\n    }\n}\n\nimpl AsRef<[u8; 4]> for Days {\n    fn as_ref(&self) -> &[u8; 4] {\n        self.0.as_ref()\n    }\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Millis(U32<LittleEndian>);\n\nimpl Millis {\n    pub fn new(millis: u32) -> Self {\n        Self(U32::new(millis))\n    }\n}\n\nimpl From<Millis> for u32 {\n    fn from(days: Millis) -> Self {\n        days.0.get()\n    }\n}\n\nimpl From<[u8; 4]> for Millis {\n    fn from(bytes: [u8; 4]) -> Self {\n        Self(U32::from(bytes))\n    }\n}\n\nimpl AsRef<[u8; 4]> for Millis {\n    fn as_ref(&self) -> &[u8; 4] {\n        self.0.as_ref()\n    }\n}\n\nimpl Duration {\n    /// Construct a new `Duration`.\n    pub fn new(months: Months, days: Days, millis: Millis) -> Self {\n        Self {\n            months,\n            days,\n            millis,\n        }\n    }\n\n    /// Return the number of months in this duration.\n    pub fn months(&self) -> Months {\n        self.months\n    }\n\n    /// Return the number of days in this duration.\n    pub fn days(&self) -> Days {\n        self.days\n    }\n\n    /// Return the number of milliseconds in this duration.\n    pub fn millis(&self) -> Millis {\n        self.millis\n    }\n}\n\nimpl From<Duration> for [u8; 12] {\n    fn from(duration: Duration) -> Self {\n        let mut bytes = [0u8; 12];\n        bytes[0..4].copy_from_slice(duration.months.as_ref());\n        bytes[4..8].copy_from_slice(duration.days.as_ref());\n        bytes[8..12].copy_from_slice(duration.millis.as_ref());\n        bytes\n    }\n}\n\nimpl From<[u8; 12]> for Duration {\n    fn from(bytes: [u8; 12]) -> Self {\n        Self {\n            months: Months::from([bytes[0], bytes[1], bytes[2], bytes[3]]),\n            days: Days::from([bytes[4], bytes[5], bytes[6], bytes[7]]),\n            millis: Millis::from([bytes[8], bytes[9], bytes[10], bytes[11]]),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","encode.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{\n    schema::Schema,\n    types::Value,\n    util::{zig_i32, zig_i64},\n};\nuse std::convert::TryInto;\n\n/// Encode a `Value` into avro format.\n///\n/// **NOTE** This will not perform schema validation. The value is assumed to\n/// be valid with regards to the schema. Schema are needed only to guide the\n/// encoding for complex type values.\npub fn encode(value: &Value, schema: &Schema, buffer: &mut Vec<u8>) {\n    encode_ref(value, schema, buffer)\n}\n\nfn encode_bytes<B: AsRef<[u8]> + ?Sized>(s: &B, buffer: &mut Vec<u8>) {\n    let bytes = s.as_ref();\n    encode(&Value::Long(bytes.len() as i64), &Schema::Long, buffer);\n    buffer.extend_from_slice(bytes);\n}\n\nfn encode_long(i: i64, buffer: &mut Vec<u8>) {\n    zig_i64(i, buffer)\n}\n\nfn encode_int(i: i32, buffer: &mut Vec<u8>) {\n    zig_i32(i, buffer)\n}\n\n/// Encode a `Value` into avro format.\n///\n/// **NOTE** This will not perform schema validation. The value is assumed to\n/// be valid with regards to the schema. Schema are needed only to guide the\n/// encoding for complex type values.\npub fn encode_ref(value: &Value, schema: &Schema, buffer: &mut Vec<u8>) {\n    match value {\n        Value::Null => (),\n        Value::Boolean(b) => buffer.push(if *b { 1u8 } else { 0u8 }),\n        // Pattern | Pattern here to signify that these _must_ have the same encoding.\n        Value::Int(i) | Value::Date(i) | Value::TimeMillis(i) => encode_int(*i, buffer),\n        Value::Long(i)\n        | Value::TimestampMillis(i)\n        | Value::TimestampMicros(i)\n        | Value::TimeMicros(i) => encode_long(*i, buffer),\n        Value::Float(x) => buffer.extend_from_slice(&x.to_le_bytes()),\n        Value::Double(x) => buffer.extend_from_slice(&x.to_le_bytes()),\n        Value::Decimal(decimal) => match schema {\n            Schema::Decimal { inner, .. } => match *inner.clone() {\n                Schema::Fixed { size, .. } => {\n                    let bytes = decimal.to_sign_extended_bytes_with_len(size).unwrap();\n                    let num_bytes = bytes.len();\n                    if num_bytes != size {\n                        panic!(\n                            \"signed decimal bytes length {} not equal to fixed schema size {}\",\n                            num_bytes, size\n                        );\n                    }\n                    encode(&Value::Fixed(size, bytes), inner, buffer)\n                }\n                Schema::Bytes => encode(&Value::Bytes(decimal.try_into().unwrap()), inner, buffer),\n                _ => panic!(\"invalid inner type for decimal: {:?}\", inner),\n            },\n            _ => panic!(\"invalid type for decimal: {:?}\", schema),\n        },\n        &Value::Duration(duration) => {\n            let slice: [u8; 12] = duration.into();\n            buffer.extend_from_slice(&slice);\n        }\n        Value::Uuid(uuid) => encode_bytes(&uuid.to_string(), buffer),\n        Value::Bytes(bytes) => match *schema {\n            Schema::Bytes => encode_bytes(bytes, buffer),\n            Schema::Fixed { .. } => buffer.extend(bytes),\n            _ => (),\n        },\n        Value::String(s) => match *schema {\n            Schema::String => {\n                encode_bytes(s, buffer);\n            }\n            Schema::Enum { ref symbols, .. } => {\n                if let Some(index) = symbols.iter().position(|item| item == s) {\n                    encode_int(index as i32, buffer);\n                }\n            }\n            _ => (),\n        },\n        Value::Fixed(_, bytes) => buffer.extend(bytes),\n        Value::Enum(i, _) => encode_int(*i, buffer),\n        Value::Union(item) => {\n            if let Schema::Union(ref inner) = *schema {\n                // Find the schema that is matched here. Due to validation, this should always\n                // return a value.\n                let (idx, inner_schema) = inner\n                    .find_schema(item)\n                    .expect(\"Invalid Union validation occurred\");\n                encode_long(idx as i64, buffer);\n                encode_ref(&*item, inner_schema, buffer);\n            }\n        }\n        Value::Array(items) => {\n            if let Schema::Array(ref inner) = *schema {\n                if !items.is_empty() {\n                    encode_long(items.len() as i64, buffer);\n                    for item in items.iter() {\n                        encode_ref(item, inner, buffer);\n                    }\n                }\n                buffer.push(0u8);\n            }\n        }\n        Value::Map(items) => {\n            if let Schema::Map(ref inner) = *schema {\n                if !items.is_empty() {\n                    encode_long(items.len() as i64, buffer);\n                    for (key, value) in items {\n                        encode_bytes(key, buffer);\n                        encode_ref(value, inner, buffer);\n                    }\n                }\n                buffer.push(0u8);\n            }\n        }\n        Value::Record(fields) => {\n            if let Schema::Record {\n                fields: ref schema_fields,\n                ..\n            } = *schema\n            {\n                for (i, &(_, ref value)) in fields.iter().enumerate() {\n                    encode_ref(value, &schema_fields[i].schema, buffer);\n                }\n            }\n        }\n    }\n}\n\npub fn encode_to_vec(value: &Value, schema: &Schema) -> Vec<u8> {\n    let mut buffer = Vec::new();\n    encode(value, schema, &mut buffer);\n    buffer\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_encode_empty_array() {\n        let mut buf = Vec::new();\n        let empty: Vec<Value> = Vec::new();\n        encode(\n            &Value::Array(empty),\n            &Schema::Array(Box::new(Schema::Int)),\n            &mut buf,\n        );\n        assert_eq!(vec![0u8], buf);\n    }\n\n    #[test]\n    fn test_encode_empty_map() {\n        let mut buf = Vec::new();\n        let empty: HashMap<String, Value> = HashMap::new();\n        encode(\n            &Value::Map(empty),\n            &Schema::Map(Box::new(Schema::Int)),\n            &mut buf,\n        );\n        assert_eq!(vec![0u8], buf);\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","error.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{schema::SchemaKind, types::ValueKind};\nuse std::fmt;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"Bad Snappy CRC32; expected {expected:x} but got {actual:x}\")]\n    SnappyCrc32 { expected: u32, actual: u32 },\n\n    #[error(\"Invalid u8 for bool: {0}\")]\n    BoolValue(u8),\n\n    #[error(\"Not a fixed value, required for decimal with fixed schema: {0:?}\")]\n    FixedValue(ValueKind),\n\n    #[error(\"Not a bytes value, required for decimal with bytes schema: {0:?}\")]\n    BytesValue(ValueKind),\n\n    #[error(\"Not a string value, required for uuid: {0:?}\")]\n    GetUuidFromStringValue(ValueKind),\n\n    #[error(\"Two schemas with the same fullname were given: {0:?}\")]\n    NameCollision(String),\n\n    #[error(\"Not a fixed or bytes type, required for decimal schema, got: {0:?}\")]\n    ResolveDecimalSchema(SchemaKind),\n\n    #[error(\"Invalid utf-8 string\")]\n    ConvertToUtf8(#[source] std::string::FromUtf8Error),\n\n    /// Describes errors happened while validating Avro data.\n    #[error(\"Value does not match schema\")]\n    Validation,\n\n    #[error(\"Unable to allocate {desired} bytes (maximum allowed: {maximum})\")]\n    MemoryAllocation { desired: usize, maximum: usize },\n\n    /// Describe a specific error happening with decimal representation\n    #[error(\"Number of bytes requested for decimal sign extension {requested} is less than the number of bytes needed to decode {needed}\")]\n    SignExtend { requested: usize, needed: usize },\n\n    #[error(\"Failed to read boolean bytes\")]\n    ReadBoolean(#[source] std::io::Error),\n\n    #[error(\"Failed to read bytes\")]\n    ReadBytes(#[source] std::io::Error),\n\n    #[error(\"Failed to read string\")]\n    ReadString(#[source] std::io::Error),\n\n    #[error(\"Failed to read double\")]\n    ReadDouble(#[source] std::io::Error),\n\n    #[error(\"Failed to read float\")]\n    ReadFloat(#[source] std::io::Error),\n\n    #[error(\"Failed to read duration\")]\n    ReadDuration(#[source] std::io::Error),\n\n    #[error(\"Failed to read fixed number of bytes: {1}\")]\n    ReadFixed(#[source] std::io::Error, usize),\n\n    #[error(\"Failed to convert &str to UUID\")]\n    ConvertStrToUuid(#[source] uuid::Error),\n\n    #[error(\"Map key is not a string; key type is {0:?}\")]\n    MapKeyType(ValueKind),\n\n    #[error(\"Union index {index} out of bounds: {num_variants}\")]\n    GetUnionVariant { index: i64, num_variants: usize },\n\n    #[error(\"Enum symbol index out of bounds: {num_variants}\")]\n    EnumSymbolIndex { index: usize, num_variants: usize },\n\n    #[error(\"Enum symbol not found\")]\n    GetEnumSymbol,\n\n    #[error(\"Scale {scale} is greater than precision {precision}\")]\n    GetScaleAndPrecision { scale: usize, precision: usize },\n\n    #[error(\n        \"Fixed type number of bytes {size} is not large enough to hold decimal values of precision {precision}\"\n    )]\n    GetScaleWithFixedSize { size: usize, precision: usize },\n\n    #[error(\"expected UUID, got: {0:?}\")]\n    GetUuid(ValueKind),\n\n    #[error(\"Fixed bytes of size 12 expected, got Fixed of size {0}\")]\n    GetDecimalFixedBytes(usize),\n\n    #[error(\"Duration expected, got {0:?}\")]\n    ResolveDuration(ValueKind),\n\n    #[error(\"Decimal expected, got {0:?}\")]\n    ResolveDecimal(ValueKind),\n\n    #[error(\"Missing field in record: {0:?}\")]\n    GetField(String),\n\n    #[error(\"Unable to convert to u8, got {0:?}\")]\n    GetU8(ValueKind),\n\n    #[error(\"Precision {precision} too small to hold decimal values with {num_bytes} bytes\")]\n    ComparePrecisionAndSize { precision: usize, num_bytes: usize },\n\n    #[error(\"Cannot convert length to i32: {1}\")]\n    ConvertLengthToI32(#[source] std::num::TryFromIntError, usize),\n\n    #[error(\"Date expected, got {0:?}\")]\n    GetDate(ValueKind),\n\n    #[error(\"TimeMillis expected, got {0:?}\")]\n    GetTimeMillis(ValueKind),\n\n    #[error(\"TimeMicros expected, got {0:?}\")]\n    GetTimeMicros(ValueKind),\n\n    #[error(\"TimestampMillis expected, got {0:?}\")]\n    GetTimestampMillis(ValueKind),\n\n    #[error(\"TimestampMicros expected, got {0:?}\")]\n    GetTimestampMicros(ValueKind),\n\n    #[error(\"Null expected, got {0:?}\")]\n    GetNull(ValueKind),\n\n    #[error(\"Boolean expected, got {0:?}\")]\n    GetBoolean(ValueKind),\n\n    #[error(\"Int expected, got {0:?}\")]\n    GetInt(ValueKind),\n\n    #[error(\"Long expected, got {0:?}\")]\n    GetLong(ValueKind),\n\n    #[error(\"Double expected, got {0:?}\")]\n    GetDouble(ValueKind),\n\n    #[error(\"Float expected, got {0:?}\")]\n    GetFloat(ValueKind),\n\n    #[error(\"Bytes expected, got {0:?}\")]\n    GetBytes(ValueKind),\n\n    #[error(\"String expected, got {0:?}\")]\n    GetString(ValueKind),\n\n    #[error(\"Enum expected, got {0:?}\")]\n    GetEnum(ValueKind),\n\n    #[error(\"Fixed size mismatch, {size} expected, got {n}\")]\n    CompareFixedSizes { size: usize, n: usize },\n\n    #[error(\"String expected for fixed, got {0:?}\")]\n    GetStringForFixed(ValueKind),\n\n    #[error(\"Enum default {symbol:?} is not among allowed symbols {symbols:?}\")]\n    GetEnumDefault {\n        symbol: String,\n        symbols: Vec<String>,\n    },\n\n    #[error(\"Enum value index {index} is out of bounds {nsymbols}\")]\n    GetEnumValue { index: usize, nsymbols: usize },\n\n    #[error(\"Key {0} not found in decimal metadata JSON\")]\n    GetDecimalMetadataFromJson(&'static str),\n\n    #[error(\"Could not find matching type in union\")]\n    FindUnionVariant,\n\n    #[error(\"Array({expected:?}) expected, got {other:?}\")]\n    GetArray {\n        expected: SchemaKind,\n        other: ValueKind,\n    },\n\n    #[error(\"Map({expected:?}) expected, got {other:?}\")]\n    GetMap {\n        expected: SchemaKind,\n        other: ValueKind,\n    },\n\n    #[error(\"Record with fields {expected:?} expected, got {other:?}\")]\n    GetRecord {\n        expected: Vec<(String, SchemaKind)>,\n        other: ValueKind,\n    },\n\n    #[error(\"No `name` field\")]\n    GetNameField,\n\n    #[error(\"No `name` in record field\")]\n    GetNameFieldFromRecord,\n\n    #[error(\"Unions may not directly contain a union\")]\n    GetNestedUnion,\n\n    #[error(\"Unions cannot contain duplicate types\")]\n    GetUnionDuplicate,\n\n    #[error(\"JSON value {0} claims to be u64 but cannot be converted\")]\n    GetU64FromJson(serde_json::Number),\n\n    #[error(\"JSON value {0} claims to be i64 but cannot be converted\")]\n    GetI64FromJson(serde_json::Number),\n\n    #[error(\"Cannot convert u64 to usize: {1}\")]\n    ConvertU64ToUsize(#[source] std::num::TryFromIntError, u64),\n\n    #[error(\"Cannot convert i64 to usize: {1}\")]\n    ConvertI64ToUsize(#[source] std::num::TryFromIntError, i64),\n\n    #[error(\"Cannot convert i32 to usize: {1}\")]\n    ConvertI32ToUsize(#[source] std::num::TryFromIntError, i32),\n\n    #[error(\"Invalid JSON value for decimal precision/scale integer: {0}\")]\n    GetPrecisionOrScaleFromJson(serde_json::Number),\n\n    #[error(\"Failed to parse schema from JSON\")]\n    ParseSchemaJson(#[source] serde_json::Error),\n\n    #[error(\"Must be a JSON string, object or array\")]\n    ParseSchemaFromValidJson,\n\n    #[error(\"Unknown primitiive type: {0}\")]\n    ParsePrimitive(String),\n\n    #[error(\"invalid JSON for {key:?}: {precision:?}\")]\n    GetDecimalPrecisionFromJson {\n        key: String,\n        precision: serde_json::Value,\n    },\n\n    #[error(\"Unexpected `type` {0} variant for `logicalType`\")]\n    GetLogicalTypeVariant(serde_json::Value),\n\n    #[error(\"No `type` field found for `logicalType`\")]\n    GetLogicalTypeField,\n\n    #[error(\"logicalType must be a string\")]\n    GetLogicalTypeFieldType,\n\n    #[error(\"Unknown complex type: {0}\")]\n    GetComplexType(serde_json::Value),\n\n    #[error(\"No `type` in complex type\")]\n    GetComplexTypeField,\n\n    #[error(\"No `fields` in record\")]\n    GetRecordFieldsJson,\n\n    #[error(\"No `symbols` field in enum\")]\n    GetEnumSymbolsField,\n\n    #[error(\"Unable to parse `symbols` in enum\")]\n    GetEnumSymbols,\n\n    #[error(\"Invalid enum symbol name {0}\")]\n    EnumSymbolName(String),\n\n    #[error(\"Duplicate enum symbol {0}\")]\n    EnumSymbolDuplicate(String),\n\n    #[error(\"No `items` in array\")]\n    GetArrayItemsField,\n\n    #[error(\"No `values` in map\")]\n    GetMapValuesField,\n\n    #[error(\"No `size` in fixed\")]\n    GetFixedSizeField,\n\n    #[error(\"Failed to compress with flate\")]\n    DeflateCompress(#[source] std::io::Error),\n\n    #[error(\"Failed to finish flate compressor\")]\n    DeflateCompressFinish(std::io::Error),\n\n    #[error(\"Failed to decompress with flate\")]\n    DeflateDecompress(#[source] std::io::Error),\n\n    #[cfg(feature = \"snappy\")]\n    #[error(\"Failed to compress with snappy\")]\n    SnappyCompress(#[source] snap::Error),\n\n    #[cfg(feature = \"snappy\")]\n    #[error(\"Failed to get snappy decompression length\")]\n    GetSnappyDecompressLen(#[source] snap::Error),\n\n    #[cfg(feature = \"snappy\")]\n    #[error(\"Failed to decompress with snappy\")]\n    SnappyDecompress(#[source] snap::Error),\n\n    #[error(\"Failed to read header\")]\n    ReadHeader(#[source] std::io::Error),\n\n    #[error(\"wrong magic in header\")]\n    HeaderMagic,\n\n    #[error(\"Failed to get JSON from avro.schema key in map\")]\n    GetAvroSchemaFromMap,\n\n    #[error(\"no metadata in header\")]\n    GetHeaderMetadata,\n\n    #[error(\"Failed to read marker bytes\")]\n    ReadMarker(#[source] std::io::Error),\n\n    #[error(\"Failed to read block marker bytes\")]\n    ReadBlockMarker(#[source] std::io::Error),\n\n    #[error(\"Read into buffer failed\")]\n    ReadIntoBuf(#[source] std::io::Error),\n\n    #[error(\"block marker does not match header marker\")]\n    GetBlockMarker,\n\n    #[error(\"Overflow when decoding integer value\")]\n    IntegerOverflow,\n\n    #[error(\"Failed to read bytes for decoding variable length integer\")]\n    ReadVariableIntegerBytes(#[source] std::io::Error),\n\n    #[error(\"Decoded integer out of range for i32: {1}\")]\n    ZagI32(#[source] std::num::TryFromIntError, i64),\n\n    #[error(\"unable to read block\")]\n    ReadBlock,\n\n    #[error(\"Failed to serialize value into Avro value: {0}\")]\n    SerializeValue(String),\n\n    #[error(\"Failed to deserialize Avro value into value: {0}\")]\n    DeserializeValue(String),\n\n    #[error(\"Failed to write buffer bytes during flush\")]\n    WriteBytes(#[source] std::io::Error),\n\n    #[error(\"Failed to write marker\")]\n    WriteMarker(#[source] std::io::Error),\n\n    #[error(\"Failed to convert JSON to string\")]\n    ConvertJsonToString(#[source] serde_json::Error),\n\n    /// Error while converting float to json value\n    #[error(\"failed to convert avro float to json: {0}\")]\n    ConvertF64ToJson(f64),\n}\n\nimpl serde::ser::Error for Error {\n    fn custom<T: fmt::Display>(msg: T) -> Self {\n        Error::SerializeValue(msg.to_string())\n    }\n}\n\nimpl serde::de::Error for Error {\n    fn custom<T: fmt::Display>(msg: T) -> Self {\n        Error::DeserializeValue(msg.to_string())\n    }\n}\n","traces":[{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","lib.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! A library for working with [Apache Avro](https://avro.apache.org/) in Rust.\n//!\n//! Please check our [documentation](https://docs.rs/avro-rs) for examples, tutorials and API reference.\n//!\n//! **[Apache Avro](https://avro.apache.org/)** is a data serialization system which provides rich\n//! data structures and a compact, fast, binary data format.\n//!\n//! All data in Avro is schematized, as in the following example:\n//!\n//! ```text\n//! {\n//!     \"type\": \"record\",\n//!     \"name\": \"test\",\n//!     \"fields\": [\n//!         {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!         {\"name\": \"b\", \"type\": \"string\"}\n//!     ]\n//! }\n//! ```\n//!\n//! There are basically two ways of handling Avro data in Rust:\n//!\n//! * **as Avro-specialized data types** based on an Avro schema;\n//! * **as generic Rust serde-compatible types** implementing/deriving `Serialize` and\n//! `Deserialize`;\n//!\n//! **avro-rs** provides a way to read and write both these data representations easily and\n//! efficiently.\n//!\n//! # Installing the library\n//!\n//!\n//! Add to your `Cargo.toml`:\n//!\n//! ```toml\n//! [dependencies]\n//! avro-rs = \"x.y\"\n//! ```\n//!\n//! Or in case you want to leverage the **Snappy** codec:\n//!\n//! ```toml\n//! [dependencies.avro-rs]\n//! version = \"x.y\"\n//! features = [\"snappy\"]\n//! ```\n//!\n//! # Upgrading to a newer minor version\n//!\n//! The library is still in beta, so there might be backward-incompatible changes between minor\n//! versions. If you have troubles upgrading, check the [version upgrade guide](migration_guide.md).\n//!\n//! # Defining a schema\n//!\n//! An Avro data cannot exist without an Avro schema. Schemas **must** be used while writing and\n//! **can** be used while reading and they carry the information regarding the type of data we are\n//! handling. Avro schemas are used for both schema validation and resolution of Avro data.\n//!\n//! Avro schemas are defined in **JSON** format and can just be parsed out of a raw string:\n//!\n//! ```\n//! use avro_rs::Schema;\n//!\n//! let raw_schema = r#\"\n//!     {\n//!         \"type\": \"record\",\n//!         \"name\": \"test\",\n//!         \"fields\": [\n//!             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!             {\"name\": \"b\", \"type\": \"string\"}\n//!         ]\n//!     }\n//! \"#;\n//!\n//! // if the schema is not valid, this function will return an error\n//! let schema = Schema::parse_str(raw_schema).unwrap();\n//!\n//! // schemas can be printed for debugging\n//! println!(\"{:?}\", schema);\n//! ```\n//!\n//! Additionally, a list of of definitions (which may depend on each other) can be given and all of\n//! them will be parsed into the corresponding schemas.\n//!\n//! ```\n//! use avro_rs::Schema;\n//!\n//! let raw_schema_1 = r#\"{\n//!         \"name\": \"A\",\n//!         \"type\": \"record\",\n//!         \"fields\": [\n//!             {\"name\": \"field_one\", \"type\": \"float\"}\n//!         ]\n//!     }\"#;\n//!\n//! // This definition depends on the definition of A above\n//! let raw_schema_2 = r#\"{\n//!         \"name\": \"B\",\n//!         \"type\": \"record\",\n//!         \"fields\": [\n//!             {\"name\": \"field_one\", \"type\": \"A\"}\n//!         ]\n//!     }\"#;\n//!\n//! // if the schemas are not valid, this function will return an error\n//! let schemas = Schema::parse_list(&[raw_schema_1, raw_schema_2]).unwrap();\n//!\n//! // schemas can be printed for debugging\n//! println!(\"{:?}\", schemas);\n//! ```\n//! *N.B.* It is important to note that the composition of schema definitions requires schemas with names.\n//! For this reason, only schemas of type Record, Enum, and Fixed should be input into this function.\n//!\n//! The library provides also a programmatic interface to define schemas without encoding them in\n//! JSON (for advanced use), but we highly recommend the JSON interface. Please read the API\n//! reference in case you are interested.\n//!\n//! For more information about schemas and what kind of information you can encapsulate in them,\n//! please refer to the appropriate section of the\n//! [Avro Specification](https://avro.apache.org/docs/current/spec.html#schemas).\n//!\n//! # Writing data\n//!\n//! Once we have defined a schema, we are ready to serialize data in Avro, validating them against\n//! the provided schema in the process. As mentioned before, there are two ways of handling Avro\n//! data in Rust.\n//!\n//! **NOTE:** The library also provides a low-level interface for encoding a single datum in Avro\n//! bytecode without generating markers and headers (for advanced use), but we highly recommend the\n//! `Writer` interface to be totally Avro-compatible. Please read the API reference in case you are\n//! interested.\n//!\n//! ## The avro way\n//!\n//! Given that the schema we defined above is that of an Avro *Record*, we are going to use the\n//! associated type provided by the library to specify the data we want to serialize:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! use avro_rs::types::Record;\n//! use avro_rs::Writer;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! // a writer needs a schema and something to write to\n//! let mut writer = Writer::new(&schema, Vec::new());\n//!\n//! // the Record type models our Record schema\n//! let mut record = Record::new(writer.schema()).unwrap();\n//! record.put(\"a\", 27i64);\n//! record.put(\"b\", \"foo\");\n//!\n//! // schema validation happens here\n//! writer.append(record).unwrap();\n//!\n//! // this is how to get back the resulting avro bytecode\n//! // this performs a flush operation to make sure data has been written, so it can fail\n//! // you can also call `writer.flush()` yourself without consuming the writer\n//! let encoded = writer.into_inner().unwrap();\n//! ```\n//!\n//! The vast majority of the times, schemas tend to define a record as a top-level container\n//! encapsulating all the values to convert as fields and providing documentation for them, but in\n//! case we want to directly define an Avro value, the library offers that capability via the\n//! `Value` interface.\n//!\n//! ```\n//! use avro_rs::types::Value;\n//!\n//! let mut value = Value::String(\"foo\".to_string());\n//! ```\n//!\n//! ## The serde way\n//!\n//! Given that the schema we defined above is an Avro *Record*, we can directly use a Rust struct\n//! deriving `Serialize` to model our data:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! # use serde::Serialize;\n//! use avro_rs::Writer;\n//!\n//! #[derive(Debug, Serialize)]\n//! struct Test {\n//!     a: i64,\n//!     b: String,\n//! }\n//!\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! // a writer needs a schema and something to write to\n//! let mut writer = Writer::new(&schema, Vec::new());\n//!\n//! // the structure models our Record schema\n//! let test = Test {\n//!     a: 27,\n//!     b: \"foo\".to_owned(),\n//! };\n//!\n//! // schema validation happens here\n//! writer.append_ser(test).unwrap();\n//!\n//! // this is how to get back the resulting avro bytecode\n//! // this performs a flush operation to make sure data is written, so it can fail\n//! // you can also call `writer.flush()` yourself without consuming the writer\n//! let encoded = writer.into_inner();\n//! ```\n//!\n//! The vast majority of the times, schemas tend to define a record as a top-level container\n//! encapsulating all the values to convert as fields and providing documentation for them, but in\n//! case we want to directly define an Avro value, any type implementing `Serialize` should work.\n//!\n//! ```\n//! let mut value = \"foo\".to_string();\n//! ```\n//!\n//! ## Using codecs to compress data\n//!\n//! Avro supports three different compression codecs when encoding data:\n//!\n//! * **Null**: leaves data uncompressed;\n//! * **Deflate**: writes the data block using the deflate algorithm as specified in RFC 1951, and\n//! typically implemented using the zlib library. Note that this format (unlike the \"zlib format\" in\n//! RFC 1950) does not have a checksum.\n//! * **Snappy**: uses Google's [Snappy](http://google.github.io/snappy/) compression library. Each\n//! compressed block is followed by the 4-byte, big-endianCRC32 checksum of the uncompressed data in\n//! the block. You must enable the `snappy` feature to use this codec.\n//!\n//! To specify a codec to use to compress data, just specify it while creating a `Writer`:\n//! ```\n//! # use avro_rs::Schema;\n//! use avro_rs::Writer;\n//! use avro_rs::Codec;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! let mut writer = Writer::with_codec(&schema, Vec::new(), Codec::Deflate);\n//! ```\n//!\n//! # Reading data\n//!\n//! As far as reading Avro encoded data goes, we can just use the schema encoded with the data to\n//! read them. The library will do it automatically for us, as it already does for the compression\n//! codec:\n//!\n//! ```\n//! use avro_rs::Reader;\n//! # use avro_rs::Schema;\n//! # use avro_rs::types::Record;\n//! # use avro_rs::Writer;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let mut writer = Writer::new(&schema, Vec::new());\n//! # let mut record = Record::new(writer.schema()).unwrap();\n//! # record.put(\"a\", 27i64);\n//! # record.put(\"b\", \"foo\");\n//! # writer.append(record).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//! // reader creation can fail in case the input to read from is not Avro-compatible or malformed\n//! let reader = Reader::new(&input[..]).unwrap();\n//! ```\n//!\n//! In case, instead, we want to specify a different (but compatible) reader schema from the schema\n//! the data has been written with, we can just do as the following:\n//! ```\n//! use avro_rs::Schema;\n//! use avro_rs::Reader;\n//! # use avro_rs::types::Record;\n//! # use avro_rs::Writer;\n//! #\n//! # let writer_raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n//! # let mut writer = Writer::new(&writer_schema, Vec::new());\n//! # let mut record = Record::new(writer.schema()).unwrap();\n//! # record.put(\"a\", 27i64);\n//! # record.put(\"b\", \"foo\");\n//! # writer.append(record).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//!\n//! let reader_raw_schema = r#\"\n//!     {\n//!         \"type\": \"record\",\n//!         \"name\": \"test\",\n//!         \"fields\": [\n//!             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!             {\"name\": \"b\", \"type\": \"string\"},\n//!             {\"name\": \"c\", \"type\": \"long\", \"default\": 43}\n//!         ]\n//!     }\n//! \"#;\n//!\n//! let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n//!\n//! // reader creation can fail in case the input to read from is not Avro-compatible or malformed\n//! let reader = Reader::with_schema(&reader_schema, &input[..]).unwrap();\n//! ```\n//!\n//! The library will also automatically perform schema resolution while reading the data.\n//!\n//! For more information about schema compatibility and resolution, please refer to the\n//! [Avro Specification](https://avro.apache.org/docs/current/spec.html#schemas).\n//!\n//! As usual, there are two ways to handle Avro data in Rust, as you can see below.\n//!\n//! **NOTE:** The library also provides a low-level interface for decoding a single datum in Avro\n//! bytecode without markers and header (for advanced use), but we highly recommend the `Reader`\n//! interface to leverage all Avro features. Please read the API reference in case you are\n//! interested.\n//!\n//!\n//! ## The avro way\n//!\n//! We can just read directly instances of `Value` out of the `Reader` iterator:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! # use avro_rs::types::Record;\n//! # use avro_rs::Writer;\n//! use avro_rs::Reader;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let mut writer = Writer::new(&schema, Vec::new());\n//! # let mut record = Record::new(writer.schema()).unwrap();\n//! # record.put(\"a\", 27i64);\n//! # record.put(\"b\", \"foo\");\n//! # writer.append(record).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//! let reader = Reader::new(&input[..]).unwrap();\n//!\n//! // value is a Result  of an Avro Value in case the read operation fails\n//! for value in reader {\n//!     println!(\"{:?}\", value.unwrap());\n//! }\n//!\n//! ```\n//!\n//! ## The serde way\n//!\n//! Alternatively, we can use a Rust type implementing `Deserialize` and representing our schema to\n//! read the data into:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! # use avro_rs::Writer;\n//! # use serde::{Deserialize, Serialize};\n//! use avro_rs::Reader;\n//! use avro_rs::from_value;\n//!\n//! # #[derive(Serialize)]\n//! #[derive(Debug, Deserialize)]\n//! struct Test {\n//!     a: i64,\n//!     b: String,\n//! }\n//!\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let mut writer = Writer::new(&schema, Vec::new());\n//! # let test = Test {\n//! #     a: 27,\n//! #     b: \"foo\".to_owned(),\n//! # };\n//! # writer.append_ser(test).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//! let reader = Reader::new(&input[..]).unwrap();\n//!\n//! // value is a Result in case the read operation fails\n//! for value in reader {\n//!     println!(\"{:?}\", from_value::<Test>(&value.unwrap()));\n//! }\n//! ```\n//!\n//! # Putting everything together\n//!\n//! The following is an example of how to combine everything showed so far and it is meant to be a\n//! quick reference of the library interface:\n//!\n//! ```\n//! use avro_rs::{Codec, Reader, Schema, Writer, from_value, types::Record, Error};\n//! use serde::{Deserialize, Serialize};\n//!\n//! #[derive(Debug, Deserialize, Serialize)]\n//! struct Test {\n//!     a: i64,\n//!     b: String,\n//! }\n//!\n//! fn main() -> Result<(), Error> {\n//!     let raw_schema = r#\"\n//!         {\n//!             \"type\": \"record\",\n//!             \"name\": \"test\",\n//!             \"fields\": [\n//!                 {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!                 {\"name\": \"b\", \"type\": \"string\"}\n//!             ]\n//!         }\n//!     \"#;\n//!\n//!     let schema = Schema::parse_str(raw_schema)?;\n//!\n//!     println!(\"{:?}\", schema);\n//!\n//!     let mut writer = Writer::with_codec(&schema, Vec::new(), Codec::Deflate);\n//!\n//!     let mut record = Record::new(writer.schema()).unwrap();\n//!     record.put(\"a\", 27i64);\n//!     record.put(\"b\", \"foo\");\n//!\n//!     writer.append(record)?;\n//!\n//!     let test = Test {\n//!         a: 27,\n//!         b: \"foo\".to_owned(),\n//!     };\n//!\n//!     writer.append_ser(test)?;\n//!\n//!     let input = writer.into_inner()?;\n//!     let reader = Reader::with_schema(&schema, &input[..])?;\n//!\n//!     for record in reader {\n//!         println!(\"{:?}\", from_value::<Test>(&record?));\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! `avro-rs` also supports the logical types listed in the [Avro specification](https://avro.apache.org/docs/current/spec.html#Logical+Types):\n//!\n//! 1. `Decimal` using the [`num_bigint`](https://docs.rs/num-bigint/0.2.6/num_bigint) crate\n//! 1. UUID using the [`uuid`](https://docs.rs/uuid/0.8.1/uuid) crate\n//! 1. Date, Time (milli) as `i32` and Time (micro) as `i64`\n//! 1. Timestamp (milli and micro) as `i64`\n//! 1. Duration as a custom type with `months`, `days` and `millis` accessor methods each of which returns an `i32`\n//!\n//! Note that the on-disk representation is identical to the underlying primitive/complex type.\n//!\n//! ### Read and write logical types\n//!\n//! ```rust\n//! use avro_rs::{\n//!     types::Record, types::Value, Codec, Days, Decimal, Duration, Millis, Months, Reader, Schema,\n//!     Writer, Error,\n//! };\n//! use num_bigint::ToBigInt;\n//!\n//! fn main() -> Result<(), Error> {\n//!     let raw_schema = r#\"\n//!     {\n//!       \"type\": \"record\",\n//!       \"name\": \"test\",\n//!       \"fields\": [\n//!         {\n//!           \"name\": \"decimal_fixed\",\n//!           \"type\": {\n//!             \"type\": \"fixed\",\n//!             \"size\": 2,\n//!             \"name\": \"decimal\"\n//!           },\n//!           \"logicalType\": \"decimal\",\n//!           \"precision\": 4,\n//!           \"scale\": 2\n//!         },\n//!         {\n//!           \"name\": \"decimal_var\",\n//!           \"type\": \"bytes\",\n//!           \"logicalType\": \"decimal\",\n//!           \"precision\": 10,\n//!           \"scale\": 3\n//!         },\n//!         {\n//!           \"name\": \"uuid\",\n//!           \"type\": \"string\",\n//!           \"logicalType\": \"uuid\"\n//!         },\n//!         {\n//!           \"name\": \"date\",\n//!           \"type\": \"int\",\n//!           \"logicalType\": \"date\"\n//!         },\n//!         {\n//!           \"name\": \"time_millis\",\n//!           \"type\": \"int\",\n//!           \"logicalType\": \"time-millis\"\n//!         },\n//!         {\n//!           \"name\": \"time_micros\",\n//!           \"type\": \"long\",\n//!           \"logicalType\": \"time-micros\"\n//!         },\n//!         {\n//!           \"name\": \"timestamp_millis\",\n//!           \"type\": \"long\",\n//!           \"logicalType\": \"timestamp-millis\"\n//!         },\n//!         {\n//!           \"name\": \"timestamp_micros\",\n//!           \"type\": \"long\",\n//!           \"logicalType\": \"timestamp-micros\"\n//!         },\n//!         {\n//!           \"name\": \"duration\",\n//!           \"type\": {\n//!             \"type\": \"fixed\",\n//!             \"size\": 12,\n//!             \"name\": \"duration\"\n//!           },\n//!           \"logicalType\": \"duration\"\n//!         }\n//!       ]\n//!     }\n//!     \"#;\n//!\n//!     let schema = Schema::parse_str(raw_schema)?;\n//!\n//!     println!(\"{:?}\", schema);\n//!\n//!     let mut writer = Writer::with_codec(&schema, Vec::new(), Codec::Deflate);\n//!\n//!     let mut record = Record::new(writer.schema()).unwrap();\n//!     record.put(\"decimal_fixed\", Decimal::from(9936.to_bigint().unwrap().to_signed_bytes_be()));\n//!     record.put(\"decimal_var\", Decimal::from((-32442.to_bigint().unwrap()).to_signed_bytes_be()));\n//!     record.put(\"uuid\", uuid::Uuid::new_v4());\n//!     record.put(\"date\", Value::Date(1));\n//!     record.put(\"time_millis\", Value::TimeMillis(2));\n//!     record.put(\"time_micros\", Value::TimeMicros(3));\n//!     record.put(\"timestamp_millis\", Value::TimestampMillis(4));\n//!     record.put(\"timestamp_micros\", Value::TimestampMicros(5));\n//!     record.put(\"duration\", Duration::new(Months::new(6), Days::new(7), Millis::new(8)));\n//!\n//!     writer.append(record)?;\n//!\n//!     let input = writer.into_inner()?;\n//!     let reader = Reader::with_schema(&schema, &input[..])?;\n//!\n//!     for record in reader {\n//!         println!(\"{:?}\", record?);\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Calculate Avro schema fingerprint\n//!\n//! This library supports calculating the following fingerprints:\n//!\n//!  - SHA-256\n//!  - MD5\n//!  - Rabin\n//!\n//! An example of fingerprinting for the supported fingerprints:\n//!\n//! ```rust\n//! use avro_rs::rabin::Rabin;\n//! use avro_rs::{Schema, Error};\n//! use md5::Md5;\n//! use sha2::Sha256;\n//!\n//! fn main() -> Result<(), Error> {\n//!     let raw_schema = r#\"\n//!         {\n//!             \"type\": \"record\",\n//!             \"name\": \"test\",\n//!             \"fields\": [\n//!                 {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!                 {\"name\": \"b\", \"type\": \"string\"}\n//!             ]\n//!         }\n//!     \"#;\n//!     let schema = Schema::parse_str(raw_schema)?;\n//!     println!(\"{}\", schema.fingerprint::<Sha256>());\n//!     println!(\"{}\", schema.fingerprint::<Md5>());\n//!     println!(\"{}\", schema.fingerprint::<Rabin>());\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Ill-formed data\n//!\n//! In order to ease decoding, the Binary Encoding specification of Avro data\n//! requires some fields to have their length encoded alongside the data.\n//!\n//! If encoded data passed to a `Reader` has been ill-formed, it can happen that\n//! the bytes meant to contain the length of data are bogus and could result\n//! in extravagant memory allocation.\n//!\n//! To shield users from ill-formed data, `avro-rs` sets a limit (default: 512MB)\n//! to any allocation it will perform when decoding data.\n//!\n//! If you expect some of your data fields to be larger than this limit, be sure\n//! to make use of the `max_allocation_bytes` function before reading **any** data\n//! (we leverage Rust's [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html)\n//! mechanism to initialize this value, if\n//! any call to decode is made before a call to `max_allocation_bytes`, the limit\n//! will be 512MB throughout the lifetime of the program).\n//!\n//!\n//! ```rust\n//! use avro_rs::max_allocation_bytes;\n//!\n//! max_allocation_bytes(2 * 1024 * 1024 * 1024);  // 2GB\n//!\n//! // ... happily decode large data\n//!\n//! ```\n//!\n//! ## Check schemas compatibility\n//!\n//! This library supports checking for schemas compatibility.\n//!\n//! Note: It does not yet support named schemas (more on\n//! https://github.com/flavray/avro-rs/pull/76).\n//!\n//! Examples of checking for compatibility:\n//!\n//! 1. Compatible schemas\n//!\n//! Explanation: an int array schema can be read by a long array schema- an int\n//! (32bit signed integer) fits into a long (64bit signed integer)\n//!\n//! ```rust\n//! use avro_rs::{Schema, schema_compatibility::SchemaCompatibility};\n//!\n//! let writers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"int\"}\"#).unwrap();\n//! let readers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"long\"}\"#).unwrap();\n//! assert_eq!(true, SchemaCompatibility::can_read(&writers_schema, &readers_schema));\n//! ```\n//!\n//! 2. Incompatible schemas (a long array schema cannot be read by an int array schema)\n//!\n//! Explanation: a long array schema cannot be read by an int array schema- a\n//! long (64bit signed integer) does not fit into an int (32bit signed integer)\n//!\n//! ```rust\n//! use avro_rs::{Schema, schema_compatibility::SchemaCompatibility};\n//!\n//! let writers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"long\"}\"#).unwrap();\n//! let readers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"int\"}\"#).unwrap();\n//! assert_eq!(false, SchemaCompatibility::can_read(&writers_schema, &readers_schema));\n//! ```\n\nmod codec;\nmod de;\nmod decimal;\nmod decode;\nmod duration;\nmod encode;\nmod error;\nmod reader;\nmod ser;\nmod util;\nmod writer;\n\npub mod rabin;\npub mod schema;\npub mod schema_compatibility;\npub mod types;\n\npub use codec::Codec;\npub use de::from_value;\npub use decimal::Decimal;\npub use duration::{Days, Duration, Millis, Months};\npub use error::{Error, Error as DeError, Error as SerError};\npub use reader::{from_avro_datum, Reader};\npub use schema::Schema;\npub use ser::to_value;\npub use util::max_allocation_bytes;\npub use writer::{to_avro_datum, Writer};\n\n/// A convenience type alias for `Result`s with `Error`s.\npub type AvroResult<T> = Result<T, Error>;\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        from_avro_datum,\n        types::{Record, Value},\n        Codec, Reader, Schema, Writer,\n    };\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_default() {\n        let writer_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"}\n                ]\n            }\n        \"#;\n        let reader_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n        let mut writer = Writer::with_codec(&writer_schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::with_schema(&reader_schema, &input[..]).unwrap();\n        assert_eq!(\n            reader.next().unwrap().unwrap(),\n            Value::Record(vec![\n                (\"a\".to_string(), Value::Long(27)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n                (\"c\".to_string(), Value::Enum(1, \"spades\".to_string())),\n            ])\n        );\n        assert!(reader.next().is_none());\n    }\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_string_value() {\n        let raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        let mut writer = Writer::with_codec(&schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        record.put(\"c\", \"clubs\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::with_schema(&schema, &input[..]).unwrap();\n        assert_eq!(\n            reader.next().unwrap().unwrap(),\n            Value::Record(vec![\n                (\"a\".to_string(), Value::Long(27)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n                (\"c\".to_string(), Value::Enum(2, \"clubs\".to_string())),\n            ])\n        );\n        assert!(reader.next().is_none());\n    }\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_resolution() {\n        let writer_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let reader_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"ninja\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n        let mut writer = Writer::with_codec(&writer_schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        record.put(\"c\", \"clubs\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::with_schema(&reader_schema, &input[..]).unwrap();\n        assert!(reader.next().unwrap().is_err());\n        assert!(reader.next().is_none());\n    }\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_no_reader_schema() {\n        let writer_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let mut writer = Writer::with_codec(&writer_schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        record.put(\"c\", \"clubs\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::new(&input[..]).unwrap();\n        assert_eq!(\n            reader.next().unwrap().unwrap(),\n            Value::Record(vec![\n                (\"a\".to_string(), Value::Long(27)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n                (\"c\".to_string(), Value::Enum(2, \"clubs\".to_string())),\n            ])\n        );\n    }\n\n    #[test]\n    fn test_illformed_length() {\n        let raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"}\n                ]\n            }\n        \"#;\n\n        let schema = Schema::parse_str(raw_schema).unwrap();\n\n        // Would allocated 18446744073709551605 bytes\n        let illformed: &[u8] = &[0x3e, 0x15, 0xff, 0x1f, 0x15, 0xff];\n\n        let value = from_avro_datum(&schema, &mut &*illformed, None);\n        assert!(value.is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","rabin.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Implementation of the Rabin fingerprint algorithm\nuse byteorder::{ByteOrder, LittleEndian};\nuse digest::{consts::U8, generic_array::GenericArray, FixedOutput, Reset, Update};\nuse lazy_static::lazy_static;\n\nconst EMPTY: i64 = -4513414715797952619;\n\nlazy_static! {\n    static ref FPTABLE: [i64; 256] = {\n        let mut fp_table: [i64; 256] = [0; 256];\n        for i in 0..256 {\n            let mut fp = i;\n            for _ in 0..8 {\n                fp = (fp as u64 >> 1) as i64 ^ (EMPTY & -(fp & 1));\n            }\n            fp_table[i as usize] = fp\n        }\n        fp_table\n    };\n}\n\n/// Implementation of the Rabin fingerprint algorithm using the Digest trait as described in [schema_fingerprints](https://avro.apache.org/docs/current/spec.html#schema_fingerprints).\n///\n/// The digest is returned as the 8-byte little-endian encoding of the Rabin hash.\n/// This is what is used for avro [single object encoding](https://avro.apache.org/docs/current/spec.html#single_object_encoding)\n///\n/// ```rust\n/// use avro_rs::rabin::Rabin;\n/// use digest::Digest;\n/// use hex_literal::hex;\n///\n/// // create the Rabin hasher\n/// let mut hasher = Rabin::new();\n///\n/// // add the data\n/// hasher.update(b\"hello world\");\n///\n/// // read hash digest and consume hasher\n/// let result = hasher.finalize();\n///\n/// assert_eq!(result[..], hex!(\"60335ba6d0415528\"));\n/// ```\n///\n/// To convert the digest to the commonly used 64-bit integer value, you can use the byteorder crate:\n///\n/// ```rust\n/// # use avro_rs::rabin::Rabin;\n/// # use digest::Digest;\n/// # use hex_literal::hex;\n///\n/// # let mut hasher = Rabin::new();\n///\n/// # hasher.update(b\"hello world\");\n///\n/// # let result = hasher.finalize();\n///\n/// # assert_eq!(result[..], hex!(\"60335ba6d0415528\"));\n/// use byteorder::{ByteOrder, LittleEndian};\n///\n/// let i = LittleEndian::read_i64(&result.to_vec());\n///\n/// assert_eq!(i, 2906301498937520992)\n/// ```\n#[derive(Clone)]\npub struct Rabin {\n    result: i64,\n}\n\nimpl Default for Rabin {\n    fn default() -> Self {\n        Rabin { result: EMPTY }\n    }\n}\n\nimpl Update for Rabin {\n    fn update(&mut self, input: impl AsRef<[u8]>) {\n        for b in input.as_ref() {\n            self.result = (self.result as u64 >> 8) as i64\n                ^ FPTABLE[((self.result ^ *b as i64) & 0xff) as usize];\n        }\n    }\n}\n\nimpl FixedOutput for Rabin {\n    // 8-byte little-endian form of the i64\n    // See: https://avro.apache.org/docs/current/spec.html#single_object_encoding\n    type OutputSize = U8;\n\n    fn finalize_into(self, out: &mut GenericArray<u8, Self::OutputSize>) {\n        LittleEndian::write_i64(out, self.result);\n    }\n\n    fn finalize_into_reset(&mut self, out: &mut GenericArray<u8, Self::OutputSize>) {\n        LittleEndian::write_i64(out, self.result);\n        self.result = EMPTY;\n    }\n}\n\nimpl Reset for Rabin {\n    fn reset(&mut self) {\n        self.result = EMPTY;\n    }\n}\n\ndigest::impl_write!(Rabin);\n\n#[cfg(test)]\nmod tests {\n    use super::Rabin;\n    use byteorder::{ByteOrder, LittleEndian};\n    use digest::Digest;\n\n    // See: https://github.com/apache/avro/blob/master/share/test/data/schema-tests.txt\n    #[test]\n    fn test1() {\n        let data: &[(&str, i64)] = &[\n            (r#\"\"null\"\"#, 7195948357588979594),\n            (r#\"\"boolean\"\"#, -6970731678124411036),\n            (\n                r#\"{\"name\":\"foo\",\"type\":\"fixed\",\"size\":15}\"#,\n                1756455273707447556,\n            ),\n            (\n                r#\"{\"name\":\"PigValue\",\"type\":\"record\",\"fields\":[{\"name\":\"value\",\"type\":[\"null\",\"int\",\"long\",\"PigValue\"]}]}\"#,\n                -1759257747318642341,\n            ),\n        ];\n\n        let mut hasher = Rabin::new();\n\n        for (s, fp) in data {\n            hasher.update(s.as_bytes());\n            let result = LittleEndian::read_i64(&hasher.finalize_reset().to_vec());\n            assert_eq!(*fp, result);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","reader.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic handling reading from Avro format at user level.\nuse crate::{decode::decode, schema::Schema, types::Value, util, AvroResult, Codec, Error};\nuse serde_json::from_slice;\nuse std::{\n    io::{ErrorKind, Read},\n    str::FromStr,\n};\n\n// Internal Block reader.\n#[derive(Debug, Clone)]\nstruct Block<R> {\n    reader: R,\n    // Internal buffering to reduce allocation.\n    buf: Vec<u8>,\n    buf_idx: usize,\n    // Number of elements expected to exist within this block.\n    message_count: usize,\n    marker: [u8; 16],\n    codec: Codec,\n    writer_schema: Schema,\n}\n\nimpl<R: Read> Block<R> {\n    fn new(reader: R) -> AvroResult<Block<R>> {\n        let mut block = Block {\n            reader,\n            codec: Codec::Null,\n            writer_schema: Schema::Null,\n            buf: vec![],\n            buf_idx: 0,\n            message_count: 0,\n            marker: [0; 16],\n        };\n\n        block.read_header()?;\n        Ok(block)\n    }\n\n    /// Try to read the header and to set the writer `Schema`, the `Codec` and the marker based on\n    /// its content.\n    fn read_header(&mut self) -> AvroResult<()> {\n        let meta_schema = Schema::Map(Box::new(Schema::Bytes));\n\n        let mut buf = [0u8; 4];\n        self.reader\n            .read_exact(&mut buf)\n            .map_err(Error::ReadHeader)?;\n\n        if buf != [b'O', b'b', b'j', 1u8] {\n            return Err(Error::HeaderMagic);\n        }\n\n        if let Value::Map(meta) = decode(&meta_schema, &mut self.reader)? {\n            // TODO: surface original parse schema errors instead of coalescing them here\n            let json = meta\n                .get(\"avro.schema\")\n                .and_then(|bytes| {\n                    if let Value::Bytes(ref bytes) = *bytes {\n                        from_slice(bytes.as_ref()).ok()\n                    } else {\n                        None\n                    }\n                })\n                .ok_or(Error::GetAvroSchemaFromMap)?;\n            self.writer_schema = Schema::parse(&json)?;\n\n            if let Some(codec) = meta\n                .get(\"avro.codec\")\n                .and_then(|codec| {\n                    if let Value::Bytes(ref bytes) = *codec {\n                        std::str::from_utf8(bytes.as_ref()).ok()\n                    } else {\n                        None\n                    }\n                })\n                .and_then(|codec| Codec::from_str(codec).ok())\n            {\n                self.codec = codec;\n            }\n        } else {\n            return Err(Error::GetHeaderMetadata);\n        }\n\n        self.reader\n            .read_exact(&mut self.marker)\n            .map_err(Error::ReadMarker)\n    }\n\n    fn fill_buf(&mut self, n: usize) -> AvroResult<()> {\n        // The buffer needs to contain exactly `n` elements, otherwise codecs will potentially read\n        // invalid bytes.\n        //\n        // The are two cases to handle here:\n        //\n        // 1. `n > self.buf.len()`:\n        //    In this case we call `Vec::resize`, which guarantees that `self.buf.len() == n`.\n        // 2. `n < self.buf.len()`:\n        //    We need to resize to ensure that the buffer len is safe to read `n` elements.\n        //\n        // TODO: Figure out a way to avoid having to truncate for the second case.\n        self.buf.resize(n, 0);\n        self.reader\n            .read_exact(&mut self.buf)\n            .map_err(Error::ReadIntoBuf)?;\n        self.buf_idx = 0;\n        Ok(())\n    }\n\n    /// Try to read a data block, also performing schema resolution for the objects contained in\n    /// the block. The objects are stored in an internal buffer to the `Reader`.\n    fn read_block_next(&mut self) -> AvroResult<()> {\n        assert!(self.is_empty(), \"Expected self to be empty!\");\n        match util::read_long(&mut self.reader) {\n            Ok(block_len) => {\n                self.message_count = block_len as usize;\n                let block_bytes = util::read_long(&mut self.reader)?;\n                self.fill_buf(block_bytes as usize)?;\n                let mut marker = [0u8; 16];\n                self.reader\n                    .read_exact(&mut marker)\n                    .map_err(Error::ReadBlockMarker)?;\n\n                if marker != self.marker {\n                    return Err(Error::GetBlockMarker);\n                }\n\n                // NOTE (JAB): This doesn't fit this Reader pattern very well.\n                // `self.buf` is a growable buffer that is reused as the reader is iterated.\n                // For non `Codec::Null` variants, `decompress` will allocate a new `Vec`\n                // and replace `buf` with the new one, instead of reusing the same buffer.\n                // We can address this by using some \"limited read\" type to decode directly\n                // into the buffer. But this is fine, for now.\n                self.codec.decompress(&mut self.buf)\n            }\n            Err(Error::ReadVariableIntegerBytes(io_err)) => {\n                if let ErrorKind::UnexpectedEof = io_err.kind() {\n                    // to not return any error in case we only finished to read cleanly from the stream\n                    Ok(())\n                } else {\n                    Err(Error::ReadVariableIntegerBytes(io_err))\n                }\n            }\n            Err(e) => Err(e),\n        }\n    }\n\n    fn len(&self) -> usize {\n        self.message_count\n    }\n\n    fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    fn read_next(&mut self, read_schema: Option<&Schema>) -> AvroResult<Option<Value>> {\n        if self.is_empty() {\n            self.read_block_next()?;\n            if self.is_empty() {\n                return Ok(None);\n            }\n        }\n\n        let mut block_bytes = &self.buf[self.buf_idx..];\n        let b_original = block_bytes.len();\n        let item = from_avro_datum(&self.writer_schema, &mut block_bytes, read_schema)?;\n        self.buf_idx += b_original - block_bytes.len();\n        self.message_count -= 1;\n        Ok(Some(item))\n    }\n}\n\n/// Main interface for reading Avro formatted values.\n///\n/// To be used as an iterator:\n///\n/// ```no_run\n/// # use avro_rs::Reader;\n/// # use std::io::Cursor;\n/// # let input = Cursor::new(Vec::<u8>::new());\n/// for value in Reader::new(input).unwrap() {\n///     match value {\n///         Ok(v) => println!(\"{:?}\", v),\n///         Err(e) => println!(\"Error: {}\", e),\n///     };\n/// }\n/// ```\npub struct Reader<'a, R> {\n    block: Block<R>,\n    reader_schema: Option<&'a Schema>,\n    errored: bool,\n    should_resolve_schema: bool,\n}\n\nimpl<'a, R: Read> Reader<'a, R> {\n    /// Creates a `Reader` given something implementing the `io::Read` trait to read from.\n    /// No reader `Schema` will be set.\n    ///\n    /// **NOTE** The avro header is going to be read automatically upon creation of the `Reader`.\n    pub fn new(reader: R) -> AvroResult<Reader<'a, R>> {\n        let block = Block::new(reader)?;\n        let reader = Reader {\n            block,\n            reader_schema: None,\n            errored: false,\n            should_resolve_schema: false,\n        };\n        Ok(reader)\n    }\n\n    /// Creates a `Reader` given a reader `Schema` and something implementing the `io::Read` trait\n    /// to read from.\n    ///\n    /// **NOTE** The avro header is going to be read automatically upon creation of the `Reader`.\n    pub fn with_schema(schema: &'a Schema, reader: R) -> AvroResult<Reader<'a, R>> {\n        let block = Block::new(reader)?;\n        let mut reader = Reader {\n            block,\n            reader_schema: Some(schema),\n            errored: false,\n            should_resolve_schema: false,\n        };\n        // Check if the reader and writer schemas disagree.\n        reader.should_resolve_schema = reader.writer_schema() != schema;\n        Ok(reader)\n    }\n\n    /// Get a reference to the writer `Schema`.\n    pub fn writer_schema(&self) -> &Schema {\n        &self.block.writer_schema\n    }\n\n    /// Get a reference to the optional reader `Schema`.\n    pub fn reader_schema(&self) -> Option<&Schema> {\n        self.reader_schema\n    }\n\n    #[inline]\n    fn read_next(&mut self) -> AvroResult<Option<Value>> {\n        let read_schema = if self.should_resolve_schema {\n            self.reader_schema\n        } else {\n            None\n        };\n\n        self.block.read_next(read_schema)\n    }\n}\n\nimpl<'a, R: Read> Iterator for Reader<'a, R> {\n    type Item = AvroResult<Value>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // to prevent keep on reading after the first error occurs\n        if self.errored {\n            return None;\n        };\n        match self.read_next() {\n            Ok(opt) => opt.map(Ok),\n            Err(e) => {\n                self.errored = true;\n                Some(Err(e))\n            }\n        }\n    }\n}\n\n/// Decode a `Value` encoded in Avro format given its `Schema` and anything implementing `io::Read`\n/// to read from.\n///\n/// In case a reader `Schema` is provided, schema resolution will also be performed.\n///\n/// **NOTE** This function has a quite small niche of usage and does NOT take care of reading the\n/// header and consecutive data blocks; use [`Reader`](struct.Reader.html) if you don't know what\n/// you are doing, instead.\npub fn from_avro_datum<R: Read>(\n    writer_schema: &Schema,\n    reader: &mut R,\n    reader_schema: Option<&Schema>,\n) -> AvroResult<Value> {\n    let value = decode(writer_schema, reader)?;\n    match reader_schema {\n        Some(schema) => value.resolve(schema),\n        None => Ok(value),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{types::Record, Reader};\n    use std::io::Cursor;\n\n    const SCHEMA: &str = r#\"\n    {\n      \"type\": \"record\",\n      \"name\": \"test\",\n      \"fields\": [\n        {\n          \"name\": \"a\",\n          \"type\": \"long\",\n          \"default\": 42\n        },\n        {\n          \"name\": \"b\",\n          \"type\": \"string\"\n        }\n      ]\n    }\n    \"#;\n    const UNION_SCHEMA: &str = r#\"[\"null\", \"long\"]\"#;\n    const ENCODED: &[u8] = &[\n        79u8, 98u8, 106u8, 1u8, 4u8, 22u8, 97u8, 118u8, 114u8, 111u8, 46u8, 115u8, 99u8, 104u8,\n        101u8, 109u8, 97u8, 222u8, 1u8, 123u8, 34u8, 116u8, 121u8, 112u8, 101u8, 34u8, 58u8, 34u8,\n        114u8, 101u8, 99u8, 111u8, 114u8, 100u8, 34u8, 44u8, 34u8, 110u8, 97u8, 109u8, 101u8, 34u8,\n        58u8, 34u8, 116u8, 101u8, 115u8, 116u8, 34u8, 44u8, 34u8, 102u8, 105u8, 101u8, 108u8,\n        100u8, 115u8, 34u8, 58u8, 91u8, 123u8, 34u8, 110u8, 97u8, 109u8, 101u8, 34u8, 58u8, 34u8,\n        97u8, 34u8, 44u8, 34u8, 116u8, 121u8, 112u8, 101u8, 34u8, 58u8, 34u8, 108u8, 111u8, 110u8,\n        103u8, 34u8, 44u8, 34u8, 100u8, 101u8, 102u8, 97u8, 117u8, 108u8, 116u8, 34u8, 58u8, 52u8,\n        50u8, 125u8, 44u8, 123u8, 34u8, 110u8, 97u8, 109u8, 101u8, 34u8, 58u8, 34u8, 98u8, 34u8,\n        44u8, 34u8, 116u8, 121u8, 112u8, 101u8, 34u8, 58u8, 34u8, 115u8, 116u8, 114u8, 105u8,\n        110u8, 103u8, 34u8, 125u8, 93u8, 125u8, 20u8, 97u8, 118u8, 114u8, 111u8, 46u8, 99u8, 111u8,\n        100u8, 101u8, 99u8, 8u8, 110u8, 117u8, 108u8, 108u8, 0u8, 94u8, 61u8, 54u8, 221u8, 190u8,\n        207u8, 108u8, 180u8, 158u8, 57u8, 114u8, 40u8, 173u8, 199u8, 228u8, 239u8, 4u8, 20u8, 54u8,\n        6u8, 102u8, 111u8, 111u8, 84u8, 6u8, 98u8, 97u8, 114u8, 94u8, 61u8, 54u8, 221u8, 190u8,\n        207u8, 108u8, 180u8, 158u8, 57u8, 114u8, 40u8, 173u8, 199u8, 228u8, 239u8,\n    ];\n\n    #[test]\n    fn test_from_avro_datum() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut encoded: &'static [u8] = &[54, 6, 102, 111, 111];\n\n        let mut record = Record::new(&schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        let expected = record.into();\n\n        assert_eq!(\n            from_avro_datum(&schema, &mut encoded, None).unwrap(),\n            expected\n        );\n    }\n\n    #[test]\n    fn test_null_union() {\n        let schema = Schema::parse_str(UNION_SCHEMA).unwrap();\n        let mut encoded: &'static [u8] = &[2, 0];\n\n        assert_eq!(\n            from_avro_datum(&schema, &mut encoded, None).unwrap(),\n            Value::Union(Box::new(Value::Long(0)))\n        );\n    }\n\n    #[test]\n    fn test_reader_iterator() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let reader = Reader::with_schema(&schema, ENCODED).unwrap();\n\n        let mut record1 = Record::new(&schema).unwrap();\n        record1.put(\"a\", 27i64);\n        record1.put(\"b\", \"foo\");\n\n        let mut record2 = Record::new(&schema).unwrap();\n        record2.put(\"a\", 42i64);\n        record2.put(\"b\", \"bar\");\n\n        let expected = vec![record1.into(), record2.into()];\n\n        for (i, value) in reader.enumerate() {\n            assert_eq!(value.unwrap(), expected[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_invalid_header() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let invalid = ENCODED.to_owned().into_iter().skip(1).collect::<Vec<u8>>();\n        assert!(Reader::with_schema(&schema, &invalid[..]).is_err());\n    }\n\n    #[test]\n    fn test_reader_invalid_block() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let invalid = ENCODED\n            .to_owned()\n            .into_iter()\n            .rev()\n            .skip(19)\n            .collect::<Vec<u8>>()\n            .into_iter()\n            .rev()\n            .collect::<Vec<u8>>();\n        let reader = Reader::with_schema(&schema, &invalid[..]).unwrap();\n        for value in reader {\n            assert!(value.is_err());\n        }\n    }\n\n    #[test]\n    fn test_reader_empty_buffer() {\n        let empty = Cursor::new(Vec::new());\n        assert!(Reader::new(empty).is_err());\n    }\n\n    #[test]\n    fn test_reader_only_header() {\n        let invalid = ENCODED\n            .to_owned()\n            .into_iter()\n            .take(165)\n            .collect::<Vec<u8>>();\n        let reader = Reader::new(&invalid[..]).unwrap();\n        for value in reader {\n            assert!(value.is_err());\n        }\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":102},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","schema.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for parsing and interacting with schemas in Avro format.\nuse crate::{error::Error, types, util::MapHelper, AvroResult};\nuse digest::Digest;\nuse lazy_static::lazy_static;\nuse regex::Regex;\nuse serde::{\n    ser::{SerializeMap, SerializeSeq},\n    Deserialize, Serialize, Serializer,\n};\nuse serde_json::{Map, Value};\nuse std::{\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    convert::TryInto,\n    fmt,\n    str::FromStr,\n};\nuse strum_macros::{EnumDiscriminants, EnumString};\n\nlazy_static! {\n    static ref ENUM_SYMBOL_NAME: Regex = Regex::new(r\"[A-Za-z_][A-Za-z0-9_]*\").unwrap();\n}\n\n/// Represents an Avro schema fingerprint\n/// More information about Avro schema fingerprints can be found in the\n/// [Avro Schema Fingerprint documentation](https://avro.apache.org/docs/current/spec.html#schema_fingerprints)\npub struct SchemaFingerprint {\n    pub bytes: Vec<u8>,\n}\n\nimpl fmt::Display for SchemaFingerprint {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            self.bytes\n                .iter()\n                .map(|byte| format!(\"{:02x}\", byte))\n                .collect::<Vec<String>>()\n                .join(\"\")\n        )\n    }\n}\n\n/// Represents any valid Avro schema\n/// More information about Avro schemas can be found in the\n/// [Avro Specification](https://avro.apache.org/docs/current/spec.html#schemas)\n#[derive(Clone, Debug, EnumDiscriminants)]\n#[strum_discriminants(name(SchemaKind), derive(Hash))]\npub enum Schema {\n    /// A `null` Avro schema.\n    Null,\n    /// A `boolean` Avro schema.\n    Boolean,\n    /// An `int` Avro schema.\n    Int,\n    /// A `long` Avro schema.\n    Long,\n    /// A `float` Avro schema.\n    Float,\n    /// A `double` Avro schema.\n    Double,\n    /// A `bytes` Avro schema.\n    /// `Bytes` represents a sequence of 8-bit unsigned bytes.\n    Bytes,\n    /// A `string` Avro schema.\n    /// `String` represents a unicode character sequence.\n    String,\n    /// A `array` Avro schema. Avro arrays are required to have the same type for each element.\n    /// This variant holds the `Schema` for the array element type.\n    Array(Box<Schema>),\n    /// A `map` Avro schema.\n    /// `Map` holds a pointer to the `Schema` of its values, which must all be the same schema.\n    /// `Map` keys are assumed to be `string`.\n    Map(Box<Schema>),\n    /// A `union` Avro schema.\n    Union(UnionSchema),\n    /// A `record` Avro schema.\n    ///\n    /// The `lookup` table maps field names to their position in the `Vec`\n    /// of `fields`.\n    Record {\n        name: Name,\n        doc: Documentation,\n        fields: Vec<RecordField>,\n        lookup: HashMap<String, usize>,\n    },\n    /// An `enum` Avro schema.\n    Enum {\n        name: Name,\n        doc: Documentation,\n        symbols: Vec<String>,\n    },\n    /// A `fixed` Avro schema.\n    Fixed { name: Name, size: usize },\n    /// Logical type which represents `Decimal` values. The underlying type is serialized and\n    /// deserialized as `Schema::Bytes` or `Schema::Fixed`.\n    ///\n    /// `scale` defaults to 0 and is an integer greater than or equal to 0 and `precision` is an\n    /// integer greater than 0.\n    Decimal {\n        precision: DecimalMetadata,\n        scale: DecimalMetadata,\n        inner: Box<Schema>,\n    },\n    /// A universally unique identifier, annotating a string.\n    Uuid,\n    /// Logical type which represents the number of days since the unix epoch.\n    /// Serialization format is `Schema::Int`.\n    Date,\n    /// The time of day in number of milliseconds after midnight with no reference any calendar,\n    /// time zone or date in particular.\n    TimeMillis,\n    /// The time of day in number of microseconds after midnight with no reference any calendar,\n    /// time zone or date in particular.\n    TimeMicros,\n    /// An instant in time represented as the number of milliseconds after the UNIX epoch.\n    TimestampMillis,\n    /// An instant in time represented as the number of microseconds after the UNIX epoch.\n    TimestampMicros,\n    /// An amount of time defined by a number of months, days and milliseconds.\n    Duration,\n}\n\nimpl PartialEq for Schema {\n    /// Assess equality of two `Schema` based on [Parsing Canonical Form].\n    ///\n    /// [Parsing Canonical Form]:\n    /// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\n    fn eq(&self, other: &Self) -> bool {\n        self.canonical_form() == other.canonical_form()\n    }\n}\n\nimpl SchemaKind {\n    pub fn is_primitive(self) -> bool {\n        matches!(\n            self,\n            SchemaKind::Null\n                | SchemaKind::Boolean\n                | SchemaKind::Int\n                | SchemaKind::Long\n                | SchemaKind::Double\n                | SchemaKind::Float\n                | SchemaKind::Bytes\n                | SchemaKind::String,\n        )\n    }\n}\n\nimpl<'a> From<&'a types::Value> for SchemaKind {\n    fn from(value: &'a types::Value) -> Self {\n        use crate::types::Value;\n        match value {\n            Value::Null => Self::Null,\n            Value::Boolean(_) => Self::Boolean,\n            Value::Int(_) => Self::Int,\n            Value::Long(_) => Self::Long,\n            Value::Float(_) => Self::Float,\n            Value::Double(_) => Self::Double,\n            Value::Bytes(_) => Self::Bytes,\n            Value::String(_) => Self::String,\n            Value::Array(_) => Self::Array,\n            Value::Map(_) => Self::Map,\n            Value::Union(_) => Self::Union,\n            Value::Record(_) => Self::Record,\n            Value::Enum(_, _) => Self::Enum,\n            Value::Fixed(_, _) => Self::Fixed,\n            Value::Decimal { .. } => Self::Decimal,\n            Value::Uuid(_) => Self::Uuid,\n            Value::Date(_) => Self::Date,\n            Value::TimeMillis(_) => Self::TimeMillis,\n            Value::TimeMicros(_) => Self::TimeMicros,\n            Value::TimestampMillis(_) => Self::TimestampMillis,\n            Value::TimestampMicros(_) => Self::TimestampMicros,\n            Value::Duration { .. } => Self::Duration,\n        }\n    }\n}\n\n/// Represents names for `record`, `enum` and `fixed` Avro schemas.\n///\n/// Each of these `Schema`s have a `fullname` composed of two parts:\n///   * a name\n///   * a namespace\n///\n/// `aliases` can also be defined, to facilitate schema evolution.\n///\n/// More information about schema names can be found in the\n/// [Avro specification](https://avro.apache.org/docs/current/spec.html#names)\n#[derive(Clone, Debug, PartialEq, Deserialize)]\npub struct Name {\n    pub name: String,\n    pub namespace: Option<String>,\n    pub aliases: Option<Vec<String>>,\n}\n\n/// Represents documentation for complex Avro schemas.\npub type Documentation = Option<String>;\n\nimpl Name {\n    /// Create a new `Name`.\n    /// No `namespace` nor `aliases` will be defined.\n    pub fn new(name: &str) -> Name {\n        Name {\n            name: name.to_owned(),\n            namespace: None,\n            aliases: None,\n        }\n    }\n\n    /// Parse a `serde_json::Value` into a `Name`.\n    fn parse(complex: &Map<String, Value>) -> AvroResult<Self> {\n        let name = complex.name().ok_or(Error::GetNameField)?;\n\n        let namespace = complex.string(\"namespace\");\n\n        let aliases: Option<Vec<String>> = complex\n            .get(\"aliases\")\n            .and_then(|aliases| aliases.as_array())\n            .and_then(|aliases| {\n                aliases\n                    .iter()\n                    .map(|alias| alias.as_str())\n                    .map(|alias| alias.map(|a| a.to_string()))\n                    .collect::<Option<_>>()\n            });\n\n        Ok(Name {\n            name,\n            namespace,\n            aliases,\n        })\n    }\n\n    /// Return the `fullname` of this `Name`\n    ///\n    /// More information about fullnames can be found in the\n    /// [Avro specification](https://avro.apache.org/docs/current/spec.html#names)\n    pub fn fullname(&self, default_namespace: Option<&str>) -> String {\n        if self.name.contains('.') {\n            self.name.clone()\n        } else {\n            let namespace = self\n                .namespace\n                .as_ref()\n                .map(|s| s.as_ref())\n                .or(default_namespace);\n\n            match namespace {\n                Some(ref namespace) => format!(\"{}.{}\", namespace, self.name),\n                None => self.name.clone(),\n            }\n        }\n    }\n}\n\n/// Represents a `field` in a `record` Avro schema.\n#[derive(Clone, Debug, PartialEq)]\npub struct RecordField {\n    /// Name of the field.\n    pub name: String,\n    /// Documentation of the field.\n    pub doc: Documentation,\n    /// Default value of the field.\n    /// This value will be used when reading Avro datum if schema resolution\n    /// is enabled.\n    pub default: Option<Value>,\n    /// Schema of the field.\n    pub schema: Schema,\n    /// Order of the field.\n    ///\n    /// **NOTE** This currently has no effect.\n    pub order: RecordFieldOrder,\n    /// Position of the field in the list of `field` of its parent `Schema`\n    pub position: usize,\n}\n\n/// Represents any valid order for a `field` in a `record` Avro schema.\n#[derive(Clone, Debug, PartialEq, EnumString)]\n#[strum(serialize_all = \"kebab_case\")]\npub enum RecordFieldOrder {\n    Ascending,\n    Descending,\n    Ignore,\n}\n\nimpl RecordField {\n    /// Parse a `serde_json::Value` into a `RecordField`.\n    fn parse(field: &Map<String, Value>, position: usize, parser: &mut Parser) -> AvroResult<Self> {\n        let name = field.name().ok_or(Error::GetNameFieldFromRecord)?;\n\n        // TODO: \"type\" = \"<record name>\"\n        let schema = parser.parse_complex(field)?;\n\n        let default = field.get(\"default\").cloned();\n\n        let order = field\n            .get(\"order\")\n            .and_then(|order| order.as_str())\n            .and_then(|order| RecordFieldOrder::from_str(order).ok())\n            .unwrap_or(RecordFieldOrder::Ascending);\n\n        Ok(RecordField {\n            name,\n            doc: field.doc(),\n            default,\n            schema,\n            order,\n            position,\n        })\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct UnionSchema {\n    pub(crate) schemas: Vec<Schema>,\n    // Used to ensure uniqueness of schema inputs, and provide constant time finding of the\n    // schema index given a value.\n    // **NOTE** that this approach does not work for named types, and will have to be modified\n    // to support that. A simple solution is to also keep a mapping of the names used.\n    variant_index: HashMap<SchemaKind, usize>,\n}\n\nimpl UnionSchema {\n    pub(crate) fn new(schemas: Vec<Schema>) -> AvroResult<Self> {\n        let mut vindex = HashMap::new();\n        for (i, schema) in schemas.iter().enumerate() {\n            if let Schema::Union(_) = schema {\n                return Err(Error::GetNestedUnion);\n            }\n            let kind = SchemaKind::from(schema);\n            if vindex.insert(kind, i).is_some() {\n                return Err(Error::GetUnionDuplicate);\n            }\n        }\n        Ok(UnionSchema {\n            schemas,\n            variant_index: vindex,\n        })\n    }\n\n    /// Returns a slice to all variants of this schema.\n    pub fn variants(&self) -> &[Schema] {\n        &self.schemas\n    }\n\n    /// Returns true if the first variant of this `UnionSchema` is `Null`.\n    pub fn is_nullable(&self) -> bool {\n        !self.schemas.is_empty() && self.schemas[0] == Schema::Null\n    }\n\n    /// Optionally returns a reference to the schema matched by this value, as well as its position\n    /// within this union.\n    pub fn find_schema(&self, value: &types::Value) -> Option<(usize, &Schema)> {\n        let type_index = &SchemaKind::from(value);\n        if let Some(&i) = self.variant_index.get(type_index) {\n            // fast path\n            Some((i, &self.schemas[i]))\n        } else {\n            // slow path (required for matching logical types)\n            self.schemas\n                .iter()\n                .enumerate()\n                .find(|(_, schema)| value.validate(schema))\n        }\n    }\n}\n\n// No need to compare variant_index, it is derivative of schemas.\nimpl PartialEq for UnionSchema {\n    fn eq(&self, other: &UnionSchema) -> bool {\n        self.schemas.eq(&other.schemas)\n    }\n}\n\ntype DecimalMetadata = usize;\npub(crate) type Precision = DecimalMetadata;\npub(crate) type Scale = DecimalMetadata;\n\nfn parse_json_integer_for_decimal(value: &serde_json::Number) -> Result<DecimalMetadata, Error> {\n    Ok(if value.is_u64() {\n        let num = value\n            .as_u64()\n            .ok_or_else(|| Error::GetU64FromJson(value.clone()))?;\n        num.try_into()\n            .map_err(|e| Error::ConvertU64ToUsize(e, num))?\n    } else if value.is_i64() {\n        let num = value\n            .as_i64()\n            .ok_or_else(|| Error::GetI64FromJson(value.clone()))?;\n        num.try_into()\n            .map_err(|e| Error::ConvertI64ToUsize(e, num))?\n    } else {\n        return Err(Error::GetPrecisionOrScaleFromJson(value.clone()));\n    })\n}\n\n#[derive(Default)]\nstruct Parser {\n    input_schemas: HashMap<String, Value>,\n    input_order: Vec<String>,\n    parsed_schemas: HashMap<String, Schema>,\n}\n\nimpl Schema {\n    /// Converts `self` into its [Parsing Canonical Form].\n    ///\n    /// [Parsing Canonical Form]:\n    /// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\n    pub fn canonical_form(&self) -> String {\n        let json = serde_json::to_value(self)\n            .unwrap_or_else(|e| panic!(\"cannot parse Schema from JSON: {0}\", e));\n        parsing_canonical_form(&json)\n    }\n\n    /// Generate [fingerprint] of Schema's [Parsing Canonical Form].\n    ///\n    /// [Parsing Canonical Form]:\n    /// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\n    /// [fingerprint]:\n    /// https://avro.apache.org/docs/current/spec.html#schema_fingerprints\n    pub fn fingerprint<D: Digest>(&self) -> SchemaFingerprint {\n        let mut d = D::new();\n        d.update(self.canonical_form());\n        SchemaFingerprint {\n            bytes: d.finalize().to_vec(),\n        }\n    }\n\n    /// Create a `Schema` from a string representing a JSON Avro schema.\n    pub fn parse_str(input: &str) -> Result<Schema, Error> {\n        let mut parser = Parser::default();\n        parser.parse_str(input)\n    }\n\n    /// Create a array of `Schema`'s from a list of named JSON Avro schemas (Record, Enum, and\n    /// Fixed).\n    ///\n    /// It is allowed that the schemas have cross-dependencies; these will be resolved\n    /// during parsing.\n    ///\n    /// If two of the input schemas have the same fullname, an Error will be returned.\n    pub fn parse_list(input: &[&str]) -> Result<Vec<Schema>, Error> {\n        let mut input_schemas: HashMap<String, Value> = HashMap::with_capacity(input.len());\n        let mut input_order: Vec<String> = Vec::with_capacity(input.len());\n        for js in input {\n            let schema: Value = serde_json::from_str(js).map_err(Error::ParseSchemaJson)?;\n            if let Value::Object(inner) = &schema {\n                let fullname = Name::parse(inner)?.fullname(None);\n                let previous_value = input_schemas.insert(fullname.clone(), schema);\n                if previous_value.is_some() {\n                    return Err(Error::NameCollision(fullname));\n                }\n                input_order.push(fullname);\n            } else {\n                return Err(Error::GetNameField);\n            }\n        }\n        let mut parser = Parser {\n            input_schemas,\n            input_order,\n            parsed_schemas: HashMap::with_capacity(input.len()),\n        };\n        parser.parse_list()\n    }\n\n    pub fn parse(value: &Value) -> AvroResult<Schema> {\n        let mut parser = Parser::default();\n        parser.parse(value)\n    }\n}\n\nimpl Parser {\n    /// Create a `Schema` from a string representing a JSON Avro schema.\n    fn parse_str(&mut self, input: &str) -> Result<Schema, Error> {\n        // TODO: (#82) this should be a ParseSchemaError wrapping the JSON error\n        let value = serde_json::from_str(input).map_err(Error::ParseSchemaJson)?;\n        self.parse(&value)\n    }\n\n    /// Create an array of `Schema`'s from an iterator of JSON Avro schemas. It is allowed that\n    /// the schemas have cross-dependencies; these will be resolved during parsing.\n    fn parse_list(&mut self) -> Result<Vec<Schema>, Error> {\n        while !self.input_schemas.is_empty() {\n            let next_name = self\n                .input_schemas\n                .keys()\n                .next()\n                .expect(\"Input schemas unexpectedly empty\")\n                .to_owned();\n            let (name, value) = self\n                .input_schemas\n                .remove_entry(&next_name)\n                .expect(\"Key unexpectedly missing\");\n            let parsed = self.parse(&value)?;\n            self.parsed_schemas.insert(name, parsed);\n        }\n\n        let mut parsed_schemas = Vec::with_capacity(self.parsed_schemas.len());\n        for name in self.input_order.drain(0..) {\n            let parsed = self\n                .parsed_schemas\n                .remove(&name)\n                .expect(\"One of the input schemas was unexpectedly not parsed\");\n            parsed_schemas.push(parsed);\n        }\n        Ok(parsed_schemas)\n    }\n\n    /// Create a `Schema` from a `serde_json::Value` representing a JSON Avro\n    /// schema.\n    fn parse(&mut self, value: &Value) -> AvroResult<Schema> {\n        match *value {\n            Value::String(ref t) => self.parse_known_schema(t.as_str()),\n            Value::Object(ref data) => self.parse_complex(data),\n            Value::Array(ref data) => self.parse_union(data),\n            _ => Err(Error::ParseSchemaFromValidJson),\n        }\n    }\n\n    /// Parse a `serde_json::Value` representing an Avro type whose Schema is known into a\n    /// `Schema`. A Schema for a `serde_json::Value` is known if it is primitive or has\n    /// been parsed previously by the parsed and stored in its map of parsed_schemas.\n    fn parse_known_schema(&mut self, name: &str) -> AvroResult<Schema> {\n        match name {\n            \"null\" => Ok(Schema::Null),\n            \"boolean\" => Ok(Schema::Boolean),\n            \"int\" => Ok(Schema::Int),\n            \"long\" => Ok(Schema::Long),\n            \"double\" => Ok(Schema::Double),\n            \"float\" => Ok(Schema::Float),\n            \"bytes\" => Ok(Schema::Bytes),\n            \"string\" => Ok(Schema::String),\n            _ => self.fetch_schema(name),\n        }\n    }\n\n    /// Given a name, tries to retrieve the parsed schema from `parsed_schemas`.\n    /// If a parsed schema is not found, it checks if a json  with that name exists\n    /// in `input_schemas` and then parses it  (removing it from `input_schemas`)\n    /// and adds the parsed schema to `parsed_schemas`\n    ///\n    /// This method allows schemas definitions that depend on other types to\n    /// parse their dependencies (or look them up if already parsed).\n    fn fetch_schema(&mut self, name: &str) -> AvroResult<Schema> {\n        if let Some(parsed) = self.parsed_schemas.get(name) {\n            return Ok(parsed.clone());\n        }\n        let value = self\n            .input_schemas\n            .remove(name)\n            .ok_or_else(|| Error::ParsePrimitive(name.into()))?;\n        let parsed = self.parse(&value)?;\n        self.parsed_schemas.insert(name.to_string(), parsed.clone());\n        Ok(parsed)\n    }\n\n    fn parse_precision_and_scale(\n        complex: &Map<String, Value>,\n    ) -> Result<(Precision, Scale), Error> {\n        fn get_decimal_integer(\n            complex: &Map<String, Value>,\n            key: &'static str,\n        ) -> Result<DecimalMetadata, Error> {\n            match complex.get(key) {\n                Some(&Value::Number(ref value)) => parse_json_integer_for_decimal(value),\n                None => Err(Error::GetDecimalMetadataFromJson(key)),\n                Some(precision) => Err(Error::GetDecimalPrecisionFromJson {\n                    key: key.into(),\n                    precision: precision.clone(),\n                }),\n            }\n        }\n        let precision = get_decimal_integer(complex, \"precision\")?;\n        let scale = get_decimal_integer(complex, \"scale\")?;\n        Ok((precision, scale))\n    }\n\n    /// Parse a `serde_json::Value` representing a complex Avro type into a\n    /// `Schema`.\n    ///\n    /// Avro supports \"recursive\" definition of types.\n    /// e.g: {\"type\": {\"type\": \"string\"}}\n    fn parse_complex(&mut self, complex: &Map<String, Value>) -> AvroResult<Schema> {\n        fn logical_verify_type(\n            complex: &Map<String, Value>,\n            kinds: &[SchemaKind],\n            parser: &mut Parser,\n        ) -> AvroResult<Schema> {\n            match complex.get(\"type\") {\n                Some(value) => {\n                    let ty = parser.parse(value)?;\n                    if kinds\n                        .iter()\n                        .any(|&kind| SchemaKind::from(ty.clone()) == kind)\n                    {\n                        Ok(ty)\n                    } else {\n                        Err(Error::GetLogicalTypeVariant(value.clone()))\n                    }\n                }\n                None => Err(Error::GetLogicalTypeField),\n            }\n        }\n        match complex.get(\"logicalType\") {\n            Some(&Value::String(ref t)) => match t.as_str() {\n                \"decimal\" => {\n                    let inner = Box::new(logical_verify_type(\n                        complex,\n                        &[SchemaKind::Fixed, SchemaKind::Bytes],\n                        self,\n                    )?);\n\n                    let (precision, scale) = Self::parse_precision_and_scale(complex)?;\n\n                    return Ok(Schema::Decimal {\n                        precision,\n                        scale,\n                        inner,\n                    });\n                }\n                \"uuid\" => {\n                    logical_verify_type(complex, &[SchemaKind::String], self)?;\n                    return Ok(Schema::Uuid);\n                }\n                \"date\" => {\n                    logical_verify_type(complex, &[SchemaKind::Int], self)?;\n                    return Ok(Schema::Date);\n                }\n                \"time-millis\" => {\n                    logical_verify_type(complex, &[SchemaKind::Int], self)?;\n                    return Ok(Schema::TimeMillis);\n                }\n                \"time-micros\" => {\n                    logical_verify_type(complex, &[SchemaKind::Long], self)?;\n                    return Ok(Schema::TimeMicros);\n                }\n                \"timestamp-millis\" => {\n                    logical_verify_type(complex, &[SchemaKind::Long], self)?;\n                    return Ok(Schema::TimestampMillis);\n                }\n                \"timestamp-micros\" => {\n                    logical_verify_type(complex, &[SchemaKind::Long], self)?;\n                    return Ok(Schema::TimestampMicros);\n                }\n                \"duration\" => {\n                    logical_verify_type(complex, &[SchemaKind::Fixed], self)?;\n                    return Ok(Schema::Duration);\n                }\n                // In this case, of an unknown logical type, we just pass through to the underlying\n                // type.\n                _ => {}\n            },\n            // The spec says to ignore invalid logical types and just continue through to the\n            // underlying type - It is unclear whether that applies to this case or not, where the\n            // `logicalType` is not a string.\n            Some(_) => return Err(Error::GetLogicalTypeFieldType),\n            _ => {}\n        }\n        match complex.get(\"type\") {\n            Some(&Value::String(ref t)) => match t.as_str() {\n                \"record\" => self.parse_record(complex),\n                \"enum\" => Self::parse_enum(complex),\n                \"array\" => self.parse_array(complex),\n                \"map\" => self.parse_map(complex),\n                \"fixed\" => Self::parse_fixed(complex),\n                other => self.parse_known_schema(other),\n            },\n            Some(&Value::Object(ref data)) => self.parse_complex(data),\n            Some(&Value::Array(ref variants)) => self.parse_union(variants),\n            Some(unknown) => Err(Error::GetComplexType(unknown.clone())),\n            None => Err(Error::GetComplexTypeField),\n        }\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro record type into a\n    /// `Schema`.\n    fn parse_record(&mut self, complex: &Map<String, Value>) -> AvroResult<Schema> {\n        let name = Name::parse(complex)?;\n\n        let mut lookup = HashMap::new();\n\n        let fields: Vec<RecordField> = complex\n            .get(\"fields\")\n            .and_then(|fields| fields.as_array())\n            .ok_or(Error::GetRecordFieldsJson)\n            .and_then(|fields| {\n                fields\n                    .iter()\n                    .filter_map(|field| field.as_object())\n                    .enumerate()\n                    .map(|(position, field)| RecordField::parse(field, position, self))\n                    .collect::<Result<_, _>>()\n            })?;\n\n        for field in &fields {\n            lookup.insert(field.name.clone(), field.position);\n        }\n\n        Ok(Schema::Record {\n            name,\n            doc: complex.doc(),\n            fields,\n            lookup,\n        })\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro enum type into a\n    /// `Schema`.\n    fn parse_enum(complex: &Map<String, Value>) -> AvroResult<Schema> {\n        let name = Name::parse(complex)?;\n\n        let symbols: Vec<String> = complex\n            .get(\"symbols\")\n            .and_then(|v| v.as_array())\n            .ok_or(Error::GetEnumSymbolsField)\n            .and_then(|symbols| {\n                symbols\n                    .iter()\n                    .map(|symbol| symbol.as_str().map(|s| s.to_string()))\n                    .collect::<Option<_>>()\n                    .ok_or(Error::GetEnumSymbols)\n            })?;\n\n        let mut existing_symbols: HashSet<&String> = HashSet::with_capacity(symbols.len());\n        for symbol in symbols.iter() {\n            // Ensure enum symbol names match [A-Za-z_][A-Za-z0-9_]*\n            if !ENUM_SYMBOL_NAME.is_match(symbol) {\n                return Err(Error::EnumSymbolName(symbol.to_string()));\n            }\n\n            // Ensure there are no duplicate symbols\n            if existing_symbols.contains(&symbol) {\n                return Err(Error::EnumSymbolDuplicate(symbol.to_string()));\n            }\n\n            existing_symbols.insert(symbol);\n        }\n\n        Ok(Schema::Enum {\n            name,\n            doc: complex.doc(),\n            symbols,\n        })\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro array type into a\n    /// `Schema`.\n    fn parse_array(&mut self, complex: &Map<String, Value>) -> AvroResult<Schema> {\n        complex\n            .get(\"items\")\n            .ok_or(Error::GetArrayItemsField)\n            .and_then(|items| self.parse(items))\n            .map(|schema| Schema::Array(Box::new(schema)))\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro map type into a\n    /// `Schema`.\n    fn parse_map(&mut self, complex: &Map<String, Value>) -> AvroResult<Schema> {\n        complex\n            .get(\"values\")\n            .ok_or(Error::GetMapValuesField)\n            .and_then(|items| self.parse(items))\n            .map(|schema| Schema::Map(Box::new(schema)))\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro union type into a\n    /// `Schema`.\n    fn parse_union(&mut self, items: &[Value]) -> AvroResult<Schema> {\n        items\n            .iter()\n            .map(|v| self.parse(v))\n            .collect::<Result<Vec<_>, _>>()\n            .and_then(|schemas| Ok(Schema::Union(UnionSchema::new(schemas)?)))\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro fixed type into a\n    /// `Schema`.\n    fn parse_fixed(complex: &Map<String, Value>) -> AvroResult<Schema> {\n        let name = Name::parse(complex)?;\n\n        let size = complex\n            .get(\"size\")\n            .and_then(|v| v.as_i64())\n            .ok_or(Error::GetFixedSizeField)?;\n\n        Ok(Schema::Fixed {\n            name,\n            size: size as usize,\n        })\n    }\n}\n\nimpl Serialize for Schema {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match *self {\n            Schema::Null => serializer.serialize_str(\"null\"),\n            Schema::Boolean => serializer.serialize_str(\"boolean\"),\n            Schema::Int => serializer.serialize_str(\"int\"),\n            Schema::Long => serializer.serialize_str(\"long\"),\n            Schema::Float => serializer.serialize_str(\"float\"),\n            Schema::Double => serializer.serialize_str(\"double\"),\n            Schema::Bytes => serializer.serialize_str(\"bytes\"),\n            Schema::String => serializer.serialize_str(\"string\"),\n            Schema::Array(ref inner) => {\n                let mut map = serializer.serialize_map(Some(2))?;\n                map.serialize_entry(\"type\", \"array\")?;\n                map.serialize_entry(\"items\", &*inner.clone())?;\n                map.end()\n            }\n            Schema::Map(ref inner) => {\n                let mut map = serializer.serialize_map(Some(2))?;\n                map.serialize_entry(\"type\", \"map\")?;\n                map.serialize_entry(\"values\", &*inner.clone())?;\n                map.end()\n            }\n            Schema::Union(ref inner) => {\n                let variants = inner.variants();\n                let mut seq = serializer.serialize_seq(Some(variants.len()))?;\n                for v in variants {\n                    seq.serialize_element(v)?;\n                }\n                seq.end()\n            }\n            Schema::Record {\n                ref name,\n                ref doc,\n                ref fields,\n                ..\n            } => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"record\")?;\n                if let Some(ref n) = name.namespace {\n                    map.serialize_entry(\"namespace\", n)?;\n                }\n                map.serialize_entry(\"name\", &name.name)?;\n                if let Some(ref docstr) = doc {\n                    map.serialize_entry(\"doc\", docstr)?;\n                }\n                if let Some(ref aliases) = name.aliases {\n                    map.serialize_entry(\"aliases\", aliases)?;\n                }\n                map.serialize_entry(\"fields\", fields)?;\n                map.end()\n            }\n            Schema::Enum {\n                ref name,\n                ref symbols,\n                ..\n            } => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"enum\")?;\n                map.serialize_entry(\"name\", &name.name)?;\n                map.serialize_entry(\"symbols\", symbols)?;\n                map.end()\n            }\n            Schema::Fixed { ref name, ref size } => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"fixed\")?;\n                map.serialize_entry(\"name\", &name.name)?;\n                map.serialize_entry(\"size\", size)?;\n                map.end()\n            }\n            Schema::Decimal {\n                ref scale,\n                ref precision,\n                ref inner,\n            } => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", &*inner.clone())?;\n                map.serialize_entry(\"logicalType\", \"decimal\")?;\n                map.serialize_entry(\"scale\", scale)?;\n                map.serialize_entry(\"precision\", precision)?;\n                map.end()\n            }\n            Schema::Uuid => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"string\")?;\n                map.serialize_entry(\"logicalType\", \"uuid\")?;\n                map.end()\n            }\n            Schema::Date => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"int\")?;\n                map.serialize_entry(\"logicalType\", \"date\")?;\n                map.end()\n            }\n            Schema::TimeMillis => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"int\")?;\n                map.serialize_entry(\"logicalType\", \"time-millis\")?;\n                map.end()\n            }\n            Schema::TimeMicros => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"long\")?;\n                map.serialize_entry(\"logicalType\", \"time-micros\")?;\n                map.end()\n            }\n            Schema::TimestampMillis => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"long\")?;\n                map.serialize_entry(\"logicalType\", \"timestamp-millis\")?;\n                map.end()\n            }\n            Schema::TimestampMicros => {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"long\")?;\n                map.serialize_entry(\"logicalType\", \"timestamp-micros\")?;\n                map.end()\n            }\n            Schema::Duration => {\n                let mut map = serializer.serialize_map(None)?;\n\n                // the Avro doesn't indicate what the name of the underlying fixed type of a\n                // duration should be or typically is.\n                let inner = Schema::Fixed {\n                    name: Name::new(\"duration\"),\n                    size: 12,\n                };\n                map.serialize_entry(\"type\", &inner)?;\n                map.serialize_entry(\"logicalType\", \"duration\")?;\n                map.end()\n            }\n        }\n    }\n}\n\nimpl Serialize for RecordField {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let mut map = serializer.serialize_map(None)?;\n        map.serialize_entry(\"name\", &self.name)?;\n        map.serialize_entry(\"type\", &self.schema)?;\n\n        if let Some(ref default) = self.default {\n            map.serialize_entry(\"default\", default)?;\n        }\n\n        map.end()\n    }\n}\n\n/// Parses a **valid** avro schema into the Parsing Canonical Form.\n/// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\nfn parsing_canonical_form(schema: &serde_json::Value) -> String {\n    match schema {\n        serde_json::Value::Object(map) => pcf_map(map),\n        serde_json::Value::String(s) => pcf_string(s),\n        serde_json::Value::Array(v) => pcf_array(v),\n        json => panic!(\n            \"got invalid JSON value for canonical form of schema: {0}\",\n            json\n        ),\n    }\n}\n\nfn pcf_map(schema: &Map<String, serde_json::Value>) -> String {\n    // Look for the namespace variant up front.\n    let ns = schema.get(\"namespace\").and_then(|v| v.as_str());\n    let mut fields = Vec::new();\n    for (k, v) in schema {\n        // Reduce primitive types to their simple form. ([PRIMITIVE] rule)\n        if schema.len() == 1 && k == \"type\" {\n            // Invariant: function is only callable from a valid schema, so this is acceptable.\n            if let serde_json::Value::String(s) = v {\n                return pcf_string(s);\n            }\n        }\n\n        // Strip out unused fields ([STRIP] rule)\n        if field_ordering_position(k).is_none() || k == \"default\" || k == \"doc\" || k == \"aliases\" {\n            continue;\n        }\n\n        // Fully qualify the name, if it isn't already ([FULLNAMES] rule).\n        if k == \"name\" {\n            // Invariant: Only valid schemas. Must be a string.\n            let name = v.as_str().unwrap();\n            let n = match ns {\n                Some(namespace) if !name.contains('.') => {\n                    Cow::Owned(format!(\"{}.{}\", namespace, name))\n                }\n                _ => Cow::Borrowed(name),\n            };\n\n            fields.push((k, format!(\"{}:{}\", pcf_string(k), pcf_string(&*n))));\n            continue;\n        }\n\n        // Strip off quotes surrounding \"size\" type, if they exist ([INTEGERS] rule).\n        if k == \"size\" {\n            let i = match v.as_str() {\n                Some(s) => s.parse::<i64>().expect(\"Only valid schemas are accepted!\"),\n                None => v.as_i64().unwrap(),\n            };\n            fields.push((k, format!(\"{}:{}\", pcf_string(k), i)));\n            continue;\n        }\n\n        // For anything else, recursively process the result.\n        fields.push((\n            k,\n            format!(\"{}:{}\", pcf_string(k), parsing_canonical_form(v)),\n        ));\n    }\n\n    // Sort the fields by their canonical ordering ([ORDER] rule).\n    fields.sort_unstable_by_key(|(k, _)| field_ordering_position(k).unwrap());\n    let inter = fields\n        .into_iter()\n        .map(|(_, v)| v)\n        .collect::<Vec<_>>()\n        .join(\",\");\n    format!(\"{{{}}}\", inter)\n}\n\nfn pcf_array(arr: &[serde_json::Value]) -> String {\n    let inter = arr\n        .iter()\n        .map(parsing_canonical_form)\n        .collect::<Vec<String>>()\n        .join(\",\");\n    format!(\"[{}]\", inter)\n}\n\nfn pcf_string(s: &str) -> String {\n    format!(\"\\\"{}\\\"\", s)\n}\n\nconst RESERVED_FIELDS: &[&str] = &[\n    \"name\",\n    \"type\",\n    \"fields\",\n    \"symbols\",\n    \"items\",\n    \"values\",\n    \"logicalType\",\n    \"size\",\n    \"order\",\n    \"doc\",\n    \"aliases\",\n    \"default\",\n];\n\n// Used to define the ordering and inclusion of fields.\nfn field_ordering_position(field: &str) -> Option<usize> {\n    RESERVED_FIELDS\n        .iter()\n        .position(|&f| f == field)\n        .map(|pos| pos + 1)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_invalid_schema() {\n        assert!(Schema::parse_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_primitive_schema() {\n        assert_eq!(Schema::Null, Schema::parse_str(\"\\\"null\\\"\").unwrap());\n        assert_eq!(Schema::Int, Schema::parse_str(\"\\\"int\\\"\").unwrap());\n        assert_eq!(Schema::Double, Schema::parse_str(\"\\\"double\\\"\").unwrap());\n    }\n\n    #[test]\n    fn test_array_schema() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\": \"string\"}\"#).unwrap();\n        assert_eq!(Schema::Array(Box::new(Schema::String)), schema);\n    }\n\n    #[test]\n    fn test_map_schema() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"map\", \"values\": \"double\"}\"#).unwrap();\n        assert_eq!(Schema::Map(Box::new(Schema::Double)), schema);\n    }\n\n    #[test]\n    fn test_union_schema() {\n        let schema = Schema::parse_str(r#\"[\"null\", \"int\"]\"#).unwrap();\n        assert_eq!(\n            Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::Int]).unwrap()),\n            schema\n        );\n    }\n\n    #[test]\n    fn test_union_unsupported_schema() {\n        let schema = Schema::parse_str(r#\"[\"null\", [\"null\", \"int\"], \"string\"]\"#);\n        assert!(schema.is_err());\n    }\n\n    #[test]\n    fn test_multi_union_schema() {\n        let schema = Schema::parse_str(r#\"[\"null\", \"int\", \"float\", \"string\", \"bytes\"]\"#);\n        assert!(schema.is_ok());\n        let schema = schema.unwrap();\n        assert_eq!(SchemaKind::from(&schema), SchemaKind::Union);\n        let union_schema = match schema {\n            Schema::Union(u) => u,\n            _ => unreachable!(),\n        };\n        assert_eq!(union_schema.variants().len(), 5);\n        let mut variants = union_schema.variants().iter();\n        assert_eq!(SchemaKind::from(variants.next().unwrap()), SchemaKind::Null);\n        assert_eq!(SchemaKind::from(variants.next().unwrap()), SchemaKind::Int);\n        assert_eq!(\n            SchemaKind::from(variants.next().unwrap()),\n            SchemaKind::Float\n        );\n        assert_eq!(\n            SchemaKind::from(variants.next().unwrap()),\n            SchemaKind::String\n        );\n        assert_eq!(\n            SchemaKind::from(variants.next().unwrap()),\n            SchemaKind::Bytes\n        );\n        assert_eq!(variants.next(), None);\n    }\n\n    #[test]\n    fn test_record_schema() {\n        let schema = Schema::parse_str(\n            r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"}\n                ]\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let mut lookup = HashMap::new();\n        lookup.insert(\"a\".to_owned(), 0);\n        lookup.insert(\"b\".to_owned(), 1);\n\n        let expected = Schema::Record {\n            name: Name::new(\"test\"),\n            doc: None,\n            fields: vec![\n                RecordField {\n                    name: \"a\".to_string(),\n                    doc: None,\n                    default: Some(Value::Number(42i64.into())),\n                    schema: Schema::Long,\n                    order: RecordFieldOrder::Ascending,\n                    position: 0,\n                },\n                RecordField {\n                    name: \"b\".to_string(),\n                    doc: None,\n                    default: None,\n                    schema: Schema::String,\n                    order: RecordFieldOrder::Ascending,\n                    position: 1,\n                },\n            ],\n            lookup,\n        };\n\n        assert_eq!(expected, schema);\n    }\n\n    #[test]\n    fn test_enum_schema() {\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Suit\", \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]}\"#,\n        ).unwrap();\n\n        let expected = Schema::Enum {\n            name: Name::new(\"Suit\"),\n            doc: None,\n            symbols: vec![\n                \"diamonds\".to_owned(),\n                \"spades\".to_owned(),\n                \"clubs\".to_owned(),\n                \"hearts\".to_owned(),\n            ],\n        };\n\n        assert_eq!(expected, schema);\n    }\n\n    #[test]\n    fn test_enum_schema_duplicate() {\n        // Duplicate \"diamonds\"\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Suit\", \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"diamonds\"]}\"#,\n        );\n        assert!(schema.is_err());\n    }\n\n    #[test]\n    fn test_enum_schema_name() {\n        // Invalid name \"0000\" does not match [A-Za-z_][A-Za-z0-9_]*\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Enum\", \"symbols\": [\"0000\", \"variant\"]}\"#,\n        );\n        assert!(schema.is_err());\n    }\n\n    #[test]\n    fn test_fixed_schema() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"fixed\", \"name\": \"test\", \"size\": 16}\"#).unwrap();\n\n        let expected = Schema::Fixed {\n            name: Name::new(\"test\"),\n            size: 16usize,\n        };\n\n        assert_eq!(expected, schema);\n    }\n\n    #[test]\n    fn test_no_documentation() {\n        let schema =\n            Schema::parse_str(r#\"{\"type\": \"enum\", \"name\": \"Coin\", \"symbols\": [\"heads\", \"tails\"]}\"#)\n                .unwrap();\n\n        let doc = match schema {\n            Schema::Enum { doc, .. } => doc,\n            _ => return,\n        };\n\n        assert!(doc.is_none());\n    }\n\n    #[test]\n    fn test_documentation() {\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Coin\", \"doc\": \"Some documentation\", \"symbols\": [\"heads\", \"tails\"]}\"#\n        ).unwrap();\n\n        let doc = match schema {\n            Schema::Enum { doc, .. } => doc,\n            _ => None,\n        };\n\n        assert_eq!(\"Some documentation\".to_owned(), doc.unwrap());\n    }\n\n    // Tests to ensure Schema is Send + Sync. These tests don't need to _do_ anything, if they can\n    // compile, they pass.\n    #[test]\n    fn test_schema_is_send() {\n        fn send<S: Send>(_s: S) {}\n\n        let schema = Schema::Null;\n        send(schema);\n    }\n\n    #[test]\n    fn test_schema_is_sync() {\n        fn sync<S: Sync>(_s: S) {}\n\n        let schema = Schema::Null;\n        sync(&schema);\n        sync(schema);\n    }\n\n    #[test]\n    fn test_schema_fingerprint() {\n        use crate::rabin::Rabin;\n        use md5::Md5;\n        use sha2::Sha256;\n\n        let raw_schema = r#\"\n    {\n        \"type\": \"record\",\n        \"name\": \"test\",\n        \"fields\": [\n            {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n            {\"name\": \"b\", \"type\": \"string\"},\n            {\"name\": \"c\", \"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\n        ]\n    }\n\"#;\n\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        assert_eq!(\n            \"abf662f831715ff78f88545a05a9262af75d6406b54e1a8a174ff1d2b75affc4\",\n            format!(\"{}\", schema.fingerprint::<Sha256>())\n        );\n\n        assert_eq!(\n            \"6e21c350f71b1a34e9efe90970f1bc69\",\n            format!(\"{}\", schema.fingerprint::<Md5>())\n        );\n        assert_eq!(\n            \"28cf0a67d9937bb3\",\n            format!(\"{}\", schema.fingerprint::<Rabin>())\n        )\n    }\n\n    #[test]\n    fn test_logical_types() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"int\", \"logicalType\": \"date\"}\"#).unwrap();\n        assert_eq!(schema, Schema::Date);\n\n        let schema =\n            Schema::parse_str(r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\"#).unwrap();\n        assert_eq!(schema, Schema::TimestampMicros);\n    }\n\n    #[test]\n    fn test_nullable_logical_type() {\n        let schema = Schema::parse_str(\n            r#\"{\"type\": [\"null\", {\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}]}\"#,\n        )\n        .unwrap();\n        assert_eq!(\n            schema,\n            Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::TimestampMicros]).unwrap())\n        );\n    }\n\n    #[test]\n    fn record_field_order_from_str() {\n        use std::str::FromStr;\n\n        assert_eq!(\n            RecordFieldOrder::from_str(\"ascending\").unwrap(),\n            RecordFieldOrder::Ascending\n        );\n        assert_eq!(\n            RecordFieldOrder::from_str(\"descending\").unwrap(),\n            RecordFieldOrder::Descending\n        );\n        assert_eq!(\n            RecordFieldOrder::from_str(\"ignore\").unwrap(),\n            RecordFieldOrder::Ignore\n        );\n        assert!(RecordFieldOrder::from_str(\"not an ordering\").is_err());\n    }\n}\n","traces":[{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":862,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":875,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":892,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":906,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":960,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":139},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","schema_compatibility.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for checking schema compatibility\nuse crate::schema::{Schema, SchemaKind};\nuse std::{\n    collections::{hash_map::DefaultHasher, HashSet},\n    hash::Hasher,\n    ptr,\n};\n\npub struct SchemaCompatibility;\n\nstruct Checker {\n    recursion: HashSet<(u64, u64)>,\n}\n\nimpl Checker {\n    /// Create a new checker, with recursion set to an empty set.\n    pub(crate) fn new() -> Self {\n        Self {\n            recursion: HashSet::new(),\n        }\n    }\n\n    pub(crate) fn can_read(&mut self, writers_schema: &Schema, readers_schema: &Schema) -> bool {\n        self.full_match_schemas(writers_schema, readers_schema)\n    }\n\n    pub(crate) fn full_match_schemas(\n        &mut self,\n        writers_schema: &Schema,\n        readers_schema: &Schema,\n    ) -> bool {\n        if self.recursion_in_progress(writers_schema, readers_schema) {\n            return true;\n        }\n\n        if !SchemaCompatibility::match_schemas(writers_schema, readers_schema) {\n            return false;\n        }\n\n        let w_type = SchemaKind::from(writers_schema);\n        let r_type = SchemaKind::from(readers_schema);\n\n        if w_type != SchemaKind::Union && (r_type.is_primitive() || r_type == SchemaKind::Fixed) {\n            return true;\n        }\n\n        match r_type {\n            SchemaKind::Record => self.match_record_schemas(writers_schema, readers_schema),\n            SchemaKind::Map => {\n                if let Schema::Map(w_m) = writers_schema {\n                    if let Schema::Map(r_m) = readers_schema {\n                        self.full_match_schemas(w_m, r_m)\n                    } else {\n                        unreachable!(\"readers_schema should have been Schema::Map\")\n                    }\n                } else {\n                    unreachable!(\"writers_schema should have been Schema::Map\")\n                }\n            }\n            SchemaKind::Array => {\n                if let Schema::Array(w_a) = writers_schema {\n                    if let Schema::Array(r_a) = readers_schema {\n                        self.full_match_schemas(w_a, r_a)\n                    } else {\n                        unreachable!(\"readers_schema should have been Schema::Array\")\n                    }\n                } else {\n                    unreachable!(\"writers_schema should have been Schema::Array\")\n                }\n            }\n            SchemaKind::Union => self.match_union_schemas(writers_schema, readers_schema),\n            SchemaKind::Enum => {\n                // reader's symbols must contain all writer's symbols\n                if let Schema::Enum {\n                    symbols: w_symbols, ..\n                } = writers_schema\n                {\n                    if let Schema::Enum {\n                        symbols: r_symbols, ..\n                    } = readers_schema\n                    {\n                        return !w_symbols.iter().any(|e| !r_symbols.contains(e));\n                    }\n                }\n                false\n            }\n            _ => {\n                if w_type == SchemaKind::Union {\n                    if let Schema::Union(r) = writers_schema {\n                        if r.schemas.len() == 1 {\n                            return self.full_match_schemas(&r.schemas[0], readers_schema);\n                        }\n                    }\n                }\n                false\n            }\n        }\n    }\n\n    fn match_record_schemas(&mut self, writers_schema: &Schema, readers_schema: &Schema) -> bool {\n        let w_type = SchemaKind::from(writers_schema);\n\n        if w_type == SchemaKind::Union {\n            return false;\n        }\n\n        if let Schema::Record {\n            fields: w_fields,\n            lookup: w_lookup,\n            ..\n        } = writers_schema\n        {\n            if let Schema::Record {\n                fields: r_fields, ..\n            } = readers_schema\n            {\n                for field in r_fields.iter() {\n                    if let Some(pos) = w_lookup.get(&field.name) {\n                        if !self.full_match_schemas(&w_fields[*pos].schema, &field.schema) {\n                            return false;\n                        }\n                    } else if field.default.is_none() {\n                        return false;\n                    }\n                }\n            }\n        }\n        true\n    }\n\n    fn match_union_schemas(&mut self, writers_schema: &Schema, readers_schema: &Schema) -> bool {\n        let w_type = SchemaKind::from(writers_schema);\n        let r_type = SchemaKind::from(readers_schema);\n\n        assert_eq!(r_type, SchemaKind::Union);\n\n        if w_type == SchemaKind::Union {\n            if let Schema::Union(u) = writers_schema {\n                u.schemas\n                    .iter()\n                    .all(|schema| self.full_match_schemas(schema, readers_schema))\n            } else {\n                unreachable!(\"writers_schema should have been Schema::Union\")\n            }\n        } else if let Schema::Union(u) = readers_schema {\n            u.schemas\n                .iter()\n                .any(|schema| self.full_match_schemas(writers_schema, schema))\n        } else {\n            unreachable!(\"readers_schema should have been Schema::Union\")\n        }\n    }\n\n    fn recursion_in_progress(&mut self, writers_schema: &Schema, readers_schema: &Schema) -> bool {\n        let mut hasher = DefaultHasher::new();\n        ptr::hash(writers_schema, &mut hasher);\n        let w_hash = hasher.finish();\n\n        hasher = DefaultHasher::new();\n        ptr::hash(readers_schema, &mut hasher);\n        let r_hash = hasher.finish();\n\n        let key = (w_hash, r_hash);\n        // This is a shortcut to add if not exists *and* return false. It will return true\n        // if it was able to insert.\n        !self.recursion.insert(key)\n    }\n}\n\nimpl SchemaCompatibility {\n    /// `can_read` performs a full, recursive check that a datum written using the\n    /// writers_schema can be read using the readers_schema.\n    pub fn can_read(writers_schema: &Schema, readers_schema: &Schema) -> bool {\n        let mut c = Checker::new();\n        c.can_read(writers_schema, readers_schema)\n    }\n\n    /// `mutual_read` performs a full, recursive check that a datum written using either\n    /// the writers_schema or the readers_schema can be read using the other schema.\n    pub fn mutual_read(writers_schema: &Schema, readers_schema: &Schema) -> bool {\n        SchemaCompatibility::can_read(writers_schema, readers_schema)\n            && SchemaCompatibility::can_read(readers_schema, writers_schema)\n    }\n\n    ///  `match_schemas` performs a basic check that a datum written with the\n    ///  writers_schema could be read using the readers_schema. This check only includes\n    ///  matching the types, including schema promotion, and matching the full name for\n    ///  named types. Aliases for named types are not supported here, and the rust\n    ///  implementation of Avro in general does not include support for aliases (I think).\n    pub(crate) fn match_schemas(writers_schema: &Schema, readers_schema: &Schema) -> bool {\n        let w_type = SchemaKind::from(writers_schema);\n        let r_type = SchemaKind::from(readers_schema);\n\n        if w_type == SchemaKind::Union || r_type == SchemaKind::Union {\n            return true;\n        }\n\n        if w_type == r_type {\n            if r_type.is_primitive() {\n                return true;\n            }\n\n            match r_type {\n                SchemaKind::Record => {\n                    if let Schema::Record { name: w_name, .. } = writers_schema {\n                        if let Schema::Record { name: r_name, .. } = readers_schema {\n                            return w_name.fullname(None) == r_name.fullname(None);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Record\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Record\")\n                    }\n                }\n                SchemaKind::Fixed => {\n                    if let Schema::Fixed {\n                        name: w_name,\n                        size: w_size,\n                    } = writers_schema\n                    {\n                        if let Schema::Fixed {\n                            name: r_name,\n                            size: r_size,\n                        } = readers_schema\n                        {\n                            return w_name.fullname(None) == r_name.fullname(None)\n                                && w_size == r_size;\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Fixed\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Fixed\")\n                    }\n                }\n                SchemaKind::Enum => {\n                    if let Schema::Enum { name: w_name, .. } = writers_schema {\n                        if let Schema::Enum { name: r_name, .. } = readers_schema {\n                            return w_name.fullname(None) == r_name.fullname(None);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Enum\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Enum\")\n                    }\n                }\n                SchemaKind::Map => {\n                    if let Schema::Map(w_m) = writers_schema {\n                        if let Schema::Map(r_m) = readers_schema {\n                            return SchemaCompatibility::match_schemas(w_m, r_m);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Map\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Map\")\n                    }\n                }\n                SchemaKind::Array => {\n                    if let Schema::Array(w_a) = writers_schema {\n                        if let Schema::Array(r_a) = readers_schema {\n                            return SchemaCompatibility::match_schemas(w_a, r_a);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Array\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Array\")\n                    }\n                }\n                _ => (),\n            };\n        }\n\n        if w_type == SchemaKind::Int\n            && vec![SchemaKind::Long, SchemaKind::Float, SchemaKind::Double]\n                .iter()\n                .any(|&t| t == r_type)\n        {\n            return true;\n        }\n\n        if w_type == SchemaKind::Long\n            && vec![SchemaKind::Float, SchemaKind::Double]\n                .iter()\n                .any(|&t| t == r_type)\n        {\n            return true;\n        }\n\n        if w_type == SchemaKind::Float && r_type == SchemaKind::Double {\n            return true;\n        }\n\n        if w_type == SchemaKind::String && r_type == SchemaKind::Bytes {\n            return true;\n        }\n\n        if w_type == SchemaKind::Bytes && r_type == SchemaKind::String {\n            return true;\n        }\n\n        false\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn int_array_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"array\", \"items\":\"int\"}\"#).unwrap()\n    }\n\n    fn long_array_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"array\", \"items\":\"long\"}\"#).unwrap()\n    }\n\n    fn string_array_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"array\", \"items\":\"string\"}\"#).unwrap()\n    }\n\n    fn int_map_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"map\", \"values\":\"int\"}\"#).unwrap()\n    }\n\n    fn long_map_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"map\", \"values\":\"long\"}\"#).unwrap()\n    }\n\n    fn string_map_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"map\", \"values\":\"string\"}\"#).unwrap()\n    }\n\n    fn enum1_ab_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum1\", \"symbols\":[\"A\",\"B\"]}\"#).unwrap()\n    }\n\n    fn enum1_abc_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum1\", \"symbols\":[\"A\",\"B\",\"C\"]}\"#).unwrap()\n    }\n\n    fn enum1_bc_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum1\", \"symbols\":[\"B\",\"C\"]}\"#).unwrap()\n    }\n\n    fn enum2_ab_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum2\", \"symbols\":[\"A\",\"B\"]}\"#).unwrap()\n    }\n\n    fn empty_record1_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[]}\"#).unwrap()\n    }\n\n    fn empty_record2_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record2\", \"fields\": []}\"#).unwrap()\n    }\n\n    fn a_int_record1_schema() -> Schema {\n        Schema::parse_str(\n            r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\"}]}\"#,\n        )\n        .unwrap()\n    }\n\n    fn a_long_record1_schema() -> Schema {\n        Schema::parse_str(\n            r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"long\"}]}\"#,\n        )\n        .unwrap()\n    }\n\n    fn a_int_b_int_record1_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\"}, {\"name\":\"b\", \"type\":\"int\"}]}\"#).unwrap()\n    }\n\n    fn a_dint_record1_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\", \"default\":0}]}\"#).unwrap()\n    }\n\n    fn a_int_b_dint_record1_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\"}, {\"name\":\"b\", \"type\":\"int\", \"default\":0}]}\"#).unwrap()\n    }\n\n    fn a_dint_b_dint_record1_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\", \"default\":0}, {\"name\":\"b\", \"type\":\"int\", \"default\":0}]}\"#).unwrap()\n    }\n\n    fn nested_record() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\",\"name\":\"parent\",\"fields\":[{\"name\":\"attribute\",\"type\":{\"type\":\"record\",\"name\":\"child\",\"fields\":[{\"name\":\"id\",\"type\":\"string\"}]}}]}\"#).unwrap()\n    }\n\n    fn nested_optional_record() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\",\"name\":\"parent\",\"fields\":[{\"name\":\"attribute\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"child\",\"fields\":[{\"name\":\"id\",\"type\":\"string\"}]}],\"default\":null}]}\"#).unwrap()\n    }\n\n    fn int_list_record_schema() -> Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"List\", \"fields\": [{\"name\": \"head\", \"type\": \"int\"},{\"name\": \"tail\", \"type\": \"array\", \"items\": \"int\"}]}\"#).unwrap()\n    }\n\n    fn long_list_record_schema() -> Schema {\n        Schema::parse_str(\n            r#\"\n      {\n        \"type\":\"record\", \"name\":\"List\", \"fields\": [\n          {\"name\": \"head\", \"type\": \"long\"},\n          {\"name\": \"tail\", \"type\": \"array\", \"items\": \"long\"}\n      ]}\n\"#,\n        )\n        .unwrap()\n    }\n\n    fn union_schema(schemas: Vec<Schema>) -> Schema {\n        let schema_string = schemas\n            .iter()\n            .map(|s| s.canonical_form())\n            .collect::<Vec<String>>()\n            .join(\",\");\n        dbg!(&schema_string);\n        Schema::parse_str(&format!(\"[{}]\", schema_string)).unwrap()\n    }\n\n    fn empty_union_schema() -> Schema {\n        union_schema(vec![])\n    }\n\n    // unused\n    // fn null_union_schema() -> Schema { union_schema(vec![Schema::Null]) }\n\n    fn int_union_schema() -> Schema {\n        union_schema(vec![Schema::Int])\n    }\n\n    fn long_union_schema() -> Schema {\n        union_schema(vec![Schema::Long])\n    }\n\n    fn string_union_schema() -> Schema {\n        union_schema(vec![Schema::String])\n    }\n\n    fn int_string_union_schema() -> Schema {\n        union_schema(vec![Schema::Int, Schema::String])\n    }\n\n    fn string_int_union_schema() -> Schema {\n        union_schema(vec![Schema::String, Schema::Int])\n    }\n\n    #[test]\n    fn test_broken() {\n        assert!(!SchemaCompatibility::can_read(\n            &int_string_union_schema(),\n            &int_union_schema()\n        ))\n    }\n\n    #[test]\n    fn test_incompatible_reader_writer_pairs() {\n        let incompatible_schemas = vec![\n            // null\n            (Schema::Null, Schema::Int),\n            (Schema::Null, Schema::Long),\n            // boolean\n            (Schema::Boolean, Schema::Int),\n            // int\n            (Schema::Int, Schema::Null),\n            (Schema::Int, Schema::Boolean),\n            (Schema::Int, Schema::Long),\n            (Schema::Int, Schema::Float),\n            (Schema::Int, Schema::Double),\n            // long\n            (Schema::Long, Schema::Float),\n            (Schema::Long, Schema::Double),\n            // float\n            (Schema::Float, Schema::Double),\n            // string\n            (Schema::String, Schema::Boolean),\n            (Schema::String, Schema::Int),\n            // bytes\n            (Schema::Bytes, Schema::Null),\n            (Schema::Bytes, Schema::Int),\n            // array and maps\n            (int_array_schema(), long_array_schema()),\n            (int_map_schema(), int_array_schema()),\n            (int_array_schema(), int_map_schema()),\n            (int_map_schema(), long_map_schema()),\n            // enum\n            (enum1_ab_schema(), enum1_abc_schema()),\n            (enum1_bc_schema(), enum1_abc_schema()),\n            (enum1_ab_schema(), enum2_ab_schema()),\n            (Schema::Int, enum2_ab_schema()),\n            (enum2_ab_schema(), Schema::Int),\n            //union\n            (int_union_schema(), int_string_union_schema()),\n            (string_union_schema(), int_string_union_schema()),\n            //record\n            (empty_record2_schema(), empty_record1_schema()),\n            (a_int_record1_schema(), empty_record1_schema()),\n            (a_int_b_dint_record1_schema(), empty_record1_schema()),\n            (int_list_record_schema(), long_list_record_schema()),\n            (nested_record(), nested_optional_record()),\n        ];\n\n        assert!(!incompatible_schemas\n            .iter()\n            .any(|(reader, writer)| SchemaCompatibility::can_read(writer, reader)));\n    }\n\n    #[test]\n    fn test_compatible_reader_writer_pairs() {\n        let compatible_schemas = vec![\n            (Schema::Null, Schema::Null),\n            (Schema::Long, Schema::Int),\n            (Schema::Float, Schema::Int),\n            (Schema::Float, Schema::Long),\n            (Schema::Double, Schema::Long),\n            (Schema::Double, Schema::Int),\n            (Schema::Double, Schema::Float),\n            (Schema::String, Schema::Bytes),\n            (Schema::Bytes, Schema::String),\n            (int_array_schema(), int_array_schema()),\n            (long_array_schema(), int_array_schema()),\n            (int_map_schema(), int_map_schema()),\n            (long_map_schema(), int_map_schema()),\n            (enum1_ab_schema(), enum1_ab_schema()),\n            (enum1_abc_schema(), enum1_ab_schema()),\n            (empty_union_schema(), empty_union_schema()),\n            (int_union_schema(), int_union_schema()),\n            (int_string_union_schema(), string_int_union_schema()),\n            (int_union_schema(), empty_union_schema()),\n            (long_union_schema(), int_union_schema()),\n            (int_union_schema(), Schema::Int),\n            (Schema::Int, int_union_schema()),\n            (empty_record1_schema(), empty_record1_schema()),\n            (empty_record1_schema(), a_int_record1_schema()),\n            (a_int_record1_schema(), a_int_record1_schema()),\n            (a_dint_record1_schema(), a_int_record1_schema()),\n            (a_dint_record1_schema(), a_dint_record1_schema()),\n            (a_int_record1_schema(), a_dint_record1_schema()),\n            (a_long_record1_schema(), a_int_record1_schema()),\n            (a_int_record1_schema(), a_int_b_int_record1_schema()),\n            (a_dint_record1_schema(), a_int_b_int_record1_schema()),\n            (a_int_b_dint_record1_schema(), a_int_record1_schema()),\n            (a_dint_b_dint_record1_schema(), empty_record1_schema()),\n            (a_dint_b_dint_record1_schema(), a_int_record1_schema()),\n            (a_int_b_int_record1_schema(), a_dint_b_dint_record1_schema()),\n            (int_list_record_schema(), int_list_record_schema()),\n            (long_list_record_schema(), long_list_record_schema()),\n            (long_list_record_schema(), int_list_record_schema()),\n            (nested_optional_record(), nested_record()),\n        ];\n\n        assert!(compatible_schemas\n            .iter()\n            .all(|(reader, writer)| SchemaCompatibility::can_read(writer, reader)));\n    }\n\n    fn writer_schema() -> Schema {\n        Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n        {\"name\":\"oldfield1\", \"type\":\"int\"},\n        {\"name\":\"oldfield2\", \"type\":\"string\"}\n      ]}\n\"#,\n        )\n        .unwrap()\n    }\n\n    #[test]\n    fn test_missing_field() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n        {\"name\":\"oldfield1\", \"type\":\"int\"}\n      ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            &writer_schema(),\n            &reader_schema,\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            &reader_schema,\n            &writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_missing_second_field() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield2\", \"type\":\"string\"}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            &writer_schema(),\n            &reader_schema\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            &reader_schema,\n            &writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_all_fields() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield1\", \"type\":\"int\"},\n          {\"name\":\"oldfield2\", \"type\":\"string\"}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            &writer_schema(),\n            &reader_schema\n        ));\n        assert!(SchemaCompatibility::can_read(\n            &reader_schema,\n            &writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_new_field_with_default() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield1\", \"type\":\"int\"},\n          {\"name\":\"newfield1\", \"type\":\"int\", \"default\":42}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            &writer_schema(),\n            &reader_schema\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            &reader_schema,\n            &writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_new_field() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield1\", \"type\":\"int\"},\n          {\"name\":\"newfield1\", \"type\":\"int\"}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(!SchemaCompatibility::can_read(\n            &writer_schema(),\n            &reader_schema\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            &reader_schema,\n            &writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_array_writer_schema() {\n        let valid_reader = string_array_schema();\n        let invalid_reader = string_map_schema();\n\n        assert!(SchemaCompatibility::can_read(\n            &string_array_schema(),\n            &valid_reader\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            &string_array_schema(),\n            &invalid_reader\n        ));\n    }\n\n    #[test]\n    fn test_primitive_writer_schema() {\n        let valid_reader = Schema::String;\n        assert!(SchemaCompatibility::can_read(\n            &Schema::String,\n            &valid_reader\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            &Schema::Int,\n            &Schema::String\n        ));\n    }\n\n    #[test]\n    fn test_union_reader_writer_subset_incompatiblity() {\n        // reader union schema must contain all writer union branches\n        let union_writer = union_schema(vec![Schema::Int, Schema::String]);\n        let union_reader = union_schema(vec![Schema::String]);\n\n        assert!(!SchemaCompatibility::can_read(&union_writer, &union_reader));\n        assert!(SchemaCompatibility::can_read(&union_reader, &union_writer));\n    }\n\n    #[test]\n    fn test_incompatible_record_field() {\n        let string_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"MyRecord\", \"namespace\":\"ns\", \"fields\": [\n            {\"name\":\"field1\", \"type\":\"string\"}\n        ]}\n        \"#,\n        )\n        .unwrap();\n\n        let int_schema = Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"MyRecord\", \"namespace\":\"ns\", \"fields\": [\n        {\"name\":\"field1\", \"type\":\"int\"}\n      ]}\n\"#,\n        )\n        .unwrap();\n\n        assert!(!SchemaCompatibility::can_read(&string_schema, &int_schema));\n    }\n\n    #[test]\n    fn test_enum_symbols() {\n        let enum_schema1 = Schema::parse_str(\n            r#\"\n      {\"type\":\"enum\", \"name\":\"MyEnum\", \"symbols\":[\"A\",\"B\"]}\n\"#,\n        )\n        .unwrap();\n        let enum_schema2 =\n            Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"MyEnum\", \"symbols\":[\"A\",\"B\",\"C\"]}\"#)\n                .unwrap();\n        assert!(!SchemaCompatibility::can_read(&enum_schema2, &enum_schema1));\n        assert!(SchemaCompatibility::can_read(&enum_schema1, &enum_schema2));\n    }\n\n    // unused\n    /*\n        fn point_2d_schema() -> Schema {\n            Schema::parse_str(\n                r#\"\n          {\"type\":\"record\", \"name\":\"Point2D\", \"fields\":[\n            {\"name\":\"x\", \"type\":\"double\"},\n            {\"name\":\"y\", \"type\":\"double\"}\n          ]}\n        \"#,\n            )\n            .unwrap()\n        }\n    */\n\n    fn point_2d_fullname_schema() -> Schema {\n        Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Point\", \"namespace\":\"written\", \"fields\":[\n        {\"name\":\"x\", \"type\":\"double\"},\n        {\"name\":\"y\", \"type\":\"double\"}\n      ]}\n    \"#,\n        )\n        .unwrap()\n    }\n\n    fn point_3d_no_default_schema() -> Schema {\n        Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Point\", \"fields\":[\n        {\"name\":\"x\", \"type\":\"double\"},\n        {\"name\":\"y\", \"type\":\"double\"},\n        {\"name\":\"z\", \"type\":\"double\"}\n      ]}\n    \"#,\n        )\n        .unwrap()\n    }\n\n    // unused\n    /*\n        fn point_3d_schema() -> Schema {\n            Schema::parse_str(\n                r#\"\n          {\"type\":\"record\", \"name\":\"Point3D\", \"fields\":[\n            {\"name\":\"x\", \"type\":\"double\"},\n            {\"name\":\"y\", \"type\":\"double\"},\n            {\"name\":\"z\", \"type\":\"double\", \"default\": 0.0}\n          ]}\n        \"#,\n            )\n            .unwrap()\n        }\n\n        fn point_3d_match_name_schema() -> Schema {\n            Schema::parse_str(\n                r#\"\n          {\"type\":\"record\", \"name\":\"Point\", \"fields\":[\n            {\"name\":\"x\", \"type\":\"double\"},\n            {\"name\":\"y\", \"type\":\"double\"},\n            {\"name\":\"z\", \"type\":\"double\", \"default\": 0.0}\n          ]}\n        \"#,\n            )\n            .unwrap()\n        }\n    */\n\n    #[test]\n    fn test_union_resolution_no_structure_match() {\n        // short name match, but no structure match\n        let read_schema = union_schema(vec![Schema::Null, point_3d_no_default_schema()]);\n        assert!(!SchemaCompatibility::can_read(\n            &point_2d_fullname_schema(),\n            &read_schema\n        ));\n    }\n\n    // TODO(nlopes): the below require named schemas to be fully supported. See:\n    // https://github.com/flavray/avro-rs/pull/76\n    //\n    // #[test]\n    // fn test_union_resolution_first_structure_match_2d() {\n    //     // multiple structure matches with no name matches\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_3d_no_default_schema(),\n    //         point_2d_schema(),\n    //         point_3d_schema(),\n    //     ]);\n    //     assert!(\n    //         !SchemaCompatibility::can_read(&point_2d_fullname_schema(), &read_schema)\n    //     );\n    // }\n\n    // #[test]\n    // fn test_union_resolution_first_structure_match_3d() {\n    //     // multiple structure matches with no name matches\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_3d_no_default_schema(),\n    //         point_3d_schema(),\n    //         point_2d_schema(),\n    //     ]);\n    //     assert!(\n    //         !SchemaCompatibility::can_read(&point_2d_fullname_schema(), &read_schema)\n    //     );\n    // }\n\n    // #[test]\n    // fn test_union_resolution_named_structure_match() {\n    //     // multiple structure matches with a short name match\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_2d_schema(),\n    //         point_3d_match_name_schema(),\n    //         point_3d_schema(),\n    //     ]);\n    //     assert!(\n    //         !SchemaCompatibility::can_read(&point_2d_fullname_schema(), &read_schema)\n    //     );\n    // }\n\n    // #[test]\n    // fn test_union_resolution_full_name_match() {\n    //     // there is a full name match that should be chosen\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_2d_schema(),\n    //         point_3d_match_name_schema(),\n    //         point_3d_schema(),\n    //         point_2d_fullname_schema(),\n    //     ]);\n    //     assert!(SchemaCompatibility::can_read(\n    //         &point_2d_fullname_schema(),\n    //         &read_schema\n    //     ));\n    // }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","ser.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for serde-compatible serialization.\nuse crate::{types::Value, Error};\nuse serde::{ser, Serialize};\nuse std::{collections::HashMap, iter::once};\n\n#[derive(Clone, Default)]\npub struct Serializer {}\n\npub struct SeqSerializer {\n    items: Vec<Value>,\n}\n\npub struct SeqVariantSerializer<'a> {\n    index: u32,\n    variant: &'a str,\n    items: Vec<Value>,\n}\n\npub struct MapSerializer {\n    indices: HashMap<String, usize>,\n    values: Vec<Value>,\n}\n\npub struct StructSerializer {\n    fields: Vec<(String, Value)>,\n}\n\npub struct StructVariantSerializer<'a> {\n    index: u32,\n    variant: &'a str,\n    fields: Vec<(String, Value)>,\n}\n\nimpl SeqSerializer {\n    pub fn new(len: Option<usize>) -> SeqSerializer {\n        let items = match len {\n            Some(len) => Vec::with_capacity(len),\n            None => Vec::new(),\n        };\n\n        SeqSerializer { items }\n    }\n}\n\nimpl<'a> SeqVariantSerializer<'a> {\n    pub fn new(index: u32, variant: &'a str, len: Option<usize>) -> SeqVariantSerializer {\n        let items = match len {\n            Some(len) => Vec::with_capacity(len),\n            None => Vec::new(),\n        };\n        SeqVariantSerializer {\n            index,\n            variant,\n            items,\n        }\n    }\n}\n\nimpl MapSerializer {\n    pub fn new(len: Option<usize>) -> MapSerializer {\n        let (indices, values) = match len {\n            Some(len) => (HashMap::with_capacity(len), Vec::with_capacity(len)),\n            None => (HashMap::new(), Vec::new()),\n        };\n\n        MapSerializer { indices, values }\n    }\n}\n\nimpl StructSerializer {\n    pub fn new(len: usize) -> StructSerializer {\n        StructSerializer {\n            fields: Vec::with_capacity(len),\n        }\n    }\n}\n\nimpl<'a> StructVariantSerializer<'a> {\n    pub fn new(index: u32, variant: &'a str, len: usize) -> StructVariantSerializer {\n        StructVariantSerializer {\n            index,\n            variant,\n            fields: Vec::with_capacity(len),\n        }\n    }\n}\n\nimpl<'b> ser::Serializer for &'b mut Serializer {\n    type Ok = Value;\n    type Error = Error;\n    type SerializeSeq = SeqSerializer;\n    type SerializeTuple = SeqSerializer;\n    type SerializeTupleStruct = SeqSerializer;\n    type SerializeTupleVariant = SeqVariantSerializer<'b>;\n    type SerializeMap = MapSerializer;\n    type SerializeStruct = StructSerializer;\n    type SerializeStructVariant = StructVariantSerializer<'b>;\n\n    fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Boolean(v))\n    }\n\n    fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error> {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error> {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Int(v))\n    }\n\n    fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Long(v))\n    }\n\n    fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error> {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error> {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error> {\n        if v <= i32::max_value() as u32 {\n            self.serialize_i32(v as i32)\n        } else {\n            self.serialize_i64(i64::from(v))\n        }\n    }\n\n    fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error> {\n        if v <= i64::max_value() as u64 {\n            self.serialize_i64(v as i64)\n        } else {\n            Err(ser::Error::custom(\"u64 is too large\"))\n        }\n    }\n\n    fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Float(v))\n    }\n\n    fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Double(v))\n    }\n\n    fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error> {\n        self.serialize_str(&once(v).collect::<String>())\n    }\n\n    fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::String(v.to_owned()))\n    }\n\n    fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Bytes(v.to_owned()))\n    }\n\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::from(None::<Self::Ok>))\n    }\n\n    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize,\n    {\n        let v = value.serialize(&mut Serializer::default())?;\n        Ok(Value::from(Some(v)))\n    }\n\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Null)\n    }\n\n    fn serialize_unit_struct(self, _: &'static str) -> Result<Self::Ok, Self::Error> {\n        self.serialize_unit()\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: &'static str,\n        index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Enum(index as i32, variant.to_string()))\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _: &'static str,\n        index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize,\n    {\n        Ok(Value::Record(vec![\n            (\n                \"type\".to_owned(),\n                Value::Enum(index as i32, variant.to_owned()),\n            ),\n            (\n                \"value\".to_owned(),\n                Value::Union(Box::new(value.serialize(self)?)),\n            ),\n        ]))\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        Ok(SeqSerializer::new(len))\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _: &'static str,\n        index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        Ok(SeqVariantSerializer::new(index, variant, Some(len)))\n    }\n\n    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n        Ok(MapSerializer::new(len))\n    }\n\n    fn serialize_struct(\n        self,\n        _: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        Ok(StructSerializer::new(len))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _: &'static str,\n        index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        Ok(StructVariantSerializer::new(index, variant, len))\n    }\n}\n\nimpl<'a> ser::SerializeSeq for SeqSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        self.items\n            .push(value.serialize(&mut Serializer::default())?);\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Array(self.items))\n    }\n}\n\nimpl<'a> ser::SerializeTuple for SeqSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl ser::SerializeTupleStruct for SeqSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl<'a> ser::SerializeSeq for SeqVariantSerializer<'a> {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        self.items.push(Value::Union(Box::new(\n            value.serialize(&mut Serializer::default())?,\n        )));\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Record(vec![\n            (\n                \"type\".to_owned(),\n                Value::Enum(self.index as i32, self.variant.to_owned()),\n            ),\n            (\"value\".to_owned(), Value::Array(self.items)),\n        ]))\n    }\n}\n\nimpl<'a> ser::SerializeTupleVariant for SeqVariantSerializer<'a> {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl ser::SerializeMap for MapSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        let key = key.serialize(&mut Serializer::default())?;\n\n        if let Value::String(key) = key {\n            self.indices.insert(key, self.values.len());\n            Ok(())\n        } else {\n            Err(ser::Error::custom(\"map key is not a string\"))\n        }\n    }\n\n    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        self.values\n            .push(value.serialize(&mut Serializer::default())?);\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        let mut items = HashMap::new();\n        for (key, index) in self.indices {\n            if let Some(value) = self.values.get(index) {\n                items.insert(key, value.clone());\n            }\n        }\n\n        Ok(Value::Map(items))\n    }\n}\n\nimpl ser::SerializeStruct for StructSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        name: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        self.fields.push((\n            name.to_owned(),\n            value.serialize(&mut Serializer::default())?,\n        ));\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Record(self.fields))\n    }\n}\n\nimpl<'a> ser::SerializeStructVariant for StructVariantSerializer<'a> {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        name: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        self.fields.push((\n            name.to_owned(),\n            value.serialize(&mut Serializer::default())?,\n        ));\n        Ok(())\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        Ok(Value::Record(vec![\n            (\n                \"type\".to_owned(),\n                Value::Enum(self.index as i32, self.variant.to_owned()),\n            ),\n            (\n                \"value\".to_owned(),\n                Value::Union(Box::new(Value::Record(self.fields))),\n            ),\n        ]))\n    }\n}\n\n/// Interpret a serializeable instance as a `Value`.\n///\n/// This conversion can fail if the value is not valid as per the Avro specification.\n/// e.g: HashMap with non-string keys\npub fn to_value<S: Serialize>(value: S) -> Result<Value, Error> {\n    let mut serializer = Serializer::default();\n    value.serialize(&mut serializer)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Debug, Deserialize, Serialize, Clone)]\n    struct Test {\n        a: i64,\n        b: String,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestInner {\n        a: Test,\n        b: i32,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitExternalEnum {\n        a: UnitExternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    enum UnitExternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitInternalEnum {\n        a: UnitInternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    #[serde(tag = \"t\")]\n    enum UnitInternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitAdjacentEnum {\n        a: UnitAdjacentEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum UnitAdjacentEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitUntaggedEnum {\n        a: UnitUntaggedEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    enum UnitUntaggedEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueExternalEnum {\n        a: SingleValueExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    enum SingleValueExternalEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueInternalEnum {\n        a: SingleValueInternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\")]\n    enum SingleValueInternalEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueAdjacentEnum {\n        a: SingleValueAdjacentEnum,\n    }\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum SingleValueAdjacentEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueUntaggedEnum {\n        a: SingleValueUntaggedEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum SingleValueUntaggedEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructExternalEnum {\n        a: StructExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    enum StructExternalEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructInternalEnum {\n        a: StructInternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum StructInternalEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructAdjacentEnum {\n        a: StructAdjacentEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum StructAdjacentEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructUntaggedEnum {\n        a: StructUntaggedEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum StructUntaggedEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32, z: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestTupleExternalEnum {\n        a: TupleExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    enum TupleExternalEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    // Tuple Internal Enum cannot be instantiated\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestTupleAdjacentEnum {\n        a: TupleAdjacentEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum TupleAdjacentEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestTupleUntaggedEnum {\n        a: TupleUntaggedEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum TupleUntaggedEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    #[test]\n    fn test_to_value() {\n        let test = Test {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n        let expected = Value::Record(vec![\n            (\"a\".to_owned(), Value::Long(27)),\n            (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n        ]);\n\n        assert_eq!(to_value(test.clone()).unwrap(), expected);\n\n        let test_inner = TestInner { a: test, b: 35 };\n\n        let expected_inner = Value::Record(vec![\n            (\n                \"a\".to_owned(),\n                Value::Record(vec![\n                    (\"a\".to_owned(), Value::Long(27)),\n                    (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n                ]),\n            ),\n            (\"b\".to_owned(), Value::Int(35)),\n        ]);\n\n        assert_eq!(to_value(test_inner).unwrap(), expected_inner);\n    }\n\n    #[test]\n    fn test_to_value_unit_enum() {\n        let test = TestUnitExternalEnum {\n            a: UnitExternalEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\"a\".to_owned(), Value::Enum(0, \"Val1\".to_owned()))]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit external enum\"\n        );\n\n        let test = TestUnitInternalEnum {\n            a: UnitInternalEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit internal enum\"\n        );\n\n        let test = TestUnitAdjacentEnum {\n            a: UnitAdjacentEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit adjacent enum\"\n        );\n\n        let test = TestUnitUntaggedEnum {\n            a: UnitUntaggedEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\"a\".to_owned(), Value::Null)]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit untagged enum\"\n        );\n    }\n\n    #[test]\n    fn test_to_value_single_value_enum() {\n        let test = TestSingleValueExternalEnum {\n            a: SingleValueExternalEnum::Double(64.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::Enum(0, \"Double\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Double(64.0))),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing single value external enum\"\n        );\n\n        // It is not possible to serialize an internal Single Value enum...\n        let test = TestSingleValueInternalEnum {\n            a: SingleValueInternalEnum::Double(64.0),\n        };\n\n        assert!(to_value(test).is_err(), \"{}\", true);\n\n        let test = TestSingleValueAdjacentEnum {\n            a: SingleValueAdjacentEnum::Double(64.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"t\".to_owned(), Value::String(\"Double\".to_owned())),\n                (\"v\".to_owned(), Value::Double(64.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing single value adjacent enum\"\n        );\n\n        let test = TestSingleValueUntaggedEnum {\n            a: SingleValueUntaggedEnum::Double(64.0),\n        };\n\n        let expected = Value::Record(vec![(\"a\".to_owned(), Value::Double(64.0))]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing single value untagged enum\"\n        );\n    }\n\n    #[test]\n    fn test_to_value_struct_enum() {\n        let test = TestStructExternalEnum {\n            a: StructExternalEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::Enum(0, \"Val1\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Record(vec![\n                        (\"x\".to_owned(), Value::Float(1.0)),\n                        (\"y\".to_owned(), Value::Float(2.0)),\n                    ]))),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct external enum\"\n        );\n\n        // I don't think that this is feasible in avro\n\n        let test = TestStructInternalEnum {\n            a: StructInternalEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\"x\".to_owned(), Value::Float(1.0)),\n                (\"y\".to_owned(), Value::Float(2.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct internal enum\"\n        );\n\n        let test = TestStructAdjacentEnum {\n            a: StructAdjacentEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"t\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"v\".to_owned(),\n                    Value::Record(vec![\n                        (\"x\".to_owned(), Value::Float(1.0)),\n                        (\"y\".to_owned(), Value::Float(2.0)),\n                    ]),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct adjacent enum\"\n        );\n\n        let test = TestStructUntaggedEnum {\n            a: StructUntaggedEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"x\".to_owned(), Value::Float(1.0)),\n                (\"y\".to_owned(), Value::Float(2.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct untagged enum\"\n        );\n\n        let test = TestStructUntaggedEnum {\n            a: StructUntaggedEnum::Val2 {\n                x: 1.0,\n                y: 2.0,\n                z: 3.0,\n            },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"x\".to_owned(), Value::Float(1.0)),\n                (\"y\".to_owned(), Value::Float(2.0)),\n                (\"z\".to_owned(), Value::Float(3.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct untagged enum variant\"\n        );\n    }\n\n    #[test]\n    fn test_to_value_tuple_enum() {\n        let test = TestTupleExternalEnum {\n            a: TupleExternalEnum::Val2(1.0, 2.0, 3.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::Enum(1, \"Val2\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Array(vec![\n                        Value::Union(Box::new(Value::Float(1.0))),\n                        Value::Union(Box::new(Value::Float(2.0))),\n                        Value::Union(Box::new(Value::Float(3.0))),\n                    ]),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing tuple external enum\"\n        );\n\n        let test = TestTupleAdjacentEnum {\n            a: TupleAdjacentEnum::Val1(1.0, 2.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"t\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"v\".to_owned(),\n                    Value::Array(vec![Value::Float(1.0), Value::Float(2.0)]),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing tuple adjacent enum\"\n        );\n\n        let test = TestTupleUntaggedEnum {\n            a: TupleUntaggedEnum::Val1(1.0, 2.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Array(vec![Value::Float(1.0), Value::Float(2.0)]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing tuple untagged enum\"\n        );\n    }\n}\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":108},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","types.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic handling the intermediate representation of Avro values.\nuse crate::{\n    decimal::Decimal,\n    duration::Duration,\n    schema::{Precision, RecordField, Scale, Schema, SchemaKind, UnionSchema},\n    AvroResult, Error,\n};\nuse serde_json::{Number, Value as JsonValue};\nuse std::{collections::HashMap, convert::TryFrom, hash::BuildHasher, str::FromStr, u8};\nuse uuid::Uuid;\n\n/// Compute the maximum decimal value precision of a byte array of length `len` could hold.\nfn max_prec_for_len(len: usize) -> Result<usize, Error> {\n    let len = i32::try_from(len).map_err(|e| Error::ConvertLengthToI32(e, len))?;\n    Ok((2.0_f64.powi(8 * len - 1) - 1.0).log10().floor() as usize)\n}\n\n/// A valid Avro value.\n///\n/// More information about Avro values can be found in the [Avro\n/// Specification](https://avro.apache.org/docs/current/spec.html#schemas)\n#[derive(Clone, Debug, PartialEq, strum_macros::EnumDiscriminants)]\n#[strum_discriminants(name(ValueKind))]\npub enum Value {\n    /// A `null` Avro value.\n    Null,\n    /// A `boolean` Avro value.\n    Boolean(bool),\n    /// A `int` Avro value.\n    Int(i32),\n    /// A `long` Avro value.\n    Long(i64),\n    /// A `float` Avro value.\n    Float(f32),\n    /// A `double` Avro value.\n    Double(f64),\n    /// A `bytes` Avro value.\n    Bytes(Vec<u8>),\n    /// A `string` Avro value.\n    String(String),\n    /// A `fixed` Avro value.\n    /// The size of the fixed value is represented as a `usize`.\n    Fixed(usize, Vec<u8>),\n    /// An `enum` Avro value.\n    ///\n    /// An Enum is represented by a symbol and its position in the symbols list\n    /// of its corresponding schema.\n    /// This allows schema-less encoding, as well as schema resolution while\n    /// reading values.\n    Enum(i32, String),\n    /// An `union` Avro value.\n    Union(Box<Value>),\n    /// An `array` Avro value.\n    Array(Vec<Value>),\n    /// A `map` Avro value.\n    Map(HashMap<String, Value>),\n    /// A `record` Avro value.\n    ///\n    /// A Record is represented by a vector of (`<record name>`, `value`).\n    /// This allows schema-less encoding.\n    ///\n    /// See [Record](types.Record) for a more user-friendly support.\n    Record(Vec<(String, Value)>),\n    /// A date value.\n    ///\n    /// Serialized and deserialized as `i32` directly. Can only be deserialized properly with a\n    /// schema.\n    Date(i32),\n    /// An Avro Decimal value. Bytes are in big-endian order, per the Avro spec.\n    Decimal(Decimal),\n    /// Time in milliseconds.\n    TimeMillis(i32),\n    /// Time in microseconds.\n    TimeMicros(i64),\n    /// Timestamp in milliseconds.\n    TimestampMillis(i64),\n    /// Timestamp in microseconds.\n    TimestampMicros(i64),\n    /// Avro Duration. An amount of time defined by months, days and milliseconds.\n    Duration(Duration),\n    /// Universally unique identifier.\n    /// Universally unique identifier.\n    Uuid(Uuid),\n}\n/// Any structure implementing the [ToAvro](trait.ToAvro.html) trait will be usable\n/// from a [Writer](../writer/struct.Writer.html).\n#[deprecated(\n    since = \"0.11.0\",\n    note = \"Please use Value::from, Into::into or value.into() instead\"\n)]\npub trait ToAvro {\n    /// Transforms this value into an Avro-compatible [Value](enum.Value.html).\n    fn avro(self) -> Value;\n}\n\n#[allow(deprecated)]\nimpl<T: Into<Value>> ToAvro for T {\n    fn avro(self) -> Value {\n        self.into()\n    }\n}\n\nmacro_rules! to_value(\n    ($type:ty, $variant_constructor:expr) => (\n        impl From<$type> for Value {\n            fn from(value: $type) -> Self {\n                $variant_constructor(value)\n            }\n        }\n    );\n);\n\nto_value!(bool, Value::Boolean);\nto_value!(i32, Value::Int);\nto_value!(i64, Value::Long);\nto_value!(f32, Value::Float);\nto_value!(f64, Value::Double);\nto_value!(String, Value::String);\nto_value!(Vec<u8>, Value::Bytes);\nto_value!(uuid::Uuid, Value::Uuid);\nto_value!(Decimal, Value::Decimal);\nto_value!(Duration, Value::Duration);\n\nimpl From<()> for Value {\n    fn from(_: ()) -> Self {\n        Self::Null\n    }\n}\n\nimpl From<usize> for Value {\n    fn from(value: usize) -> Self {\n        i64::try_from(value)\n            .expect(\"cannot convert usize to i64\")\n            .into()\n    }\n}\n\nimpl From<&str> for Value {\n    fn from(value: &str) -> Self {\n        Self::String(value.to_owned())\n    }\n}\n\nimpl From<&[u8]> for Value {\n    fn from(value: &[u8]) -> Self {\n        Self::Bytes(value.to_owned())\n    }\n}\n\nimpl<T> From<Option<T>> for Value\nwhere\n    T: Into<Self>,\n{\n    fn from(value: Option<T>) -> Self {\n        Self::Union(Box::new(value.map_or_else(|| Self::Null, Into::into)))\n    }\n}\n\nimpl<K, V, S> From<HashMap<K, V, S>> for Value\nwhere\n    K: Into<String>,\n    V: Into<Self>,\n    S: BuildHasher,\n{\n    fn from(value: HashMap<K, V, S>) -> Self {\n        Self::Map(\n            value\n                .into_iter()\n                .map(|(key, value)| (key.into(), value.into()))\n                .collect(),\n        )\n    }\n}\n\n/// Utility interface to build `Value::Record` objects.\n#[derive(Debug, Clone)]\npub struct Record<'a> {\n    /// List of fields contained in the record.\n    /// Ordered according to the fields in the schema given to create this\n    /// `Record` object. Any unset field defaults to `Value::Null`.\n    pub fields: Vec<(String, Value)>,\n    schema_lookup: &'a HashMap<String, usize>,\n}\n\nimpl<'a> Record<'a> {\n    /// Create a `Record` given a `Schema`.\n    ///\n    /// If the `Schema` is not a `Schema::Record` variant, `None` will be returned.\n    pub fn new(schema: &Schema) -> Option<Record> {\n        match *schema {\n            Schema::Record {\n                fields: ref schema_fields,\n                lookup: ref schema_lookup,\n                ..\n            } => {\n                let mut fields = Vec::with_capacity(schema_fields.len());\n                for schema_field in schema_fields.iter() {\n                    fields.push((schema_field.name.clone(), Value::Null));\n                }\n\n                Some(Record {\n                    fields,\n                    schema_lookup,\n                })\n            }\n            _ => None,\n        }\n    }\n\n    /// Put a compatible value (implementing the `ToAvro` trait) in the\n    /// `Record` for a given `field` name.\n    ///\n    /// **NOTE** Only ensure that the field name is present in the `Schema` given when creating\n    /// this `Record`. Does not perform any schema validation.\n    pub fn put<V>(&mut self, field: &str, value: V)\n    where\n        V: Into<Value>,\n    {\n        if let Some(&position) = self.schema_lookup.get(field) {\n            self.fields[position].1 = value.into()\n        }\n    }\n}\n\nimpl<'a> From<Record<'a>> for Value {\n    fn from(value: Record<'a>) -> Self {\n        Self::Record(value.fields)\n    }\n}\n\nimpl From<JsonValue> for Value {\n    fn from(value: JsonValue) -> Self {\n        match value {\n            JsonValue::Null => Self::Null,\n            JsonValue::Bool(b) => b.into(),\n            JsonValue::Number(ref n) if n.is_i64() => Value::Long(n.as_i64().unwrap()),\n            JsonValue::Number(ref n) if n.is_f64() => Value::Double(n.as_f64().unwrap()),\n            JsonValue::Number(n) => Value::Long(n.as_u64().unwrap() as i64), // TODO: Not so great\n            JsonValue::String(s) => s.into(),\n            JsonValue::Array(items) => Value::Array(items.into_iter().map(Value::from).collect()),\n            JsonValue::Object(items) => Value::Map(\n                items\n                    .into_iter()\n                    .map(|(key, value)| (key, value.into()))\n                    .collect(),\n            ),\n        }\n    }\n}\n\n/// Convert Avro values to Json values\nimpl std::convert::TryFrom<Value> for JsonValue {\n    type Error = crate::error::Error;\n    fn try_from(value: Value) -> AvroResult<Self> {\n        match value {\n            Value::Null => Ok(Self::Null),\n            Value::Boolean(b) => Ok(Self::Bool(b)),\n            Value::Int(i) => Ok(Self::Number(i.into())),\n            Value::Long(l) => Ok(Self::Number(l.into())),\n            Value::Float(f) => Number::from_f64(f.into())\n                .map(Self::Number)\n                .ok_or_else(|| Error::ConvertF64ToJson(f.into())),\n            Value::Double(d) => Number::from_f64(d)\n                .map(Self::Number)\n                .ok_or(Error::ConvertF64ToJson(d)),\n            Value::Bytes(bytes) => Ok(Self::Array(bytes.into_iter().map(|b| b.into()).collect())),\n            Value::String(s) => Ok(Self::String(s)),\n            Value::Fixed(_size, items) => {\n                Ok(Self::Array(items.into_iter().map(|v| v.into()).collect()))\n            }\n            Value::Enum(_i, s) => Ok(Self::String(s)),\n            Value::Union(b) => Self::try_from(*b),\n            Value::Array(items) => items\n                .into_iter()\n                .map(Self::try_from)\n                .collect::<Result<Vec<_>, _>>()\n                .map(Self::Array),\n            Value::Map(items) => items\n                .into_iter()\n                .map(|(key, value)| Self::try_from(value).map(|v| (key, v)))\n                .collect::<Result<Vec<_>, _>>()\n                .map(|v| Self::Object(v.into_iter().collect())),\n            Value::Record(items) => items\n                .into_iter()\n                .map(|(key, value)| Self::try_from(value).map(|v| (key, v)))\n                .collect::<Result<Vec<_>, _>>()\n                .map(|v| Self::Object(v.into_iter().collect())),\n            Value::Date(d) => Ok(Self::Number(d.into())),\n            Value::Decimal(ref d) => <Vec<u8>>::try_from(d)\n                .map(|vec| Self::Array(vec.into_iter().map(|v| v.into()).collect())),\n            Value::TimeMillis(t) => Ok(Self::Number(t.into())),\n            Value::TimeMicros(t) => Ok(Self::Number(t.into())),\n            Value::TimestampMillis(t) => Ok(Self::Number(t.into())),\n            Value::TimestampMicros(t) => Ok(Self::Number(t.into())),\n            Value::Duration(d) => Ok(Self::Array(\n                <[u8; 12]>::from(d).iter().map(|&v| v.into()).collect(),\n            )),\n            Value::Uuid(uuid) => Ok(Self::String(uuid.to_hyphenated().to_string())),\n        }\n    }\n}\n\nimpl Value {\n    /// Validate the value against the given [Schema](../schema/enum.Schema.html).\n    ///\n    /// See the [Avro specification](https://avro.apache.org/docs/current/spec.html)\n    /// for the full set of rules of schema validation.\n    pub fn validate(&self, schema: &Schema) -> bool {\n        match (self, schema) {\n            (&Value::Null, &Schema::Null) => true,\n            (&Value::Boolean(_), &Schema::Boolean) => true,\n            (&Value::Int(_), &Schema::Int) => true,\n            (&Value::Int(_), &Schema::Date) => true,\n            (&Value::Int(_), &Schema::TimeMillis) => true,\n            (&Value::Long(_), &Schema::Long) => true,\n            (&Value::Long(_), &Schema::TimeMicros) => true,\n            (&Value::Long(_), &Schema::TimestampMillis) => true,\n            (&Value::Long(_), &Schema::TimestampMicros) => true,\n            (&Value::TimestampMicros(_), &Schema::TimestampMicros) => true,\n            (&Value::TimestampMillis(_), &Schema::TimestampMillis) => true,\n            (&Value::TimeMicros(_), &Schema::TimeMicros) => true,\n            (&Value::TimeMillis(_), &Schema::TimeMillis) => true,\n            (&Value::Date(_), &Schema::Date) => true,\n            (&Value::Decimal(_), &Schema::Decimal { .. }) => true,\n            (&Value::Duration(_), &Schema::Duration) => true,\n            (&Value::Uuid(_), &Schema::Uuid) => true,\n            (&Value::Float(_), &Schema::Float) => true,\n            (&Value::Double(_), &Schema::Double) => true,\n            (&Value::Bytes(_), &Schema::Bytes) => true,\n            (&Value::Bytes(_), &Schema::Decimal { .. }) => true,\n            (&Value::String(_), &Schema::String) => true,\n            (&Value::String(_), &Schema::Uuid) => true,\n            (&Value::Fixed(n, _), &Schema::Fixed { size, .. }) => n == size,\n            (&Value::Bytes(ref b), &Schema::Fixed { size, .. }) => b.len() == size,\n            (&Value::Fixed(n, _), &Schema::Duration) => n == 12,\n            // TODO: check precision against n\n            (&Value::Fixed(_n, _), &Schema::Decimal { .. }) => true,\n            (&Value::String(ref s), &Schema::Enum { ref symbols, .. }) => symbols.contains(s),\n            (&Value::Enum(i, ref s), &Schema::Enum { ref symbols, .. }) => symbols\n                .get(i as usize)\n                .map(|ref symbol| symbol == &s)\n                .unwrap_or(false),\n            // (&Value::Union(None), &Schema::Union(_)) => true,\n            (&Value::Union(ref value), &Schema::Union(ref inner)) => {\n                inner.find_schema(value).is_some()\n            }\n            (&Value::Array(ref items), &Schema::Array(ref inner)) => {\n                items.iter().all(|item| item.validate(inner))\n            }\n            (&Value::Map(ref items), &Schema::Map(ref inner)) => {\n                items.iter().all(|(_, value)| value.validate(inner))\n            }\n            (&Value::Record(ref record_fields), &Schema::Record { ref fields, .. }) => {\n                fields.len() == record_fields.len()\n                    && fields.iter().zip(record_fields.iter()).all(\n                        |(field, &(ref name, ref value))| {\n                            field.name == *name && value.validate(&field.schema)\n                        },\n                    )\n            }\n            (&Value::Map(ref items), &Schema::Record { ref fields, .. }) => {\n                fields.iter().all(|field| {\n                    if let Some(item) = items.get(&field.name) {\n                        item.validate(&field.schema)\n                    } else {\n                        false\n                    }\n                })\n            }\n            _ => false,\n        }\n    }\n\n    /// Attempt to perform schema resolution on the value, with the given\n    /// [Schema](../schema/enum.Schema.html).\n    ///\n    /// See [Schema Resolution](https://avro.apache.org/docs/current/spec.html#Schema+Resolution)\n    /// in the Avro specification for the full set of rules of schema\n    /// resolution.\n    pub fn resolve(mut self, schema: &Schema) -> AvroResult<Self> {\n        // Check if this schema is a union, and if the reader schema is not.\n        if SchemaKind::from(&self) == SchemaKind::Union\n            && SchemaKind::from(schema) != SchemaKind::Union\n        {\n            // Pull out the Union, and attempt to resolve against it.\n            let v = match self {\n                Value::Union(b) => *b,\n                _ => unreachable!(),\n            };\n            self = v;\n        }\n        match *schema {\n            Schema::Null => self.resolve_null(),\n            Schema::Boolean => self.resolve_boolean(),\n            Schema::Int => self.resolve_int(),\n            Schema::Long => self.resolve_long(),\n            Schema::Float => self.resolve_float(),\n            Schema::Double => self.resolve_double(),\n            Schema::Bytes => self.resolve_bytes(),\n            Schema::String => self.resolve_string(),\n            Schema::Fixed { size, .. } => self.resolve_fixed(size),\n            Schema::Union(ref inner) => self.resolve_union(inner),\n            Schema::Enum { ref symbols, .. } => self.resolve_enum(symbols),\n            Schema::Array(ref inner) => self.resolve_array(inner),\n            Schema::Map(ref inner) => self.resolve_map(inner),\n            Schema::Record { ref fields, .. } => self.resolve_record(fields),\n            Schema::Decimal {\n                scale,\n                precision,\n                ref inner,\n            } => self.resolve_decimal(precision, scale, inner),\n            Schema::Date => self.resolve_date(),\n            Schema::TimeMillis => self.resolve_time_millis(),\n            Schema::TimeMicros => self.resolve_time_micros(),\n            Schema::TimestampMillis => self.resolve_timestamp_millis(),\n            Schema::TimestampMicros => self.resolve_timestamp_micros(),\n            Schema::Duration => self.resolve_duration(),\n            Schema::Uuid => self.resolve_uuid(),\n        }\n    }\n\n    fn resolve_uuid(self) -> Result<Self, Error> {\n        Ok(match self {\n            uuid @ Value::Uuid(_) => uuid,\n            Value::String(ref string) => {\n                Value::Uuid(Uuid::from_str(string).map_err(Error::ConvertStrToUuid)?)\n            }\n            other => return Err(Error::GetUuid(other.into())),\n        })\n    }\n\n    fn resolve_duration(self) -> Result<Self, Error> {\n        Ok(match self {\n            duration @ Value::Duration { .. } => duration,\n            Value::Fixed(size, bytes) => {\n                if size != 12 {\n                    return Err(Error::GetDecimalFixedBytes(size));\n                }\n                Value::Duration(Duration::from([\n                    bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],\n                    bytes[8], bytes[9], bytes[10], bytes[11],\n                ]))\n            }\n            other => return Err(Error::ResolveDuration(other.into())),\n        })\n    }\n\n    fn resolve_decimal(\n        self,\n        precision: Precision,\n        scale: Scale,\n        inner: &Schema,\n    ) -> Result<Self, Error> {\n        if scale > precision {\n            return Err(Error::GetScaleAndPrecision { scale, precision });\n        }\n        match inner {\n            &Schema::Fixed { size, .. } => {\n                if max_prec_for_len(size)? < precision {\n                    return Err(Error::GetScaleWithFixedSize { size, precision });\n                }\n            }\n            Schema::Bytes => (),\n            _ => return Err(Error::ResolveDecimalSchema(inner.into())),\n        };\n        match self {\n            Value::Decimal(num) => {\n                let num_bytes = num.len();\n                if max_prec_for_len(num_bytes)? > precision {\n                    Err(Error::ComparePrecisionAndSize {\n                        precision,\n                        num_bytes,\n                    })\n                } else {\n                    Ok(Value::Decimal(num))\n                }\n                // check num.bits() here\n            }\n            Value::Fixed(_, bytes) | Value::Bytes(bytes) => {\n                if max_prec_for_len(bytes.len())? > precision {\n                    Err(Error::ComparePrecisionAndSize {\n                        precision,\n                        num_bytes: bytes.len(),\n                    })\n                } else {\n                    // precision and scale match, can we assume the underlying type can hold the data?\n                    Ok(Value::Decimal(Decimal::from(bytes)))\n                }\n            }\n            other => Err(Error::ResolveDecimal(other.into())),\n        }\n    }\n\n    fn resolve_date(self) -> Result<Self, Error> {\n        match self {\n            Value::Date(d) | Value::Int(d) => Ok(Value::Date(d)),\n            other => Err(Error::GetDate(other.into())),\n        }\n    }\n\n    fn resolve_time_millis(self) -> Result<Self, Error> {\n        match self {\n            Value::TimeMillis(t) | Value::Int(t) => Ok(Value::TimeMillis(t)),\n            other => Err(Error::GetTimeMillis(other.into())),\n        }\n    }\n\n    fn resolve_time_micros(self) -> Result<Self, Error> {\n        match self {\n            Value::TimeMicros(t) | Value::Long(t) => Ok(Value::TimeMicros(t)),\n            Value::Int(t) => Ok(Value::TimeMicros(i64::from(t))),\n            other => Err(Error::GetTimeMicros(other.into())),\n        }\n    }\n\n    fn resolve_timestamp_millis(self) -> Result<Self, Error> {\n        match self {\n            Value::TimestampMillis(ts) | Value::Long(ts) => Ok(Value::TimestampMillis(ts)),\n            Value::Int(ts) => Ok(Value::TimestampMillis(i64::from(ts))),\n            other => Err(Error::GetTimestampMillis(other.into())),\n        }\n    }\n\n    fn resolve_timestamp_micros(self) -> Result<Self, Error> {\n        match self {\n            Value::TimestampMicros(ts) | Value::Long(ts) => Ok(Value::TimestampMicros(ts)),\n            Value::Int(ts) => Ok(Value::TimestampMicros(i64::from(ts))),\n            other => Err(Error::GetTimestampMicros(other.into())),\n        }\n    }\n\n    fn resolve_null(self) -> Result<Self, Error> {\n        match self {\n            Value::Null => Ok(Value::Null),\n            other => Err(Error::GetNull(other.into())),\n        }\n    }\n\n    fn resolve_boolean(self) -> Result<Self, Error> {\n        match self {\n            Value::Boolean(b) => Ok(Value::Boolean(b)),\n            other => Err(Error::GetBoolean(other.into())),\n        }\n    }\n\n    fn resolve_int(self) -> Result<Self, Error> {\n        match self {\n            Value::Int(n) => Ok(Value::Int(n)),\n            Value::Long(n) => Ok(Value::Int(n as i32)),\n            other => Err(Error::GetInt(other.into())),\n        }\n    }\n\n    fn resolve_long(self) -> Result<Self, Error> {\n        match self {\n            Value::Int(n) => Ok(Value::Long(i64::from(n))),\n            Value::Long(n) => Ok(Value::Long(n)),\n            other => Err(Error::GetLong(other.into())),\n        }\n    }\n\n    fn resolve_float(self) -> Result<Self, Error> {\n        match self {\n            Value::Int(n) => Ok(Value::Float(n as f32)),\n            Value::Long(n) => Ok(Value::Float(n as f32)),\n            Value::Float(x) => Ok(Value::Float(x)),\n            Value::Double(x) => Ok(Value::Float(x as f32)),\n            other => Err(Error::GetFloat(other.into())),\n        }\n    }\n\n    fn resolve_double(self) -> Result<Self, Error> {\n        match self {\n            Value::Int(n) => Ok(Value::Double(f64::from(n))),\n            Value::Long(n) => Ok(Value::Double(n as f64)),\n            Value::Float(x) => Ok(Value::Double(f64::from(x))),\n            Value::Double(x) => Ok(Value::Double(x)),\n            other => Err(Error::GetDouble(other.into())),\n        }\n    }\n\n    fn resolve_bytes(self) -> Result<Self, Error> {\n        match self {\n            Value::Bytes(bytes) => Ok(Value::Bytes(bytes)),\n            Value::String(s) => Ok(Value::Bytes(s.into_bytes())),\n            Value::Array(items) => Ok(Value::Bytes(\n                items\n                    .into_iter()\n                    .map(Value::try_u8)\n                    .collect::<Result<Vec<_>, _>>()?,\n            )),\n            other => Err(Error::GetBytes(other.into())),\n        }\n    }\n\n    fn resolve_string(self) -> Result<Self, Error> {\n        match self {\n            Value::String(s) => Ok(Value::String(s)),\n            Value::Bytes(bytes) => Ok(Value::String(\n                String::from_utf8(bytes).map_err(Error::ConvertToUtf8)?,\n            )),\n            other => Err(Error::GetString(other.into())),\n        }\n    }\n\n    fn resolve_fixed(self, size: usize) -> Result<Self, Error> {\n        match self {\n            Value::Fixed(n, bytes) => {\n                if n == size {\n                    Ok(Value::Fixed(n, bytes))\n                } else {\n                    Err(Error::CompareFixedSizes { size, n })\n                }\n            }\n            other => Err(Error::GetStringForFixed(other.into())),\n        }\n    }\n\n    fn resolve_enum(self, symbols: &[String]) -> Result<Self, Error> {\n        let validate_symbol = |symbol: String, symbols: &[String]| {\n            if let Some(index) = symbols.iter().position(|item| item == &symbol) {\n                Ok(Value::Enum(index as i32, symbol))\n            } else {\n                Err(Error::GetEnumDefault {\n                    symbol,\n                    symbols: symbols.into(),\n                })\n            }\n        };\n\n        match self {\n            Value::Enum(raw_index, s) => {\n                let index = usize::try_from(raw_index)\n                    .map_err(|e| Error::ConvertI32ToUsize(e, raw_index))?;\n                if (0..=symbols.len()).contains(&index) {\n                    validate_symbol(s, symbols)\n                } else {\n                    Err(Error::GetEnumValue {\n                        index,\n                        nsymbols: symbols.len(),\n                    })\n                }\n            }\n            Value::String(s) => validate_symbol(s, symbols),\n            other => Err(Error::GetEnum(other.into())),\n        }\n    }\n\n    fn resolve_union(self, schema: &UnionSchema) -> Result<Self, Error> {\n        let v = match self {\n            // Both are unions case.\n            Value::Union(v) => *v,\n            // Reader is a union, but writer is not.\n            v => v,\n        };\n        // Find the first match in the reader schema.\n        let (_, inner) = schema.find_schema(&v).ok_or(Error::FindUnionVariant)?;\n        Ok(Value::Union(Box::new(v.resolve(inner)?)))\n    }\n\n    fn resolve_array(self, schema: &Schema) -> Result<Self, Error> {\n        match self {\n            Value::Array(items) => Ok(Value::Array(\n                items\n                    .into_iter()\n                    .map(|item| item.resolve(schema))\n                    .collect::<Result<_, _>>()?,\n            )),\n            other => Err(Error::GetArray {\n                expected: schema.into(),\n                other: other.into(),\n            }),\n        }\n    }\n\n    fn resolve_map(self, schema: &Schema) -> Result<Self, Error> {\n        match self {\n            Value::Map(items) => Ok(Value::Map(\n                items\n                    .into_iter()\n                    .map(|(key, value)| value.resolve(schema).map(|value| (key, value)))\n                    .collect::<Result<_, _>>()?,\n            )),\n            other => Err(Error::GetMap {\n                expected: schema.into(),\n                other: other.into(),\n            }),\n        }\n    }\n\n    fn resolve_record(self, fields: &[RecordField]) -> Result<Self, Error> {\n        let mut items = match self {\n            Value::Map(items) => Ok(items),\n            Value::Record(fields) => Ok(fields.into_iter().collect::<HashMap<_, _>>()),\n            other => Err(Error::GetRecord {\n                expected: fields\n                    .iter()\n                    .map(|field| (field.name.clone(), field.schema.clone().into()))\n                    .collect(),\n                other: other.into(),\n            }),\n        }?;\n\n        let new_fields = fields\n            .iter()\n            .map(|field| {\n                let value = match items.remove(&field.name) {\n                    Some(value) => value,\n                    None => match field.default {\n                        Some(ref value) => match field.schema {\n                            Schema::Enum { ref symbols, .. } => {\n                                Value::from(value.clone()).resolve_enum(symbols)?\n                            }\n                            Schema::Union(ref union_schema) => {\n                                let first = &union_schema.variants()[0];\n                                // NOTE: this match exists only to optimize null defaults for large\n                                // backward-compatible schemas with many nullable fields\n                                match first {\n                                    Schema::Null => Value::Union(Box::new(Value::Null)),\n                                    _ => Value::Union(Box::new(\n                                        Value::from(value.clone()).resolve(first)?,\n                                    )),\n                                }\n                            }\n                            _ => Value::from(value.clone()),\n                        },\n                        None => {\n                            return Err(Error::GetField(field.name.clone()));\n                        }\n                    },\n                };\n                value\n                    .resolve(&field.schema)\n                    .map(|value| (field.name.clone(), value))\n            })\n            .collect::<Result<Vec<_>, _>>()?;\n\n        Ok(Value::Record(new_fields))\n    }\n\n    fn try_u8(self) -> AvroResult<u8> {\n        let int = self.resolve(&Schema::Int)?;\n        if let Value::Int(n) = int {\n            if n >= 0 && n <= i32::from(u8::MAX) {\n                return Ok(n as u8);\n            }\n        }\n\n        Err(Error::GetU8(int.into()))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        decimal::Decimal,\n        duration::{Days, Duration, Millis, Months},\n        schema::{Name, RecordField, RecordFieldOrder, Schema, UnionSchema},\n        types::Value,\n    };\n    use uuid::Uuid;\n\n    #[test]\n    fn validate() {\n        let value_schema_valid = vec![\n            (Value::Int(42), Schema::Int, true),\n            (Value::Int(42), Schema::Boolean, false),\n            (\n                Value::Union(Box::new(Value::Null)),\n                Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::Int]).unwrap()),\n                true,\n            ),\n            (\n                Value::Union(Box::new(Value::Int(42))),\n                Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::Int]).unwrap()),\n                true,\n            ),\n            (\n                Value::Union(Box::new(Value::Null)),\n                Schema::Union(UnionSchema::new(vec![Schema::Double, Schema::Int]).unwrap()),\n                false,\n            ),\n            (\n                Value::Union(Box::new(Value::Int(42))),\n                Schema::Union(\n                    UnionSchema::new(vec![\n                        Schema::Null,\n                        Schema::Double,\n                        Schema::String,\n                        Schema::Int,\n                    ])\n                    .unwrap(),\n                ),\n                true,\n            ),\n            (\n                Value::Union(Box::new(Value::Long(42i64))),\n                Schema::Union(\n                    UnionSchema::new(vec![Schema::Null, Schema::TimestampMillis]).unwrap(),\n                ),\n                true,\n            ),\n            (\n                Value::Array(vec![Value::Long(42i64)]),\n                Schema::Array(Box::new(Schema::Long)),\n                true,\n            ),\n            (\n                Value::Array(vec![Value::Boolean(true)]),\n                Schema::Array(Box::new(Schema::Long)),\n                false,\n            ),\n            (Value::Record(vec![]), Schema::Null, false),\n        ];\n\n        for (value, schema, valid) in value_schema_valid.into_iter() {\n            assert_eq!(valid, value.validate(&schema));\n        }\n    }\n\n    #[test]\n    fn validate_fixed() {\n        let schema = Schema::Fixed {\n            size: 4,\n            name: Name::new(\"some_fixed\"),\n        };\n\n        assert!(Value::Fixed(4, vec![0, 0, 0, 0]).validate(&schema));\n        assert!(!Value::Fixed(5, vec![0, 0, 0, 0, 0]).validate(&schema));\n        assert!(Value::Bytes(vec![0, 0, 0, 0]).validate(&schema));\n        assert!(!Value::Bytes(vec![0, 0, 0, 0, 0]).validate(&schema));\n    }\n\n    #[test]\n    fn validate_enum() {\n        let schema = Schema::Enum {\n            name: Name::new(\"some_enum\"),\n            doc: None,\n            symbols: vec![\n                \"spades\".to_string(),\n                \"hearts\".to_string(),\n                \"diamonds\".to_string(),\n                \"clubs\".to_string(),\n            ],\n        };\n\n        assert!(Value::Enum(0, \"spades\".to_string()).validate(&schema));\n        assert!(Value::String(\"spades\".to_string()).validate(&schema));\n\n        assert!(!Value::Enum(1, \"spades\".to_string()).validate(&schema));\n        assert!(!Value::String(\"lorem\".to_string()).validate(&schema));\n\n        let other_schema = Schema::Enum {\n            name: Name::new(\"some_other_enum\"),\n            doc: None,\n            symbols: vec![\n                \"hearts\".to_string(),\n                \"diamonds\".to_string(),\n                \"clubs\".to_string(),\n                \"spades\".to_string(),\n            ],\n        };\n\n        assert!(!Value::Enum(0, \"spades\".to_string()).validate(&other_schema));\n    }\n\n    #[test]\n    fn validate_record() {\n        use std::collections::HashMap;\n        // {\n        //    \"type\": \"record\",\n        //    \"fields\": [\n        //      {\"type\": \"long\", \"name\": \"a\"},\n        //      {\"type\": \"string\", \"name\": \"b\"}\n        //    ]\n        // }\n        let schema = Schema::Record {\n            name: Name::new(\"some_record\"),\n            doc: None,\n            fields: vec![\n                RecordField {\n                    name: \"a\".to_string(),\n                    doc: None,\n                    default: None,\n                    schema: Schema::Long,\n                    order: RecordFieldOrder::Ascending,\n                    position: 0,\n                },\n                RecordField {\n                    name: \"b\".to_string(),\n                    doc: None,\n                    default: None,\n                    schema: Schema::String,\n                    order: RecordFieldOrder::Ascending,\n                    position: 1,\n                },\n            ],\n            lookup: HashMap::new(),\n        };\n\n        assert!(Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n        ])\n        .validate(&schema));\n\n        assert!(!Value::Record(vec![\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            (\"a\".to_string(), Value::Long(42i64)),\n        ])\n        .validate(&schema));\n\n        assert!(!Value::Record(vec![\n            (\"a\".to_string(), Value::Boolean(false)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n        ])\n        .validate(&schema));\n\n        assert!(!Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"c\".to_string(), Value::String(\"foo\".to_string())),\n        ])\n        .validate(&schema));\n\n        assert!(!Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            (\"c\".to_string(), Value::Null),\n        ])\n        .validate(&schema));\n\n        assert!(Value::Map(\n            vec![\n                (\"a\".to_string(), Value::Long(42i64)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            ]\n            .into_iter()\n            .collect()\n        )\n        .validate(&schema));\n\n        let union_schema = Schema::Union(UnionSchema::new(vec![Schema::Null, schema]).unwrap());\n\n        assert!(Value::Union(Box::new(Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n        ])))\n        .validate(&union_schema));\n\n        assert!(Value::Union(Box::new(Value::Map(\n            vec![\n                (\"a\".to_string(), Value::Long(42i64)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            ]\n            .into_iter()\n            .collect()\n        )))\n        .validate(&union_schema));\n    }\n\n    #[test]\n    fn resolve_bytes_ok() {\n        let value = Value::Array(vec![Value::Int(0), Value::Int(42)]);\n        assert_eq!(\n            value.resolve(&Schema::Bytes).unwrap(),\n            Value::Bytes(vec![0u8, 42u8])\n        );\n    }\n\n    #[test]\n    fn resolve_bytes_failure() {\n        let value = Value::Array(vec![Value::Int(2000), Value::Int(-42)]);\n        assert!(value.resolve(&Schema::Bytes).is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_bytes() {\n        let value = Value::Decimal(Decimal::from(vec![1, 2]));\n        value\n            .clone()\n            .resolve(&Schema::Decimal {\n                precision: 10,\n                scale: 4,\n                inner: Box::new(Schema::Bytes),\n            })\n            .unwrap();\n        assert!(value.resolve(&Schema::String).is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_invalid_scale() {\n        let value = Value::Decimal(Decimal::from(vec![1]));\n        assert!(value\n            .resolve(&Schema::Decimal {\n                precision: 2,\n                scale: 3,\n                inner: Box::new(Schema::Bytes),\n            })\n            .is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_invalid_precision_for_length() {\n        let value = Value::Decimal(Decimal::from((1u8..=8u8).rev().collect::<Vec<_>>()));\n        assert!(value\n            .resolve(&Schema::Decimal {\n                precision: 1,\n                scale: 0,\n                inner: Box::new(Schema::Bytes),\n            })\n            .is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_fixed() {\n        let value = Value::Decimal(Decimal::from(vec![1, 2]));\n        assert!(value\n            .clone()\n            .resolve(&Schema::Decimal {\n                precision: 10,\n                scale: 1,\n                inner: Box::new(Schema::Fixed {\n                    name: Name::new(\"decimal\"),\n                    size: 20\n                })\n            })\n            .is_ok());\n        assert!(value.resolve(&Schema::String).is_err());\n    }\n\n    #[test]\n    fn resolve_date() {\n        let value = Value::Date(2345);\n        assert!(value.clone().resolve(&Schema::Date).is_ok());\n        assert!(value.resolve(&Schema::String).is_err());\n    }\n\n    #[test]\n    fn resolve_time_millis() {\n        let value = Value::TimeMillis(10);\n        assert!(value.clone().resolve(&Schema::TimeMillis).is_ok());\n        assert!(value.resolve(&Schema::TimeMicros).is_err());\n    }\n\n    #[test]\n    fn resolve_time_micros() {\n        let value = Value::TimeMicros(10);\n        assert!(value.clone().resolve(&Schema::TimeMicros).is_ok());\n        assert!(value.resolve(&Schema::TimeMillis).is_err());\n    }\n\n    #[test]\n    fn resolve_timestamp_millis() {\n        let value = Value::TimestampMillis(10);\n        assert!(value.clone().resolve(&Schema::TimestampMillis).is_ok());\n        assert!(value.resolve(&Schema::Float).is_err());\n\n        let value = Value::Float(10.0f32);\n        assert!(value.resolve(&Schema::TimestampMillis).is_err());\n    }\n\n    #[test]\n    fn resolve_timestamp_micros() {\n        let value = Value::TimestampMicros(10);\n        assert!(value.clone().resolve(&Schema::TimestampMicros).is_ok());\n        assert!(value.resolve(&Schema::Int).is_err());\n\n        let value = Value::Double(10.0);\n        assert!(value.resolve(&Schema::TimestampMicros).is_err());\n    }\n\n    #[test]\n    fn resolve_duration() {\n        let value = Value::Duration(Duration::new(\n            Months::new(10),\n            Days::new(5),\n            Millis::new(3000),\n        ));\n        assert!(value.clone().resolve(&Schema::Duration).is_ok());\n        assert!(value.resolve(&Schema::TimestampMicros).is_err());\n        assert!(Value::Long(1i64).resolve(&Schema::Duration).is_err());\n    }\n\n    #[test]\n    fn resolve_uuid() {\n        let value = Value::Uuid(Uuid::parse_str(\"1481531d-ccc9-46d9-a56f-5b67459c0537\").unwrap());\n        assert!(value.clone().resolve(&Schema::Uuid).is_ok());\n        assert!(value.resolve(&Schema::TimestampMicros).is_err());\n    }\n\n    #[test]\n    fn json_from_avro() {\n        assert_eq!(JsonValue::try_from(Value::Null).unwrap(), JsonValue::Null);\n        assert_eq!(\n            JsonValue::try_from(Value::Boolean(true)).unwrap(),\n            JsonValue::Bool(true)\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Int(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Long(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Float(1.0)).unwrap(),\n            JsonValue::Number(Number::from_f64(1.0).unwrap())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Double(1.0)).unwrap(),\n            JsonValue::Number(Number::from_f64(1.0).unwrap())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Bytes(vec![1, 2, 3])).unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::String(\"test\".into())).unwrap(),\n            JsonValue::String(\"test\".into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Fixed(3, vec![1, 2, 3])).unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Enum(1, \"test_enum\".into())).unwrap(),\n            JsonValue::String(\"test_enum\".into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Union(Box::new(Value::String(\"test_enum\".into())))).unwrap(),\n            JsonValue::String(\"test_enum\".into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Array(vec![\n                Value::Int(1),\n                Value::Int(2),\n                Value::Int(3)\n            ]))\n            .unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Map(\n                vec![\n                    (\"v1\".to_string(), Value::Int(1)),\n                    (\"v2\".to_string(), Value::Int(2)),\n                    (\"v3\".to_string(), Value::Int(3))\n                ]\n                .into_iter()\n                .collect()\n            ))\n            .unwrap(),\n            JsonValue::Object(\n                vec![\n                    (\"v1\".to_string(), JsonValue::Number(1.into())),\n                    (\"v2\".to_string(), JsonValue::Number(2.into())),\n                    (\"v3\".to_string(), JsonValue::Number(3.into()))\n                ]\n                .into_iter()\n                .collect()\n            )\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Record(vec![\n                (\"v1\".to_string(), Value::Int(1)),\n                (\"v2\".to_string(), Value::Int(2)),\n                (\"v3\".to_string(), Value::Int(3))\n            ]))\n            .unwrap(),\n            JsonValue::Object(\n                vec![\n                    (\"v1\".to_string(), JsonValue::Number(1.into())),\n                    (\"v2\".to_string(), JsonValue::Number(2.into())),\n                    (\"v3\".to_string(), JsonValue::Number(3.into()))\n                ]\n                .into_iter()\n                .collect()\n            )\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Date(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Decimal(vec![1, 2, 3].into())).unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimeMillis(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimeMicros(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimestampMillis(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimestampMicros(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Duration(\n                [1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8].into()\n            ))\n            .unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into()),\n                JsonValue::Number(4.into()),\n                JsonValue::Number(5.into()),\n                JsonValue::Number(6.into()),\n                JsonValue::Number(7.into()),\n                JsonValue::Number(8.into()),\n                JsonValue::Number(9.into()),\n                JsonValue::Number(10.into()),\n                JsonValue::Number(11.into()),\n                JsonValue::Number(12.into()),\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Uuid(\n                Uuid::parse_str(\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\").unwrap()\n            ))\n            .unwrap(),\n            JsonValue::String(\"936da01f-9abd-4d9d-80c7-02af85c822a8\".into())\n        );\n    }\n}\n","traces":[{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","util.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{AvroResult, Error};\nuse serde_json::{Map, Value};\nuse std::{convert::TryFrom, i64, io::Read, sync::Once};\n\n/// Maximum number of bytes that can be allocated when decoding\n/// Avro-encoded values. This is a protection against ill-formed\n/// data, whose length field might be interpreted as enourmous.\n/// See max_allocation_bytes to change this limit.\npub static mut MAX_ALLOCATION_BYTES: usize = 512 * 1024 * 1024;\nstatic MAX_ALLOCATION_BYTES_ONCE: Once = Once::new();\n\npub trait MapHelper {\n    fn string(&self, key: &str) -> Option<String>;\n\n    fn name(&self) -> Option<String> {\n        self.string(\"name\")\n    }\n\n    fn doc(&self) -> Option<String> {\n        self.string(\"doc\")\n    }\n}\n\nimpl MapHelper for Map<String, Value> {\n    fn string(&self, key: &str) -> Option<String> {\n        self.get(key)\n            .and_then(|v| v.as_str())\n            .map(|v| v.to_string())\n    }\n}\n\npub fn read_long<R: Read>(reader: &mut R) -> AvroResult<i64> {\n    zag_i64(reader)\n}\n\npub fn zig_i32(n: i32, buffer: &mut Vec<u8>) {\n    zig_i64(n as i64, buffer)\n}\n\npub fn zig_i64(n: i64, buffer: &mut Vec<u8>) {\n    encode_variable(((n << 1) ^ (n >> 63)) as u64, buffer)\n}\n\npub fn zag_i32<R: Read>(reader: &mut R) -> AvroResult<i32> {\n    let i = zag_i64(reader)?;\n    i32::try_from(i).map_err(|e| Error::ZagI32(e, i))\n}\n\npub fn zag_i64<R: Read>(reader: &mut R) -> AvroResult<i64> {\n    let z = decode_variable(reader)?;\n    Ok(if z & 0x1 == 0 {\n        (z >> 1) as i64\n    } else {\n        !(z >> 1) as i64\n    })\n}\n\nfn encode_variable(mut z: u64, buffer: &mut Vec<u8>) {\n    loop {\n        if z <= 0x7F {\n            buffer.push((z & 0x7F) as u8);\n            break;\n        } else {\n            buffer.push((0x80 | (z & 0x7F)) as u8);\n            z >>= 7;\n        }\n    }\n}\n\nfn decode_variable<R: Read>(reader: &mut R) -> AvroResult<u64> {\n    let mut i = 0u64;\n    let mut buf = [0u8; 1];\n\n    let mut j = 0;\n    loop {\n        if j > 9 {\n            // if j * 7 > 64\n            return Err(Error::IntegerOverflow);\n        }\n        reader\n            .read_exact(&mut buf[..])\n            .map_err(Error::ReadVariableIntegerBytes)?;\n        i |= (u64::from(buf[0] & 0x7F)) << (j * 7);\n        if (buf[0] >> 7) == 0 {\n            break;\n        } else {\n            j += 1;\n        }\n    }\n\n    Ok(i)\n}\n\n/// Set a new maximum number of bytes that can be allocated when decoding data.\n/// Once called, the limit cannot be changed.\n///\n/// **NOTE** This function must be called before decoding **any** data. The\n/// library leverages [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html)\n/// to set the limit either when calling this method, or when decoding for\n/// the first time.\npub fn max_allocation_bytes(num_bytes: usize) -> usize {\n    unsafe {\n        MAX_ALLOCATION_BYTES_ONCE.call_once(|| {\n            MAX_ALLOCATION_BYTES = num_bytes;\n        });\n        MAX_ALLOCATION_BYTES\n    }\n}\n\npub fn safe_len(len: usize) -> AvroResult<usize> {\n    let max_bytes = max_allocation_bytes(512 * 1024 * 1024);\n\n    if len <= max_bytes {\n        Ok(len)\n    } else {\n        Err(Error::MemoryAllocation {\n            desired: len,\n            maximum: max_bytes,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_zigzag() {\n        let mut a = Vec::new();\n        let mut b = Vec::new();\n        zig_i32(42i32, &mut a);\n        zig_i64(42i64, &mut b);\n        assert_eq!(a, b);\n    }\n\n    #[test]\n    fn test_zig_i64() {\n        let mut s = Vec::new();\n        zig_i64(std::i32::MAX as i64, &mut s);\n        assert_eq!(s, [254, 255, 255, 255, 15]);\n\n        s.clear();\n        zig_i64(std::i32::MAX as i64 + 1, &mut s);\n        assert_eq!(s, [128, 128, 128, 128, 16]);\n\n        s.clear();\n        zig_i64(std::i32::MIN as i64, &mut s);\n        assert_eq!(s, [255, 255, 255, 255, 15]);\n\n        s.clear();\n        zig_i64(std::i32::MIN as i64 - 1, &mut s);\n        assert_eq!(s, [129, 128, 128, 128, 16]);\n\n        s.clear();\n        zig_i64(i64::MAX, &mut s);\n        assert_eq!(s, [254, 255, 255, 255, 255, 255, 255, 255, 255, 1]);\n\n        s.clear();\n        zig_i64(i64::MIN, &mut s);\n        assert_eq!(s, [255, 255, 255, 255, 255, 255, 255, 255, 255, 1]);\n    }\n\n    #[test]\n    fn test_zig_i32() {\n        let mut s = Vec::new();\n        zig_i32(std::i32::MAX / 2, &mut s);\n        assert_eq!(s, [254, 255, 255, 255, 7]);\n\n        s.clear();\n        zig_i32(std::i32::MIN / 2, &mut s);\n        assert_eq!(s, [255, 255, 255, 255, 7]);\n\n        s.clear();\n        zig_i32(-(std::i32::MIN / 2), &mut s);\n        assert_eq!(s, [128, 128, 128, 128, 8]);\n\n        s.clear();\n        zig_i32(std::i32::MIN / 2 - 1, &mut s);\n        assert_eq!(s, [129, 128, 128, 128, 8]);\n\n        s.clear();\n        zig_i32(std::i32::MAX, &mut s);\n        assert_eq!(s, [254, 255, 255, 255, 15]);\n\n        s.clear();\n        zig_i32(std::i32::MIN, &mut s);\n        assert_eq!(s, [255, 255, 255, 255, 15]);\n    }\n\n    #[test]\n    fn test_overflow() {\n        let causes_left_shift_overflow: &[u8] = &[0xe1, 0xe1, 0xe1, 0xe1, 0xe1];\n        assert!(decode_variable(&mut &*causes_left_shift_overflow).is_err());\n    }\n\n    #[test]\n    fn test_safe_len() {\n        assert_eq!(42usize, safe_len(42usize).unwrap());\n        assert!(safe_len(1024 * 1024 * 1024).is_err());\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","writer.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic handling writing in Avro format at user level.\nuse crate::{\n    encode::{encode, encode_ref, encode_to_vec},\n    schema::Schema,\n    ser::Serializer,\n    types::Value,\n    AvroResult, Codec, Error,\n};\nuse rand::random;\nuse serde::Serialize;\nuse std::{collections::HashMap, io::Write};\n\nconst DEFAULT_BLOCK_SIZE: usize = 16000;\nconst AVRO_OBJECT_HEADER: &[u8] = b\"Obj\\x01\";\n\n/// Main interface for writing Avro formatted values.\n#[derive(typed_builder::TypedBuilder)]\npub struct Writer<'a, W> {\n    schema: &'a Schema,\n    writer: W,\n    #[builder(default = Codec::Null)]\n    codec: Codec,\n    #[builder(default = DEFAULT_BLOCK_SIZE)]\n    block_size: usize,\n    #[builder(default = Vec::with_capacity(block_size), setter(skip))]\n    buffer: Vec<u8>,\n    #[builder(default, setter(skip))]\n    serializer: Serializer,\n    #[builder(default = 0, setter(skip))]\n    num_values: usize,\n    #[builder(default = std::iter::repeat_with(random).take(16).collect(), setter(skip))]\n    marker: Vec<u8>,\n    #[builder(default = false, setter(skip))]\n    has_header: bool,\n}\n\nimpl<'a, W: Write> Writer<'a, W> {\n    /// Creates a `Writer` given a `Schema` and something implementing the `io::Write` trait to write\n    /// to.\n    /// No compression `Codec` will be used.\n    pub fn new(schema: &'a Schema, writer: W) -> Self {\n        Self::builder().schema(schema).writer(writer).build()\n    }\n\n    /// Creates a `Writer` with a specific `Codec` given a `Schema` and something implementing the\n    /// `io::Write` trait to write to.\n    pub fn with_codec(schema: &'a Schema, writer: W, codec: Codec) -> Self {\n        Self::builder()\n            .schema(schema)\n            .writer(writer)\n            .codec(codec)\n            .build()\n    }\n\n    /// Get a reference to the `Schema` associated to a `Writer`.\n    pub fn schema(&self) -> &'a Schema {\n        self.schema\n    }\n\n    /// Append a compatible value (implementing the `ToAvro` trait) to a `Writer`, also performing\n    /// schema validation.\n    ///\n    /// Return the number of bytes written (it might be 0, see below).\n    ///\n    /// **NOTE** This function is not guaranteed to perform any actual write, since it relies on\n    /// internal buffering for performance reasons. If you want to be sure the value has been\n    /// written, then call [`flush`](struct.Writer.html#method.flush).\n    pub fn append<T: Into<Value>>(&mut self, value: T) -> AvroResult<usize> {\n        let n = if !self.has_header {\n            let header = self.header()?;\n            let n = self.append_bytes(header.as_ref())?;\n            self.has_header = true;\n            n\n        } else {\n            0\n        };\n\n        let avro = value.into();\n        write_value_ref(self.schema, &avro, &mut self.buffer)?;\n\n        self.num_values += 1;\n\n        if self.buffer.len() >= self.block_size {\n            return self.flush().map(|b| b + n);\n        }\n\n        Ok(n)\n    }\n\n    /// Append a compatible value to a `Writer`, also performing schema validation.\n    ///\n    /// Return the number of bytes written (it might be 0, see below).\n    ///\n    /// **NOTE** This function is not guaranteed to perform any actual write, since it relies on\n    /// internal buffering for performance reasons. If you want to be sure the value has been\n    /// written, then call [`flush`](struct.Writer.html#method.flush).\n    pub fn append_value_ref(&mut self, value: &Value) -> AvroResult<usize> {\n        let n = if !self.has_header {\n            let header = self.header()?;\n            let n = self.append_bytes(header.as_ref())?;\n            self.has_header = true;\n            n\n        } else {\n            0\n        };\n\n        write_value_ref(self.schema, value, &mut self.buffer)?;\n\n        self.num_values += 1;\n\n        if self.buffer.len() >= self.block_size {\n            return self.flush().map(|b| b + n);\n        }\n\n        Ok(n)\n    }\n\n    /// Append anything implementing the `Serialize` trait to a `Writer` for\n    /// [`serde`](https://docs.serde.rs/serde/index.html) compatibility, also performing schema\n    /// validation.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function is not guaranteed to perform any actual write, since it relies on\n    /// internal buffering for performance reasons. If you want to be sure the value has been\n    /// written, then call [`flush`](struct.Writer.html#method.flush).\n    pub fn append_ser<S: Serialize>(&mut self, value: S) -> AvroResult<usize> {\n        let avro_value = value.serialize(&mut self.serializer)?;\n        self.append(avro_value)\n    }\n\n    /// Extend a `Writer` with an `Iterator` of compatible values (implementing the `ToAvro`\n    /// trait), also performing schema validation.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn extend<I, T: Into<Value>>(&mut self, values: I) -> AvroResult<usize>\n    where\n        I: IntoIterator<Item = T>,\n    {\n        /*\n        https://github.com/rust-lang/rfcs/issues/811 :(\n        let mut stream = values\n            .filter_map(|value| value.serialize(&mut self.serializer).ok())\n            .map(|value| value.encode(self.schema))\n            .collect::<Option<Vec<_>>>()\n            .ok_or_else(|| err_msg(\"value does not match given schema\"))?\n            .into_iter()\n            .fold(Vec::new(), |mut acc, stream| {\n                num_values += 1;\n                acc.extend(stream); acc\n            });\n        */\n\n        let mut num_bytes = 0;\n        for value in values {\n            num_bytes += self.append(value)?;\n        }\n        num_bytes += self.flush()?;\n\n        Ok(num_bytes)\n    }\n\n    /// Extend a `Writer` with an `Iterator` of anything implementing the `Serialize` trait for\n    /// [`serde`](https://docs.serde.rs/serde/index.html) compatibility, also performing schema\n    /// validation.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn extend_ser<I, T: Serialize>(&mut self, values: I) -> AvroResult<usize>\n    where\n        I: IntoIterator<Item = T>,\n    {\n        /*\n        https://github.com/rust-lang/rfcs/issues/811 :(\n        let mut stream = values\n            .filter_map(|value| value.serialize(&mut self.serializer).ok())\n            .map(|value| value.encode(self.schema))\n            .collect::<Option<Vec<_>>>()\n            .ok_or_else(|| err_msg(\"value does not match given schema\"))?\n            .into_iter()\n            .fold(Vec::new(), |mut acc, stream| {\n                num_values += 1;\n                acc.extend(stream); acc\n            });\n        */\n\n        let mut num_bytes = 0;\n        for value in values {\n            num_bytes += self.append_ser(value)?;\n        }\n        num_bytes += self.flush()?;\n\n        Ok(num_bytes)\n    }\n\n    /// Extend a `Writer` by appending each `Value` from a slice, while also performing schema\n    /// validation on each value appended.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn extend_from_slice(&mut self, values: &[Value]) -> AvroResult<usize> {\n        let mut num_bytes = 0;\n        for value in values {\n            num_bytes += self.append_value_ref(value)?;\n        }\n        num_bytes += self.flush()?;\n\n        Ok(num_bytes)\n    }\n\n    /// Flush the content appended to a `Writer`. Call this function to make sure all the content\n    /// has been written before releasing the `Writer`.\n    ///\n    /// Return the number of bytes written.\n    pub fn flush(&mut self) -> AvroResult<usize> {\n        if self.num_values == 0 {\n            return Ok(0);\n        }\n\n        self.codec.compress(&mut self.buffer)?;\n\n        let num_values = self.num_values;\n        let stream_len = self.buffer.len();\n\n        let num_bytes = self.append_raw(&num_values.into(), &Schema::Long)?\n            + self.append_raw(&stream_len.into(), &Schema::Long)?\n            + self\n                .writer\n                .write(self.buffer.as_ref())\n                .map_err(Error::WriteBytes)?\n            + self.append_marker()?;\n\n        self.buffer.clear();\n        self.num_values = 0;\n\n        Ok(num_bytes)\n    }\n\n    /// Return what the `Writer` is writing to, consuming the `Writer` itself.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn into_inner(mut self) -> AvroResult<W> {\n        self.flush()?;\n        Ok(self.writer)\n    }\n\n    /// Generate and append synchronization marker to the payload.\n    fn append_marker(&mut self) -> AvroResult<usize> {\n        // using .writer.write directly to avoid mutable borrow of self\n        // with ref borrowing of self.marker\n        self.writer.write(&self.marker).map_err(Error::WriteMarker)\n    }\n\n    /// Append a raw Avro Value to the payload avoiding to encode it again.\n    fn append_raw(&mut self, value: &Value, schema: &Schema) -> AvroResult<usize> {\n        self.append_bytes(encode_to_vec(value, schema).as_ref())\n    }\n\n    /// Append pure bytes to the payload.\n    fn append_bytes(&mut self, bytes: &[u8]) -> AvroResult<usize> {\n        self.writer.write(bytes).map_err(Error::WriteBytes)\n    }\n\n    /// Create an Avro header based on schema, codec and sync marker.\n    fn header(&self) -> Result<Vec<u8>, Error> {\n        let schema_bytes = serde_json::to_string(self.schema)\n            .map_err(Error::ConvertJsonToString)?\n            .into_bytes();\n\n        let mut metadata = HashMap::with_capacity(2);\n        metadata.insert(\"avro.schema\", Value::Bytes(schema_bytes));\n        metadata.insert(\"avro.codec\", self.codec.into());\n\n        let mut header = Vec::new();\n        header.extend_from_slice(AVRO_OBJECT_HEADER);\n        encode(\n            &metadata.into(),\n            &Schema::Map(Box::new(Schema::Bytes)),\n            &mut header,\n        );\n        header.extend_from_slice(&self.marker);\n\n        Ok(header)\n    }\n}\n\n/// Encode a compatible value (implementing the `ToAvro` trait) into Avro format, also performing\n/// schema validation.\n///\n/// This is an internal function which gets the bytes buffer where to write as parameter instead of\n/// creating a new one like `to_avro_datum`.\nfn write_avro_datum<T: Into<Value>>(\n    schema: &Schema,\n    value: T,\n    buffer: &mut Vec<u8>,\n) -> Result<(), Error> {\n    let avro = value.into();\n    if !avro.validate(schema) {\n        return Err(Error::Validation);\n    }\n    encode(&avro, schema, buffer);\n    Ok(())\n}\n\nfn write_value_ref(schema: &Schema, value: &Value, buffer: &mut Vec<u8>) -> AvroResult<()> {\n    if !value.validate(schema) {\n        return Err(Error::Validation);\n    }\n    encode_ref(value, schema, buffer);\n    Ok(())\n}\n\n/// Encode a compatible value (implementing the `ToAvro` trait) into Avro format, also\n/// performing schema validation.\n///\n/// **NOTE** This function has a quite small niche of usage and does NOT generate headers and sync\n/// markers; use [`Writer`](struct.Writer.html) to be fully Avro-compatible if you don't know what\n/// you are doing, instead.\npub fn to_avro_datum<T: Into<Value>>(schema: &Schema, value: T) -> AvroResult<Vec<u8>> {\n    let mut buffer = Vec::new();\n    write_avro_datum(schema, value, &mut buffer)?;\n    Ok(buffer)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        decimal::Decimal,\n        duration::{Days, Duration, Millis, Months},\n        schema::Name,\n        types::Record,\n        util::zig_i64,\n    };\n    use serde::{Deserialize, Serialize};\n\n    const AVRO_OBJECT_HEADER_LEN: usize = AVRO_OBJECT_HEADER.len();\n\n    const SCHEMA: &str = r#\"\n    {\n      \"type\": \"record\",\n      \"name\": \"test\",\n      \"fields\": [\n        {\n          \"name\": \"a\",\n          \"type\": \"long\",\n          \"default\": 42\n        },\n        {\n          \"name\": \"b\",\n          \"type\": \"string\"\n        }\n      ]\n    }\n    \"#;\n    const UNION_SCHEMA: &str = r#\"[\"null\", \"long\"]\"#;\n\n    #[test]\n    fn test_to_avro_datum() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut record = Record::new(&schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n\n        let mut expected = Vec::new();\n        zig_i64(27, &mut expected);\n        zig_i64(3, &mut expected);\n        expected.extend(vec![b'f', b'o', b'o'].into_iter());\n\n        assert_eq!(to_avro_datum(&schema, record).unwrap(), expected);\n    }\n\n    #[test]\n    fn test_union_not_null() {\n        let schema = Schema::parse_str(UNION_SCHEMA).unwrap();\n        let union = Value::Union(Box::new(Value::Long(3)));\n\n        let mut expected = Vec::new();\n        zig_i64(1, &mut expected);\n        zig_i64(3, &mut expected);\n\n        assert_eq!(to_avro_datum(&schema, union).unwrap(), expected);\n    }\n\n    #[test]\n    fn test_union_null() {\n        let schema = Schema::parse_str(UNION_SCHEMA).unwrap();\n        let union = Value::Union(Box::new(Value::Null));\n\n        let mut expected = Vec::new();\n        zig_i64(0, &mut expected);\n\n        assert_eq!(to_avro_datum(&schema, union).unwrap(), expected);\n    }\n\n    type TestResult<T> = Result<T, Box<dyn std::error::Error>>;\n\n    fn logical_type_test<T: Into<Value> + Clone>(\n        schema_str: &'static str,\n\n        expected_schema: &Schema,\n        value: Value,\n\n        raw_schema: &Schema,\n        raw_value: T,\n    ) -> TestResult<()> {\n        let schema = Schema::parse_str(schema_str)?;\n        assert_eq!(&schema, expected_schema);\n        // The serialized format should be the same as the schema.\n        let ser = to_avro_datum(&schema, value.clone())?;\n        let raw_ser = to_avro_datum(raw_schema, raw_value)?;\n        assert_eq!(ser, raw_ser);\n\n        // Should deserialize from the schema into the logical type.\n        let mut r = ser.as_slice();\n        let de = crate::from_avro_datum(&schema, &mut r, None).unwrap();\n        assert_eq!(de, value);\n        Ok(())\n    }\n\n    #[test]\n    fn date() -> TestResult<()> {\n        logical_type_test(\n            r#\"{\"type\": \"int\", \"logicalType\": \"date\"}\"#,\n            &Schema::Date,\n            Value::Date(1_i32),\n            &Schema::Int,\n            1_i32,\n        )\n    }\n\n    #[test]\n    fn time_millis() -> TestResult<()> {\n        logical_type_test(\n            r#\"{\"type\": \"int\", \"logicalType\": \"time-millis\"}\"#,\n            &Schema::TimeMillis,\n            Value::TimeMillis(1_i32),\n            &Schema::Int,\n            1_i32,\n        )\n    }\n\n    #[test]\n    fn time_micros() -> TestResult<()> {\n        logical_type_test(\n            r#\"{\"type\": \"long\", \"logicalType\": \"time-micros\"}\"#,\n            &Schema::TimeMicros,\n            Value::TimeMicros(1_i64),\n            &Schema::Long,\n            1_i64,\n        )\n    }\n\n    #[test]\n    fn timestamp_millis() -> TestResult<()> {\n        logical_type_test(\n            r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\"#,\n            &Schema::TimestampMillis,\n            Value::TimestampMillis(1_i64),\n            &Schema::Long,\n            1_i64,\n        )\n    }\n\n    #[test]\n    fn timestamp_micros() -> TestResult<()> {\n        logical_type_test(\n            r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\"#,\n            &Schema::TimestampMicros,\n            Value::TimestampMicros(1_i64),\n            &Schema::Long,\n            1_i64,\n        )\n    }\n\n    #[test]\n    fn decimal_fixed() -> TestResult<()> {\n        let size = 30;\n        let inner = Schema::Fixed {\n            name: Name::new(\"decimal\"),\n            size,\n        };\n        let value = vec![0u8; size];\n        logical_type_test(\n            r#\"{\"type\": {\"type\": \"fixed\", \"size\": 30, \"name\": \"decimal\"}, \"logicalType\": \"decimal\", \"precision\": 20, \"scale\": 5}\"#,\n            &Schema::Decimal {\n                precision: 20,\n                scale: 5,\n                inner: Box::new(inner.clone()),\n            },\n            Value::Decimal(Decimal::from(value.clone())),\n            &inner,\n            Value::Fixed(size, value),\n        )\n    }\n\n    #[test]\n    fn decimal_bytes() -> TestResult<()> {\n        let inner = Schema::Bytes;\n        let value = vec![0u8; 10];\n        logical_type_test(\n            r#\"{\"type\": \"bytes\", \"logicalType\": \"decimal\", \"precision\": 4, \"scale\": 3}\"#,\n            &Schema::Decimal {\n                precision: 4,\n                scale: 3,\n                inner: Box::new(inner.clone()),\n            },\n            Value::Decimal(Decimal::from(value.clone())),\n            &inner,\n            value,\n        )\n    }\n\n    #[test]\n    fn duration() -> TestResult<()> {\n        let inner = Schema::Fixed {\n            name: Name::new(\"duration\"),\n            size: 12,\n        };\n        let value = Value::Duration(Duration::new(\n            Months::new(256),\n            Days::new(512),\n            Millis::new(1024),\n        ));\n        logical_type_test(\n            r#\"{\"type\": {\"type\": \"fixed\", \"name\": \"duration\", \"size\": 12}, \"logicalType\": \"duration\"}\"#,\n            &Schema::Duration,\n            value,\n            &inner,\n            Value::Fixed(12, vec![0, 1, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0]),\n        )\n    }\n\n    #[test]\n    fn test_writer_append() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(&schema, Vec::new());\n\n        let mut record = Record::new(&schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n\n        let n1 = writer.append(record.clone()).unwrap();\n        let n2 = writer.append(record.clone()).unwrap();\n        let n3 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2 + n3, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, &mut data);\n        zig_i64(3, &mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n\n        // starts with magic\n        assert_eq!(&result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            &result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[test]\n    fn test_writer_extend() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(&schema, Vec::new());\n\n        let mut record = Record::new(&schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        let record_copy = record.clone();\n        let records = vec![record, record_copy];\n\n        let n1 = writer.extend(records.into_iter()).unwrap();\n        let n2 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, &mut data);\n        zig_i64(3, &mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n\n        // starts with magic\n        assert_eq!(&result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            &result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[derive(Debug, Clone, Deserialize, Serialize)]\n    struct TestSerdeSerialize {\n        a: i64,\n        b: String,\n    }\n\n    #[test]\n    fn test_writer_append_ser() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(&schema, Vec::new());\n\n        let record = TestSerdeSerialize {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n\n        let n1 = writer.append_ser(record).unwrap();\n        let n2 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, &mut data);\n        zig_i64(3, &mut data);\n        data.extend(b\"foo\");\n\n        // starts with magic\n        assert_eq!(&result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            &result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[test]\n    fn test_writer_extend_ser() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(&schema, Vec::new());\n\n        let record = TestSerdeSerialize {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n        let record_copy = record.clone();\n        let records = vec![record, record_copy];\n\n        let n1 = writer.extend_ser(records.into_iter()).unwrap();\n        let n2 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, &mut data);\n        zig_i64(3, &mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n\n        // starts with magic\n        assert_eq!(&result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            &result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    fn make_writer_with_codec(schema: &Schema) -> Writer<'_, Vec<u8>> {\n        Writer::with_codec(schema, Vec::new(), Codec::Deflate)\n    }\n\n    fn make_writer_with_builder(schema: &Schema) -> Writer<'_, Vec<u8>> {\n        Writer::builder()\n            .writer(Vec::new())\n            .schema(schema)\n            .codec(Codec::Deflate)\n            .block_size(100)\n            .build()\n    }\n\n    fn check_writer(mut writer: Writer<'_, Vec<u8>>, schema: &Schema) {\n        let mut record = Record::new(schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n\n        let n1 = writer.append(record.clone()).unwrap();\n        let n2 = writer.append(record.clone()).unwrap();\n        let n3 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2 + n3, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, &mut data);\n        zig_i64(3, &mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n        Codec::Deflate.compress(&mut data).unwrap();\n\n        // starts with magic\n        assert_eq!(&result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            &result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[test]\n    fn test_writer_with_codec() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let writer = make_writer_with_codec(&schema);\n        check_writer(writer, &schema);\n    }\n\n    #[test]\n    fn test_writer_with_builder() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let writer = make_writer_with_builder(&schema);\n        check_writer(writer, &schema);\n    }\n\n    #[test]\n    fn test_logical_writer() {\n        const LOGICAL_TYPE_SCHEMA: &str = r#\"\n        {\n          \"type\": \"record\",\n          \"name\": \"logical_type_test\",\n          \"fields\": [\n            {\n              \"name\": \"a\",\n              \"type\": [\n                \"null\",\n                {\n                  \"type\": \"long\",\n                  \"logicalType\": \"timestamp-micros\"\n                }\n              ]\n            }\n          ]\n        }\n        \"#;\n        let codec = Codec::Deflate;\n        let schema = Schema::parse_str(LOGICAL_TYPE_SCHEMA).unwrap();\n        let mut writer = Writer::builder()\n            .schema(&schema)\n            .codec(codec)\n            .writer(Vec::new())\n            .build();\n\n        let mut record1 = Record::new(&schema).unwrap();\n        record1.put(\n            \"a\",\n            Value::Union(Box::new(Value::TimestampMicros(1234_i64))),\n        );\n\n        let mut record2 = Record::new(&schema).unwrap();\n        record2.put(\"a\", Value::Union(Box::new(Value::Null)));\n\n        let n1 = writer.append(record1).unwrap();\n        let n2 = writer.append(record2).unwrap();\n        let n3 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2 + n3, result.len());\n\n        let mut data = Vec::new();\n        // byte indicating not null\n        zig_i64(1, &mut data);\n        zig_i64(1234, &mut data);\n\n        // byte indicating null\n        zig_i64(0, &mut data);\n        codec.compress(&mut data).unwrap();\n\n        // starts with magic\n        assert_eq!(&result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            &result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":109},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","tests","io.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Port of https://github.com/apache/avro/blob/release-1.9.1/lang/py/test/test_io.py\nuse avro_rs::{from_avro_datum, to_avro_datum, types::Value, Error, Schema};\nuse lazy_static::lazy_static;\nuse std::io::Cursor;\n\nlazy_static! {\n    static ref SCHEMAS_TO_VALIDATE: Vec<(&'static str, Value)> = vec![\n        (r#\"\"null\"\"#, Value::Null),\n        (r#\"\"boolean\"\"#, Value::Boolean(true)),\n        (r#\"\"string\"\"#, Value::String(\"adsfasdf09809dsf-=adsf\".to_string())),\n        (r#\"\"bytes\"\"#, Value::Bytes(\"12345abcd\".to_string().into_bytes())),\n        (r#\"\"int\"\"#, Value::Int(1234)),\n        (r#\"\"long\"\"#, Value::Long(1234)),\n        (r#\"\"float\"\"#, Value::Float(1234.0)),\n        (r#\"\"double\"\"#, Value::Double(1234.0)),\n        (r#\"{\"type\": \"fixed\", \"name\": \"Test\", \"size\": 1}\"#, Value::Fixed(1, vec![b'B'])),\n        (r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\"#, Value::Enum(1, \"B\".to_string())),\n        (r#\"{\"type\": \"array\", \"items\": \"long\"}\"#, Value::Array(vec![Value::Long(1), Value::Long(3), Value::Long(2)])),\n        (r#\"{\"type\": \"map\", \"values\": \"long\"}\"#, Value::Map([(\"a\".to_string(), Value::Long(1i64)), (\"b\".to_string(), Value::Long(3i64)), (\"c\".to_string(), Value::Long(2i64))].iter().cloned().collect())),\n        (r#\"[\"string\", \"null\", \"long\"]\"#, Value::Union(Box::new(Value::Null))),\n        (r#\"{\"type\": \"record\", \"name\": \"Test\", \"fields\": [{\"name\": \"f\", \"type\": \"long\"}]}\"#, Value::Record(vec![(\"f\".to_string(), Value::Long(1))]))\n    ];\n\n    static ref BINARY_ENCODINGS: Vec<(i64, Vec<u8>)> = vec![\n        (0, vec![0x00]),\n        (-1, vec![0x01]),\n        (1, vec![0x02]),\n        (-2, vec![0x03]),\n        (2, vec![0x04]),\n        (-64, vec![0x7f]),\n        (64, vec![0x80, 0x01]),\n        (8192, vec![0x80, 0x80, 0x01]),\n        (-8193, vec![0x81, 0x80, 0x01]),\n    ];\n\n    static ref DEFAULT_VALUE_EXAMPLES: Vec<(&'static str, &'static str, Value)> = vec![\n        (r#\"\"null\"\"#, \"null\", Value::Null),\n        (r#\"\"boolean\"\"#, \"true\", Value::Boolean(true)),\n        (r#\"\"string\"\"#, r#\"\"foo\"\"#, Value::String(\"foo\".to_string())),\n        // TODO: (#96) investigate why this is failing\n        //(r#\"\"bytes\"\"#, r#\"\"\\u00FF\\u00FF\"\"#, Value::Bytes(vec![0xff, 0xff])),\n        (r#\"\"int\"\"#, \"5\", Value::Int(5)),\n        (r#\"\"long\"\"#, \"5\", Value::Long(5)),\n        (r#\"\"float\"\"#, \"1.1\", Value::Float(1.1)),\n        (r#\"\"double\"\"#, \"1.1\", Value::Double(1.1)),\n        // TODO: (#96) investigate why this is failing\n        //(r#\"{\"type\": \"fixed\", \"name\": \"F\", \"size\": 2}\"#, r#\"\"\\u00FF\\u00FF\"\"#, Value::Bytes(vec![0xff, 0xff])),\n        (r#\"{\"type\": \"enum\", \"name\": \"F\", \"symbols\": [\"FOO\", \"BAR\"]}\"#, r#\"\"FOO\"\"#, Value::Enum(0, \"FOO\".to_string())),\n        (r#\"{\"type\": \"array\", \"items\": \"int\"}\"#, \"[1, 2, 3]\", Value::Array(vec![Value::Int(1), Value::Int(2), Value::Int(3)])),\n        (r#\"{\"type\": \"map\", \"values\": \"int\"}\"#, r#\"{\"a\": 1, \"b\": 2}\"#, Value::Map([(\"a\".to_string(), Value::Int(1)), (\"b\".to_string(), Value::Int(2))].iter().cloned().collect())),\n        (r#\"[\"int\", \"null\"]\"#, \"5\", Value::Union(Box::new(Value::Int(5)))),\n        (r#\"{\"type\": \"record\", \"name\": \"F\", \"fields\": [{\"name\": \"A\", \"type\": \"int\"}]}\"#, r#\"{\"A\": 5}\"#,Value::Record(vec![(\"A\".to_string(), Value::Int(5))])),\n    ];\n\n    static ref LONG_RECORD_SCHEMA: Schema = Schema::parse_str(r#\"\n    {\n        \"type\": \"record\",\n        \"name\": \"Test\",\n        \"fields\": [\n            {\"name\": \"A\", \"type\": \"int\"},\n            {\"name\": \"B\", \"type\": \"int\"},\n            {\"name\": \"C\", \"type\": \"int\"},\n            {\"name\": \"D\", \"type\": \"int\"},\n            {\"name\": \"E\", \"type\": \"int\"},\n            {\"name\": \"F\", \"type\": \"int\"},\n            {\"name\": \"G\", \"type\": \"int\"}\n        ]\n    }\n    \"#).unwrap();\n\n    static ref LONG_RECORD_DATUM: Value = Value::Record(vec![\n        (\"A\".to_string(), Value::Int(1)),\n        (\"B\".to_string(), Value::Int(2)),\n        (\"C\".to_string(), Value::Int(3)),\n        (\"D\".to_string(), Value::Int(4)),\n        (\"E\".to_string(), Value::Int(5)),\n        (\"F\".to_string(), Value::Int(6)),\n        (\"G\".to_string(), Value::Int(7)),\n    ]);\n}\n\n#[test]\nfn test_validate() {\n    for (raw_schema, value) in SCHEMAS_TO_VALIDATE.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        assert!(\n            value.validate(&schema),\n            \"value {:?} does not validate schema: {}\",\n            value,\n            raw_schema\n        );\n    }\n}\n\n#[test]\nfn test_round_trip() {\n    for (raw_schema, value) in SCHEMAS_TO_VALIDATE.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        let encoded = to_avro_datum(&schema, value.clone()).unwrap();\n        let decoded = from_avro_datum(&schema, &mut Cursor::new(encoded), None).unwrap();\n        assert_eq!(value, &decoded);\n    }\n}\n\n#[test]\nfn test_binary_int_encoding() {\n    for (number, hex_encoding) in BINARY_ENCODINGS.iter() {\n        let encoded = to_avro_datum(&Schema::Int, Value::Int(*number as i32)).unwrap();\n        assert_eq!(&encoded, hex_encoding);\n    }\n}\n\n#[test]\nfn test_binary_long_encoding() {\n    for (number, hex_encoding) in BINARY_ENCODINGS.iter() {\n        let encoded = to_avro_datum(&Schema::Long, Value::Long(*number as i64)).unwrap();\n        assert_eq!(&encoded, hex_encoding);\n    }\n}\n\n#[test]\nfn test_schema_promotion() {\n    // Each schema is present in order of promotion (int -> long, long -> float, float -> double)\n    // Each value represents the expected decoded value when promoting a value previously encoded with a promotable schema\n    let promotable_schemas = vec![r#\"\"int\"\"#, r#\"\"long\"\"#, r#\"\"float\"\"#, r#\"\"double\"\"#];\n    let promotable_values = vec![\n        Value::Int(219),\n        Value::Long(219),\n        Value::Float(219.0),\n        Value::Double(219.0),\n    ];\n    for (i, writer_raw_schema) in promotable_schemas.iter().enumerate() {\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let original_value = &promotable_values[i];\n        for (j, reader_raw_schema) in promotable_schemas.iter().enumerate().skip(i + 1) {\n            let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n            let encoded = to_avro_datum(&writer_schema, original_value.clone()).unwrap();\n            let decoded = from_avro_datum(\n                &writer_schema,\n                &mut Cursor::new(encoded),\n                Some(&reader_schema),\n            )\n            .unwrap_or_else(|_| {\n                panic!(\n                    \"failed to decode {:?} with schema: {:?}\",\n                    original_value, reader_raw_schema,\n                )\n            });\n            assert_eq!(decoded, promotable_values[j]);\n        }\n    }\n}\n\n#[test]\nfn test_unknown_symbol() {\n    let writer_schema =\n        Schema::parse_str(r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"FOO\", \"BAR\"]}\"#)\n            .unwrap();\n    let reader_schema =\n        Schema::parse_str(r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"BAR\", \"BAZ\"]}\"#)\n            .unwrap();\n    let original_value = Value::Enum(0, \"FOO\".to_string());\n    let encoded = to_avro_datum(&writer_schema, original_value).unwrap();\n    let decoded = from_avro_datum(\n        &writer_schema,\n        &mut Cursor::new(encoded),\n        Some(&reader_schema),\n    );\n    assert!(decoded.is_err());\n}\n\n#[test]\nfn test_default_value() {\n    for (field_type, default_json, default_datum) in DEFAULT_VALUE_EXAMPLES.iter() {\n        let reader_schema = Schema::parse_str(&format!(\n            r#\"{{\n                \"type\": \"record\",\n                \"name\": \"Test\",\n                \"fields\": [\n                    {{\"name\": \"H\", \"type\": {}, \"default\": {}}}\n                ]\n            }}\"#,\n            field_type, default_json\n        ))\n        .unwrap();\n        let datum_to_read = Value::Record(vec![(\"H\".to_string(), default_datum.clone())]);\n        let encoded = to_avro_datum(&LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n        let datum_read = from_avro_datum(\n            &LONG_RECORD_SCHEMA,\n            &mut Cursor::new(encoded),\n            Some(&reader_schema),\n        )\n        .unwrap();\n        assert_eq!(\n            datum_read, datum_to_read,\n            \"{} -> {}\",\n            *field_type, *default_json\n        );\n    }\n}\n\n#[test]\nfn test_no_default_value() -> Result<(), Error> {\n    let reader_schema = Schema::parse_str(\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"Test\",\n            \"fields\": [\n                {\"name\": \"H\", \"type\": \"int\"}\n            ]\n        }\"#,\n    )\n    .unwrap();\n    let encoded = to_avro_datum(&LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n    let result = from_avro_datum(\n        &LONG_RECORD_SCHEMA,\n        &mut Cursor::new(encoded),\n        Some(&reader_schema),\n    );\n    assert!(result.is_err());\n    Ok(())\n}\n\n#[test]\nfn test_projection() {\n    let reader_schema = Schema::parse_str(\n        r#\"\n        {\n            \"type\": \"record\",\n            \"name\": \"Test\",\n            \"fields\": [\n                {\"name\": \"E\", \"type\": \"int\"},\n                {\"name\": \"F\", \"type\": \"int\"}\n            ]\n        }\n    \"#,\n    )\n    .unwrap();\n    let datum_to_read = Value::Record(vec![\n        (\"E\".to_string(), Value::Int(5)),\n        (\"F\".to_string(), Value::Int(6)),\n    ]);\n    let encoded = to_avro_datum(&LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n    let datum_read = from_avro_datum(\n        &LONG_RECORD_SCHEMA,\n        &mut Cursor::new(encoded),\n        Some(&reader_schema),\n    )\n    .unwrap();\n    assert_eq!(datum_to_read, datum_read);\n}\n\n#[test]\nfn test_field_order() {\n    let reader_schema = Schema::parse_str(\n        r#\"\n        {\n            \"type\": \"record\",\n            \"name\": \"Test\",\n            \"fields\": [\n                {\"name\": \"F\", \"type\": \"int\"},\n                {\"name\": \"E\", \"type\": \"int\"}\n            ]\n        }\n    \"#,\n    )\n    .unwrap();\n    let datum_to_read = Value::Record(vec![\n        (\"F\".to_string(), Value::Int(6)),\n        (\"E\".to_string(), Value::Int(5)),\n    ]);\n    let encoded = to_avro_datum(&LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n    let datum_read = from_avro_datum(\n        &LONG_RECORD_SCHEMA,\n        &mut Cursor::new(encoded),\n        Some(&reader_schema),\n    )\n    .unwrap();\n    assert_eq!(datum_to_read, datum_read);\n}\n\n#[test]\nfn test_type_exception() -> Result<(), String> {\n    let writer_schema = Schema::parse_str(\n        r#\"\n        {\n             \"type\": \"record\",\n             \"name\": \"Test\",\n             \"fields\": [\n                {\"name\": \"F\", \"type\": \"int\"},\n                {\"name\": \"E\", \"type\": \"int\"}\n             ]\n        }\n    \"#,\n    )\n    .unwrap();\n    let datum_to_write = Value::Record(vec![\n        (\"E\".to_string(), Value::Int(5)),\n        (\"F\".to_string(), Value::String(String::from(\"Bad\"))),\n    ]);\n    let encoded = to_avro_datum(&writer_schema, datum_to_write);\n    match encoded {\n        Ok(_) => Err(String::from(\"Expected ValidationError, got Ok\")),\n        Err(Error::Validation) => Ok(()),\n        Err(ref e) => Err(format!(\"Expected ValidationError, got {}\", e)),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","tests","schema.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Port of https://github.com/apache/avro/blob/release-1.9.1/lang/py/test/test_schema.py\nuse avro_rs::{schema::Name, Error, Schema};\nuse lazy_static::lazy_static;\n\nconst PRIMITIVE_EXAMPLES: &[(&str, bool)] = &[\n    (r#\"\"null\"\"#, true),\n    (r#\"{\"type\": \"null\"}\"#, true),\n    (r#\"\"boolean\"\"#, true),\n    (r#\"{\"type\": \"boolean\"}\"#, true),\n    (r#\"\"string\"\"#, true),\n    (r#\"{\"type\": \"string\"}\"#, true),\n    (r#\"\"bytes\"\"#, true),\n    (r#\"{\"type\": \"bytes\"}\"#, true),\n    (r#\"\"int\"\"#, true),\n    (r#\"{\"type\": \"int\"}\"#, true),\n    (r#\"\"long\"\"#, true),\n    (r#\"{\"type\": \"long\"}\"#, true),\n    (r#\"\"float\"\"#, true),\n    (r#\"{\"type\": \"float\"}\"#, true),\n    (r#\"\"double\"\"#, true),\n    (r#\"{\"type\": \"double\"}\"#, true),\n    (r#\"\"true\"\"#, false),\n    (r#\"true\"#, false),\n    (r#\"{\"no_type\": \"test\"}\"#, false),\n    (r#\"{\"type\": \"panther\"}\"#, false),\n];\n\nconst FIXED_EXAMPLES: &[(&str, bool)] = &[\n    (r#\"{\"type\": \"fixed\", \"name\": \"Test\", \"size\": 1}\"#, true),\n    (\n        r#\"{\n                \"type\": \"fixed\",\n                \"name\": \"MyFixed\",\n                \"namespace\": \"org.apache.hadoop.avro\",\n                \"size\": 1\n            }\"#,\n        true,\n    ),\n    (r#\"{\"type\": \"fixed\", \"name\": \"Missing size\"}\"#, false),\n    (r#\"{\"type\": \"fixed\", \"size\": 314}\"#, false),\n];\n\nconst ENUM_EXAMPLES: &[(&str, bool)] = &[\n    (\n        r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\"#,\n        true,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                \"name\": \"Status\",\n                \"symbols\": \"Normal Caution Critical\"\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                \"name\": [ 0, 1, 1, 2, 3, 5, 8 ],\n                \"symbols\": [\"Golden\", \"Mean\"]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                \"symbols\" : [\"I\", \"will\", \"fail\", \"no\", \"name\"]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                 \"name\": \"Test\"\n                 \"symbols\" : [\"AA\", \"AA\"]\n            }\"#,\n        false,\n    ),\n];\n\nconst ARRAY_EXAMPLES: &[(&str, bool)] = &[\n    (r#\"{\"type\": \"array\", \"items\": \"long\"}\"#, true),\n    (\n        r#\"{\n                \"type\": \"array\",\n                 \"items\": {\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\n            }\"#,\n        true,\n    ),\n];\n\nconst MAP_EXAMPLES: &[(&str, bool)] = &[\n    (r#\"{\"type\": \"map\", \"values\": \"long\"}\"#, true),\n    (\n        r#\"{\n                \"type\": \"map\",\n                \"values\": {\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\n            }\"#,\n        true,\n    ),\n];\n\nconst UNION_EXAMPLES: &[(&str, bool)] = &[\n    (r#\"[\"string\", \"null\", \"long\"]\"#, true),\n    (r#\"[\"null\", \"null\"]\"#, false),\n    (r#\"[\"long\", \"long\"]\"#, false),\n    (\n        r#\"[\n                {\"type\": \"array\", \"items\": \"long\"}\n                {\"type\": \"array\", \"items\": \"string\"}\n            ]\"#,\n        false,\n    ),\n];\n\nconst RECORD_EXAMPLES: &[(&str, bool)] = &[\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"Test\",\n                \"fields\": [{\"name\": \"f\", \"type\": \"long\"}]\n            }\"#,\n        true,\n    ),\n    /*\n    // TODO: (#91) figure out why \"type\": \"error\" seems to be valid (search in spec) and uncomment\n    (\n        r#\"{\n            \"type\": \"error\",\n            \"name\": \"Test\",\n            \"fields\": [{\"name\": \"f\", \"type\": \"long\"}]\n        }\"#,\n        true\n    ),\n    */\n    /*\n    // TODO: (#92) properly support recursive types and uncomment\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"Node\",\n            \"fields\": [\n                {\"name\": \"label\", \"type\": \"string\"},\n                {\"name\": \"children\", \"type\": {\"type\": \"array\", \"items\": \"Node\"}}\n            ]\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"Lisp\",\n            \"fields\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": [\n                        \"null\", \"string\",\n                        {\n                            \"type\": \"record\",\n                            \"name\": \"Cons\",\n                            \"fields\": [\n                                {\"name\": \"car\", \"type\": \"Lisp\"},\n                                {\"name\": \"cdr\", \"type\": \"Lisp\"}\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"HandshakeRequest\",\n            \"namespace\": \"org.apache.avro.ipc\",\n            \"fields\": [\n                {\"name\": \"clientHash\", \"type\": {\"type\": \"fixed\", \"name\": \"MD5\", \"size\": 16}},\n                {\"name\": \"clientProtocol\", \"type\": [\"null\", \"string\"]},\n                {\"name\": \"serverHash\", \"type\": \"MD5\"},\n                {\"name\": \"meta\", \"type\": [\"null\", {\"type\": \"map\", \"values\": \"bytes\"}]}\n            ]\n        }\"#, true\n    ),\n    */\n    (\n        r#\"{\n                \"type\":\"record\",\n                \"name\":\"HandshakeResponse\",\n                \"namespace\":\"org.apache.avro.ipc\",\n                \"fields\":[\n                    {\n                        \"name\":\"match\",\n                        \"type\":{\n                           \"type\":\"enum\",\n                           \"name\":\"HandshakeMatch\",\n                           \"symbols\":[\"BOTH\", \"CLIENT\", \"NONE\"]\n                        }\n                    },\n                    {\"name\":\"serverProtocol\", \"type\":[\"null\", \"string\"]},\n                    {\n                        \"name\":\"serverHash\",\n                        \"type\":[\"null\", {\"name\":\"MD5\", \"size\":16, \"type\":\"fixed\"}]\n                    },\n                    {\n                        \"name\":\"meta\",\n                        \"type\":[\"null\", {\"type\":\"map\", \"values\":\"bytes\"}]\n                    }\n                ]\n            }\"#,\n        true,\n    ),\n    (\n        r#\"{\n                \"type\":\"record\",\n                \"name\":\"HandshakeResponse\",\n                \"namespace\":\"org.apache.avro.ipc\",\n                \"fields\":[\n                    {\n                        \"name\":\"match\",\n                        \"type\":{\n                            \"type\":\"enum\",\n                            \"name\":\"HandshakeMatch\",\n                            \"symbols\":[\"BOTH\", \"CLIENT\", \"NONE\"]\n                        }\n                    },\n                    {\"name\":\"serverProtocol\", \"type\":[\"null\", \"string\"]},\n                    {\n                        \"name\":\"serverHash\",\n                        \"type\":[\"null\", { \"name\":\"MD5\", \"size\":16, \"type\":\"fixed\"}]\n                    },\n                    {\"name\":\"meta\", \"type\":[\"null\", { \"type\":\"map\", \"values\":\"bytes\"}]}\n                ]\n            }\"#,\n        true,\n    ),\n    /*\n    // TODO: (#95) support same types but with different names in unions and uncomment (below the explanation)\n\n    // Unions may not contain more than one schema with the same type, except for the named\n    // types record, fixed and enum. For example, unions containing two array types or two map\n    // types are not permitted, but two types with different names are permitted.\n    // (Names permit efficient resolution when reading and writing unions.)\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"ipAddr\",\n            \"fields\": [\n                {\n                    \"name\": \"addr\",\n                    \"type\": [\n                        {\"name\": \"IPv6\", \"type\": \"fixed\", \"size\": 16},\n                        {\"name\": \"IPv4\", \"type\": \"fixed\", \"size\": 4}\n                    ]\n                }\n            ]\n        }\"#,\n        true\n    ),\n    */\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"Address\",\n                \"fields\": [\n                    {\"type\": \"string\"},\n                    {\"type\": \"string\", \"name\": \"City\"}\n                ]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"Event\",\n                \"fields\": [{\"name\": \"Sponsor\"}, {\"name\": \"City\", \"type\": \"string\"}]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"fields\": \"His vision, from the constantly passing bars,\"\n                \"name\",\n                \"Rainer\"\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"name\": [\"Tom\", \"Jerry\"],\n                \"type\": \"record\",\n                \"fields\": [{\"name\": \"name\", \"type\": \"string\"}]\n            }\"#,\n        false,\n    ),\n];\n\nconst DOC_EXAMPLES: &[(&str, bool)] = &[\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"TestDoc\",\n                \"doc\":  \"Doc string\",\n                \"fields\": [{\"name\": \"name\", \"type\": \"string\", \"doc\" : \"Doc String\"}]\n            }\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"], \"doc\": \"Doc String\"}\"#,\n        true,\n    ),\n];\n\nconst OTHER_ATTRIBUTES_EXAMPLES: &[(&str, bool)] = &[\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"TestRecord\",\n                \"cp_string\": \"string\",\n                \"cp_int\": 1,\n                \"cp_array\": [ 1, 2, 3, 4],\n                \"fields\": [\n                    {\"name\": \"f1\", \"type\": \"string\", \"cp_object\": {\"a\":1,\"b\":2}},\n                    {\"name\": \"f2\", \"type\": \"long\", \"cp_null\": null}\n                ]\n            }\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"map\", \"values\": \"long\", \"cp_boolean\": true}\"#,\n        true,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                 \"name\": \"TestEnum\",\n                 \"symbols\": [ \"one\", \"two\", \"three\" ],\n                 \"cp_float\" : 1.0\n            }\"#,\n        true,\n    ),\n    (r#\"{\"type\": \"long\", \"date\": \"true\"}\"#, true),\n];\n\nconst DECIMAL_LOGICAL_TYPE: &[(&str, bool)] = &[\n    /*\n    // TODO: (#93) support logical types and uncomment\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 4,\n            \"size\": 10,\n            \"scale\": 2\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 4,\n            \"scale\": 2\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 2,\n            \"scale\": -2\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": -2,\n            \"scale\": 2\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 2,\n            \"scale\": 3\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": -10,\n            \"scale\": 2,\n            \"size\": 5\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 2,\n            \"scale\": 3,\n            \"size\": 2\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 2,\n            \"scale\": 2,\n            \"size\": -2\n        }\"#,\n        false\n    ),\n    */\n];\n\nconst DECIMAL_LOGICAL_TYPE_ATTRIBUTES: &[(&str, bool)] = &[\n    /*\n    // TODO: (#93) support logical types and attributes and uncomment\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 4,\n            \"scale\": 2,\n            \"size\": 2\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 4\n        }\"#,\n        true\n    ),\n    */\n];\n\nconst DATE_LOGICAL_TYPE: &[(&str, bool)] = &[\n    (r#\"{\"type\": \"int\", \"logicalType\": \"date\"}\"#, true),\n    // this is valid even though its logical type is \"date1\", because unknown logical types are\n    // ignored\n    (r#\"{\"type\": \"int\", \"logicalType\": \"date1\"}\"#, true),\n    (r#\"{\"type\": \"long\", \"logicalType\": \"date\"}\"#, false),\n];\n\nconst TIMEMILLIS_LOGICAL_TYPE: &[(&str, bool)] = &[\n    (r#\"{\"type\": \"int\", \"logicalType\": \"time-millis\"}\"#, true),\n    // this is valid even though its logical type is \"time-milis\" (missing the second \"l\"),\n    // because unknown logical types are ignored\n    (r#\"{\"type\": \"int\", \"logicalType\": \"time-milis\"}\"#, true),\n    (r#\"{\"type\": \"long\", \"logicalType\": \"time-millis\"}\"#, false),\n];\n\nconst TIMEMICROS_LOGICAL_TYPE: &[(&str, bool)] = &[\n    (r#\"{\"type\": \"long\", \"logicalType\": \"time-micros\"}\"#, true),\n    // this is valid even though its logical type is \"time-micro\" (missing the last \"s\"), because\n    // unknown logical types are ignored\n    (r#\"{\"type\": \"long\", \"logicalType\": \"time-micro\"}\"#, true),\n    (r#\"{\"type\": \"int\", \"logicalType\": \"time-micros\"}\"#, false),\n];\n\nconst TIMESTAMPMILLIS_LOGICAL_TYPE: &[(&str, bool)] = &[\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\"#,\n        true,\n    ),\n    // this is valid even though its logical type is \"timestamp-milis\" (missing the second \"l\"), because\n    // unknown logical types are ignored\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-milis\"}\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"int\", \"logicalType\": \"timestamp-millis\"}\"#,\n        false,\n    ),\n];\n\nconst TIMESTAMPMICROS_LOGICAL_TYPE: &[(&str, bool)] = &[\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\"#,\n        true,\n    ),\n    // this is valid even though its logical type is \"timestamp-micro\" (missing the last \"s\"), because\n    // unknown logical types are ignored\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micro\"}\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"int\", \"logicalType\": \"timestamp-micros\"}\"#,\n        false,\n    ),\n];\n\nlazy_static! {\n    static ref EXAMPLES: Vec<(&'static str, bool)> = Vec::new()\n        .iter()\n        .copied()\n        .chain(PRIMITIVE_EXAMPLES.iter().copied())\n        .chain(FIXED_EXAMPLES.iter().copied())\n        .chain(ENUM_EXAMPLES.iter().copied())\n        .chain(ARRAY_EXAMPLES.iter().copied())\n        .chain(MAP_EXAMPLES.iter().copied())\n        .chain(UNION_EXAMPLES.iter().copied())\n        .chain(RECORD_EXAMPLES.iter().copied())\n        .chain(DOC_EXAMPLES.iter().copied())\n        .chain(OTHER_ATTRIBUTES_EXAMPLES.iter().copied())\n        .chain(DECIMAL_LOGICAL_TYPE.iter().copied())\n        .chain(DECIMAL_LOGICAL_TYPE_ATTRIBUTES.iter().copied())\n        .chain(DATE_LOGICAL_TYPE.iter().copied())\n        .chain(TIMEMILLIS_LOGICAL_TYPE.iter().copied())\n        .chain(TIMEMICROS_LOGICAL_TYPE.iter().copied())\n        .chain(TIMESTAMPMILLIS_LOGICAL_TYPE.iter().copied())\n        .chain(TIMESTAMPMICROS_LOGICAL_TYPE.iter().copied())\n        .collect();\n    static ref VALID_EXAMPLES: Vec<(&'static str, bool)> =\n        EXAMPLES.iter().copied().filter(|s| s.1).collect();\n}\n\n/*\n// TODO: (#92) properly support recursive types and uncomment\n\nThis test is failing unwrapping the outer schema with ParseSchemaError(\"Unknown type: X\"). It seems\nthat recursive types are not properly supported.\n\n#[test]\nfn test_correct_recursive_extraction() {\n    let raw_outer_schema = r#\"{\n        \"type\": \"record\",\n        \"name\": \"X\",\n        \"fields\": [\n            {\n                \"name\": \"y\",\n                \"type\": {\n                    \"type\": \"record\",\n                    \"name\": \"Y\",\n                    \"fields\": [\n                        {\n                            \"name\": \"Z\",\n                            \"type\": \"X\"\n                        }\n                    ]\n                }\n            }\n        ]\n    }\"#;\n    let outer_schema = Schema::parse_str(raw_outer_schema).unwrap();\n    if let Schema::Record { fields: outer_fields, .. } = outer_schema {\n        let raw_inner_schema = outer_fields[0].schema.canonical_form();\n        let inner_schema = Schema::parse_str(raw_inner_schema.as_str()).unwrap();\n        if let Schema::Record { fields: inner_fields, .. } = inner_schema {\n            if let Schema::Record {name: recursive_type, .. } = &inner_fields[0].schema {\n                assert_eq!(\"X\", recursive_type.name.as_str());\n            }\n        } else {\n            panic!(\"inner schema {} should have been a record\", raw_inner_schema)\n        }\n    } else {\n        panic!(\"outer schema {} should have been a record\", raw_outer_schema)\n    }\n}\n*/\n\n#[test]\nfn test_parse() {\n    for (raw_schema, valid) in EXAMPLES.iter() {\n        let schema = Schema::parse_str(raw_schema);\n        if *valid {\n            assert!(\n                schema.is_ok(),\n                \"schema {} was supposed to be valid; error: {:?}\",\n                raw_schema,\n                schema,\n            )\n        } else {\n            assert!(\n                schema.is_err(),\n                \"schema {} was supposed to be invalid\",\n                raw_schema\n            )\n        }\n    }\n}\n\n#[test]\n/// Test that the string generated by an Avro Schema object is, in fact, a valid Avro schema.\nfn test_valid_cast_to_string_after_parse() {\n    for (raw_schema, _) in VALID_EXAMPLES.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        Schema::parse_str(schema.canonical_form().as_str()).unwrap();\n    }\n}\n\n#[test]\n/// 1. Given a string, parse it to get Avro schema \"original\".\n/// 2. Serialize \"original\" to a string and parse that string to generate Avro schema \"round trip\".\n/// 3. Ensure \"original\" and \"round trip\" schemas are equivalent.\nfn test_equivalence_after_round_trip() {\n    for (raw_schema, _) in VALID_EXAMPLES.iter() {\n        let original_schema = Schema::parse_str(raw_schema).unwrap();\n        let round_trip_schema =\n            Schema::parse_str(original_schema.canonical_form().as_str()).unwrap();\n        assert_eq!(original_schema, round_trip_schema);\n    }\n}\n\n#[test]\n/// Test that a list of schemas whose definitions do not depend on each other produces the same\n/// result as parsing each element of the list individually\nfn test_parse_list_without_cross_deps() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"fixed\",\n        \"size\": 16\n    }\"#;\n    let schema_strs = [schema_str_1, schema_str_2];\n    let schemas = Schema::parse_list(&schema_strs).expect(\"Test failed\");\n\n    for schema_str in &schema_strs {\n        let parsed = Schema::parse_str(schema_str).expect(\"Test failed\");\n        assert!(schemas.contains(&parsed));\n    }\n}\n\n#[test]\n/// Test that the parsing of a list of schemas, whose definitions do depend on each other, can\n/// perform the necessary schema composition. This should work regardless of the order in which\n/// the schemas are input.\n/// However, the output order is guaranteed to be the same as the input order.\nfn test_parse_list_with_cross_deps_basic() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"A\"}\n        ]\n    }\"#;\n    let schema_composite = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n            \"type\": {\n                \"name\": \"A\",\n                \"type\": \"record\",\n                \"fields\": [\n                    {\"name\": \"field_one\", \"type\": \"float\"}\n                    ]\n                }\n            }\n        ]\n\n    }\"#;\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let schemas_first = Schema::parse_list(&schema_strs_first).expect(\"Test failed\");\n    let schemas_second = Schema::parse_list(&schema_strs_second).expect(\"Test failed\");\n\n    let parsed_1 = Schema::parse_str(schema_str_1).expect(\"Test failed\");\n    let parsed_2 = Schema::parse_str(schema_composite).expect(\"Test failed\");\n    assert_eq!(schemas_first, vec!(parsed_1.clone(), parsed_2.clone()));\n    assert_eq!(schemas_second, vec!(parsed_2, parsed_1));\n}\n\n#[test]\n/// Test that if a cycle of dependencies occurs in the input schema jsons, the algorithm terminates\n/// and returns an error. N.B. In the future, when recursive types are supported, this should be\n/// revisited.\nfn test_parse_list_recursive_type_error() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"B\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"A\"}\n        ]\n    }\"#;\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let _ = Schema::parse_list(&schema_strs_first).expect_err(\"Test failed\");\n    let _ = Schema::parse_list(&schema_strs_second).expect_err(\"Test failed\");\n}\n\n#[test]\n/// Test that schema composition resolves namespaces.\nfn test_parse_list_with_cross_deps_and_namespaces() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"namespace\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"namespace.A\"}\n        ]\n    }\"#;\n    let schema_composite = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n            \"type\": {\n                \"name\": \"A\",\n                \"type\": \"record\",\n                \"namespace\": \"namespace\",\n                \"fields\": [\n                    {\"name\": \"field_one\", \"type\": \"float\"}\n                    ]\n                }\n            }\n        ]\n    }\"#;\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let schemas_first = Schema::parse_list(&schema_strs_first).expect(\"Test failed\");\n    let schemas_second = Schema::parse_list(&schema_strs_second).expect(\"Test failed\");\n\n    let parsed_1 = Schema::parse_str(schema_str_1).expect(\"Test failed\");\n    let parsed_2 = Schema::parse_str(schema_composite).expect(\"Test failed\");\n    assert_eq!(schemas_first, vec!(parsed_1.clone(), parsed_2.clone()));\n    assert_eq!(schemas_second, vec!(parsed_2, parsed_1));\n}\n\n#[test]\n/// Test that schema composition fails on namespace errors.\nfn test_parse_list_with_cross_deps_and_namespaces_error() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"namespace\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"A\"}\n        ]\n    }\"#;\n\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let _ = Schema::parse_list(&schema_strs_first).expect_err(\"Test failed\");\n    let _ = Schema::parse_list(&schema_strs_second).expect_err(\"Test failed\");\n}\n\n/// Return all permutations of an input slice\nfn permutations<T>(list: &[T]) -> Vec<Vec<&T>> {\n    let size = list.len();\n    let indices = permutation_indices((0..size).collect());\n    let mut perms = Vec::new();\n    for perm_map in &indices {\n        let mut perm = Vec::new();\n        for ix in perm_map {\n            perm.push(&list[*ix]);\n        }\n        perms.push(perm)\n    }\n    perms\n}\n\n/// Return all permutations of the indices of a vector\nfn permutation_indices(indices: Vec<usize>) -> Vec<Vec<usize>> {\n    let size = indices.len();\n    let mut perms: Vec<Vec<usize>> = Vec::new();\n    if size == 1 {\n        perms.push(indices);\n        return perms;\n    }\n    for index in 0..size {\n        let (head, tail) = indices.split_at(index);\n        let (first, rest) = tail.split_at(1);\n        let mut head = head.to_vec();\n        head.extend_from_slice(rest);\n        for mut sub_index in permutation_indices(head) {\n            sub_index.insert(0, first[0]);\n            perms.push(sub_index);\n        }\n    }\n\n    perms\n}\n\n#[test]\n/// Test that a type that depends on more than one other type is parsed correctly when all\n/// definitions are passed in as a list. This should work regardless of the ordering of the list.\nfn test_parse_list_multiple_dependencies() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": [\"null\", \"B\", \"C\"]}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"fixed\",\n        \"size\": 16\n    }\"#;\n    let schema_str_3 = r#\"{\n        \"name\": \"C\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"string\"}\n        ]\n    }\"#;\n    let schema_composite = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\n                \"name\": \"field_one\",\n                \"type\":  [\n                    \"null\",\n                    {\n                        \"name\": \"B\",\n                        \"type\": \"fixed\",\n                        \"size\": 16\n                    },\n                    {\n                        \"name\": \"C\",\n                        \"type\": \"record\",\n                        \"fields\": [\n                            {\"name\": \"field_one\", \"type\": \"string\"}\n                        ]\n                    }\n                ]\n            }\n        ]\n    }\"#;\n\n    let parsed = vec![\n        Schema::parse_str(schema_str_2).expect(\"Test failed\"),\n        Schema::parse_str(schema_str_3).expect(\"Test failed\"),\n        Schema::parse_str(schema_composite).expect(\"Test failed\"),\n    ];\n    let schema_strs = vec![schema_str_1, schema_str_2, schema_str_3];\n    for schema_str_perm in permutations(&schema_strs) {\n        let schema_str_perm: Vec<&str> = schema_str_perm.iter().map(|s| **s).collect();\n        let schemas = Schema::parse_list(&schema_str_perm).expect(\"Test failed\");\n        assert_eq!(schemas.len(), 3);\n        for parsed_schema in &parsed {\n            assert!(schemas.contains(parsed_schema));\n        }\n    }\n}\n\n#[test]\n/// Test that a type that is depended on by more than one other type is parsed correctly when all\n/// definitions are passed in as a list. This should work regardless of the ordering of the list.\nfn test_parse_list_shared_dependency() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": {\"type\": \"array\", \"items\": \"C\"}}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": {\"type\": \"map\", \"values\": \"C\"}}\n        ]\n    }\"#;\n    let schema_str_3 = r#\"{\n        \"name\": \"C\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"string\"}\n        ]\n    }\"#;\n    let schema_composite_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n              \"type\": {\"type\": \"array\",\n                       \"items\": {\n                            \"name\": \"C\",\n                            \"type\": \"record\",\n                            \"fields\": [\n                                {\"name\": \"field_one\", \"type\": \"string\"}\n                                ]\n                            }\n                      }\n            }\n        ]\n    }\"#;\n    let schema_composite_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n              \"type\": {\"type\": \"map\",\n                       \"values\": {\n                            \"name\": \"C\",\n                            \"type\":  \"record\",\n                            \"fields\": [\n                                {\"name\": \"field_one\", \"type\": \"string\"}\n                                ]\n                            }\n                      }\n                 }\n            ]\n    }\"#;\n\n    let parsed = vec![\n        Schema::parse_str(schema_str_3).expect(\"Test failed\"),\n        Schema::parse_str(schema_composite_1).expect(\"Test failed\"),\n        Schema::parse_str(schema_composite_2).expect(\"Test failed\"),\n    ];\n    let schema_strs = vec![schema_str_1, schema_str_2, schema_str_3];\n    for schema_str_perm in permutations(&schema_strs) {\n        let schema_str_perm: Vec<&str> = schema_str_perm.iter().map(|s| **s).collect();\n        let schemas = Schema::parse_list(&schema_str_perm).expect(\"Test failed\");\n        assert_eq!(schemas.len(), 3);\n        for parsed_schema in &parsed {\n            assert!(schemas.contains(parsed_schema));\n        }\n    }\n}\n\n#[test]\n/// Test that trying to parse two schemas with the same fullname returns an Error\nfn test_name_collision_error() {\n    let schema_str_1 = r#\"{\n        \"name\": \"foo.A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"double\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"foo\",\n        \"fields\": [\n            {\"name\": \"field_two\", \"type\": \"string\"}\n        ]\n    }\"#;\n\n    let _ = Schema::parse_list(&[schema_str_1, schema_str_2]).expect_err(\"Test failed\");\n}\n\n#[test]\n/// Test that having the same name but different fullnames does not return an error\nfn test_namespace_prevents_collisions() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"double\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"foo\",\n        \"fields\": [\n            {\"name\": \"field_two\", \"type\": \"string\"}\n        ]\n    }\"#;\n\n    let parsed = Schema::parse_list(&[schema_str_1, schema_str_2]).expect(\"Test failed\");\n    let parsed_1 = Schema::parse_str(schema_str_1).expect(\"Test failed\");\n    let parsed_2 = Schema::parse_str(schema_str_2).expect(\"Test failed\");\n    assert_eq!(parsed, vec!(parsed_1, parsed_2));\n}\n\n// The fullname is determined in one of the following ways:\n//  * A name and namespace are both specified.  For example,\n//    one might use \"name\": \"X\", \"namespace\": \"org.foo\"\n//    to indicate the fullname \"org.foo.X\".\n//  * A fullname is specified.  If the name specified contains\n//    a dot, then it is assumed to be a fullname, and any\n//    namespace also specified is ignored.  For example,\n//    use \"name\": \"org.foo.X\" to indicate the\n//    fullname \"org.foo.X\".\n//  * A name only is specified, i.e., a name that contains no\n//    dots.  In this case the namespace is taken from the most\n//    tightly enclosing schema or protocol.  For example,\n//    if \"name\": \"X\" is specified, and this occurs\n//    within a field of the record definition ///    of \"org.foo.Y\", then the fullname is \"org.foo.X\".\n\n// References to previously defined names are as in the latter\n// two cases above: if they contain a dot they are a fullname, if\n// they do not contain a dot, the namespace is the namespace of\n// the enclosing definition.\n\n// Primitive type names have no namespace and their names may\n// not be defined in any namespace. A schema may only contain\n// multiple definitions of a fullname if the definitions are\n// equivalent.\n\n#[test]\nfn test_fullname_name_and_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a\", \"namespace\": \"o.a.h\", \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(None);\n    assert_eq!(\"o.a.h.a\", fullname);\n}\n\n#[test]\nfn test_fullname_fullname_and_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a.b.c.d\", \"namespace\": \"o.a.h\", \"aliases\": null}\"#)\n            .unwrap();\n    let fullname = name.fullname(None);\n    assert_eq!(\"a.b.c.d\", fullname);\n}\n\n#[test]\nfn test_fullname_name_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a\", \"namespace\": null, \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(Some(\"b.c.d\"));\n    assert_eq!(\"b.c.d.a\", fullname);\n}\n\n#[test]\nfn test_fullname_fullname_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a.b.c.d\", \"namespace\": null, \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(Some(\"o.a.h\"));\n    assert_eq!(\"a.b.c.d\", fullname);\n}\n\n#[test]\nfn test_fullname_fullname_namespace_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a.b.c.d\", \"namespace\": \"o.a.a\", \"aliases\": null}\"#)\n            .unwrap();\n    let fullname = name.fullname(Some(\"o.a.h\"));\n    assert_eq!(\"a.b.c.d\", fullname);\n}\n\n#[test]\nfn test_fullname_name_namespace_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a\", \"namespace\": \"o.a.a\", \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(Some(\"o.a.h\"));\n    assert_eq!(\"o.a.a.a\", fullname);\n}\n\n#[test]\nfn test_doc_attributes() {\n    fn assert_doc(schema: &Schema) {\n        match schema {\n            Schema::Enum { doc, .. } => assert!(doc.is_some()),\n            Schema::Record { doc, .. } => assert!(doc.is_some()),\n            _ => (),\n        }\n    }\n\n    for (raw_schema, _) in DOC_EXAMPLES.iter() {\n        let original_schema = Schema::parse_str(raw_schema).unwrap();\n        assert_doc(&original_schema);\n        if let Schema::Record { fields, .. } = original_schema {\n            for f in fields {\n                assert_doc(&f.schema)\n            }\n        }\n    }\n}\n\n/*\nTODO: (#94) add support for user-defined attributes and uncomment (may need some tweaks to compile)\n#[test]\nfn test_other_attributes() {\n    fn assert_attribute_type(attribute: (String, serde_json::Value)) {\n        match attribute.1.as_ref() {\n            \"cp_boolean\" => assert!(attribute.2.is_bool()),\n            \"cp_int\" => assert!(attribute.2.is_i64()),\n            \"cp_object\" => assert!(attribute.2.is_object()),\n            \"cp_float\" => assert!(attribute.2.is_f64()),\n            \"cp_array\" => assert!(attribute.2.is_array()),\n        }\n    }\n\n    for (raw_schema, _) in OTHER_ATTRIBUTES_EXAMPLES.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        // all inputs have at least some user-defined attributes\n        assert!(schema.other_attributes.is_some());\n        for prop in schema.other_attributes.unwrap().iter() {\n            assert_attribute_type(prop);\n        }\n        if let Schema::Record { fields, .. } = schema {\n           for f in fields {\n               // all fields in the record have at least some user-defined attributes\n               assert!(f.schema.other_attributes.is_some());\n               for prop in f.schema.other_attributes.unwrap().iter() {\n                   assert_attribute_type(prop);\n               }\n           }\n        }\n    }\n}\n*/\n\n#[test]\nfn test_root_error_is_not_swallowed_on_parse_error() -> Result<(), String> {\n    let raw_schema = r#\"/not/a/real/file\"#;\n    let error = Schema::parse_str(raw_schema).unwrap_err();\n\n    if let Error::ParseSchemaJson(e) = error {\n        assert!(\n            e.to_string().contains(\"expected value at line 1 column 1\"),\n            \"{}\",\n            e\n        );\n        Ok(())\n    } else {\n        Err(format!(\n            \"Expected serde_json::error::Error, got {:?}\",\n            error\n        ))\n    }\n}\n\n/*\n// TODO: (#93) add support for logical type and attributes and uncomment (may need some tweaks to compile)\n#[test]\nfn test_decimal_valid_type_attributes() {\n    let fixed_decimal = Schema::parse_str(DECIMAL_LOGICAL_TYPE_ATTRIBUTES[0]).unwrap();\n    assert_eq!(4, fixed_decimal.get_attribute(\"precision\"));\n    assert_eq!(2, fixed_decimal.get_attribute(\"scale\"));\n    assert_eq!(2, fixed_decimal.get_attribute(\"size\"));\n\n    let bytes_decimal = Schema::parse_str(DECIMAL_LOGICAL_TYPE_ATTRIBUTES[1]).unwrap();\n    assert_eq!(4, bytes_decimal.get_attribute(\"precision\"));\n    assert_eq!(0, bytes_decimal.get_attribute(\"scale\"));\n}\n*/\n","traces":[{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","huolinhe","Projects","taosdata","taosx","mdsn","src","lib.rs"],"content":"//! M-DSN: A Multi-address DSN(Data Source Name) parser.\n//!\n//! M-DSN support two kind of DSN format:\n//!\n//! 1. `<driver>[+<protocol>]://<username>:<password>@<addresses>/<database>?<params>`\n//! 2. `<driver>[+<protocol>]://<username>:<password>@<fragment>?<params>`\n//! 3. `<driver>://<username>:<password>@<protocol>(<addresses>)/<database>?<params>`\n//!\n//! All the items will be parsed into struct [Dsn](crate::Dsn).\n//!\n//! ## Parser\n//!\n//! ```rust\n//! use mdsn::Dsn;\n//!\n//! # fn main() -> Result<(), mdsn::DsnError> {\n//! // The two styles are equivalent.\n//! let dsn = Dsn::parse(\"taos://root:taosdata@host1:6030,host2:6030/db\")?;\n//! let dsn: Dsn = \"taos://root:taosdata@host1:6030,host2:6030/db\".parse()?;\n//!\n//! assert_eq!(dsn.driver, \"taos\");\n//! assert_eq!(dsn.username.unwrap(), \"root\");\n//! assert_eq!(dsn.password.unwrap(), \"taosdata\");\n//! assert_eq!(dsn.database.unwrap(), \"db\");\n//! assert_eq!(dsn.addresses.len(), 2);\n//! assert_eq!(dsn.addresses, vec![\n//!     mdsn::Address::new(\"host1\", 6030),\n//!     mdsn::Address::new(\"host2\", 6030),\n//! ]);\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! ## DSN Examples\n//!\n//! A DSN for [TDengine](https://taosdata.com) driver [taos](https://docs.rs/taos).\n//!\n//! ```dsn\n//! taos://root:taosdata@localhost:6030/db?timezone=Asia/Shanghai&asyncLog=1\n//! ```\n//!\n//! With multi-address:\n//!\n//! ```dsn\n//! taos://root:taosdata@host1:6030,host2:6030/db?timezone=Asia/Shanghai\n//! ```\n//!\n//! A DSN for unix socket:\n//!\n//! ```dsn\n//! unix:///path/to/unix.sock?param1=value\n//! ```\n//!\n//! A DSN for postgresql with url-encoded socket directory path.\n//!\n//! ```dsn\n//! postgresql://%2Fvar%2Flib%2Fpostgresql/db\n//! ```\n//!\n//! A DSN for sqlite db file, note that you must use prefix `./` for a relative path file.\n//!\n//! ```dsn\n//! sqlite://./file.db\n//! ```\n//!\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::num::ParseIntError;\nuse std::str::FromStr;\n\nuse itertools::Itertools;\nuse pest;\nuse pest::Parser;\nuse pest_derive::Parser;\nuse thiserror::Error;\n\n#[derive(Parser)]\n#[grammar = \"dsn.pest\"]\nstruct DsnParser;\n\n/// Error caused by [pest] DSN parser.\n#[derive(Debug, Error)]\npub enum DsnError {\n    #[error(\"{0}\")]\n    ParseErr(#[from] pest::error::Error<Rule>),\n    #[error(\"unable to parse port from {0}\")]\n    PortErr(#[from] ParseIntError),\n    #[error(\"invalid driver {0}\")]\n    InvalidDriver(String),\n    #[error(\"invalid connection {0}\")]\n    InvalidConnection(String),\n    #[error(\"invalid addresses {0:?}\")]\n    InvalidAddresses(Vec<Address>),\n    #[error(\"requires database: {0}\")]\n    RequireDatabase(String),\n}\n\n/// A simple struct to represent a server address, with host:port or socket path.\n#[derive(Debug, Default, PartialEq, Eq, Clone)]\npub struct Address {\n    /// Host or ip address of the server.\n    pub host: Option<String>,\n    /// Port to connect to the server.\n    pub port: Option<u16>,\n    /// Use unix socket path to connect.\n    pub path: Option<String>,\n}\n\nimpl Address {\n    /// Construct server address with host and port.\n    #[inline]\n    pub fn new(host: impl Into<String>, port: u16) -> Self {\n        Self {\n            host: Some(host.into()),\n            port: Some(port),\n            ..Default::default()\n        }\n    }\n    /// Construct server address with host or ip address only.\n    #[inline]\n    pub fn from_host(host: impl Into<String>) -> Self {\n        Self {\n            host: Some(host.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Construct server address with unix socket path.\n    #[inline]\n    pub fn from_path(path: impl Into<String>) -> Self {\n        Self {\n            path: Some(path.into()),\n            ..Default::default()\n        }\n    }\n\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.host.is_none() && self.port.is_none() && self.path.is_none()\n    }\n}\n\nimpl FromStr for Address {\n    type Err = DsnError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut addr = Self::default();\n        if let Some(dsn) = DsnParser::parse(Rule::address, &s)?.next() {\n            for inner in dsn.into_inner() {\n                match inner.as_rule() {\n                    Rule::host => addr.host = Some(inner.as_str().to_string()),\n                    Rule::port => addr.port = Some(inner.as_str().parse()?),\n                    Rule::path => {\n                        addr.path = Some(\n                            urlencoding::decode(inner.as_str())\n                                .expect(\"UTF-8\")\n                                .to_string(),\n                        )\n                    }\n                    _ => unreachable!(),\n                }\n            }\n        }\n        Ok(addr)\n    }\n}\n\nimpl Display for Address {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match (&self.host, self.port, &self.path) {\n            (Some(host), None, None) => write!(f, \"{host}\"),\n            (Some(host), Some(port), None) => write!(f, \"{host}:{port}\"),\n            (None, Some(port), None) => write!(f, \":{port}\"),\n            (None, None, Some(path)) => write!(f, \"{}\", urlencoding::encode(path)),\n            (None, None, None) => Ok(()),\n            _ => unreachable!(\"path will be conflict with host/port\"),\n        }\n    }\n}\n\n#[test]\nfn addr_parse() {\n    let s = \"taosdata:6030\";\n    let addr = Address::from_str(s).unwrap();\n    assert_eq!(addr.to_string(), s);\n\n    let s = \"/var/lib/taos\";\n    let addr = Address::from_str(&urlencoding::encode(s)).unwrap();\n    assert_eq!(addr.path.as_ref().unwrap(), s);\n    assert_eq!(addr.to_string(), urlencoding::encode(s));\n}\n\n/// A DSN(**Data Source Name**) parser.\n#[derive(Debug, Default, PartialEq, Eq, Clone)]\npub struct Dsn {\n    pub driver: String,\n    pub protocol: Option<String>,\n    pub username: Option<String>,\n    pub password: Option<String>,\n    pub addresses: Vec<Address>,\n    pub fragment: Option<String>,\n    pub database: Option<String>,\n    pub params: BTreeMap<String, String>,\n}\n\npub trait IntoDsn {\n    fn into_dsn(self) -> Result<Dsn, DsnError>;\n}\n\nimpl IntoDsn for &str {\n    fn into_dsn(self) -> Result<Dsn, DsnError> {\n        self.parse()\n    }\n}\n\nimpl IntoDsn for String {\n    fn into_dsn(self) -> Result<Dsn, DsnError> {\n        self.as_str().into_dsn()\n    }\n}\n\nimpl IntoDsn for &String {\n    fn into_dsn(self) -> Result<Dsn, DsnError> {\n        self.as_str().into_dsn()\n    }\n}\n\nimpl IntoDsn for &Dsn {\n    fn into_dsn(self) -> Result<Dsn, DsnError> {\n        Ok(self.clone())\n    }\n}\nimpl IntoDsn for Dsn {\n    fn into_dsn(self) -> Result<Dsn, DsnError> {\n        Ok(self)\n    }\n}\n\nimpl Display for Dsn {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.driver)?;\n        if let Some(protocol) = &self.protocol {\n            write!(f, \"+{protocol}\")?;\n        }\n        write!(f, \"://\")?;\n        match (&self.username, &self.password) {\n            (Some(username), Some(password)) => write!(f, \"{username}:{password}@\")?,\n            (Some(username), None) => write!(f, \"{username}@\")?,\n            (None, Some(password)) => write!(f, \":{password}@\")?,\n            (None, None) => {}\n        }\n        if !self.addresses.is_empty() {\n            write!(\n                f,\n                \"{}\",\n                self.addresses.iter().map(ToString::to_string).join(\",\")\n            )?;\n        }\n        if let Some(database) = &self.database {\n            write!(f, \"/{database}\")?;\n        }\n        if let Some(fragment) = &self.fragment {\n            write!(f, \"{fragment}\")?;\n        }\n        if !self.params.is_empty() {\n            write!(\n                f,\n                \"?{}\",\n                self.params\n                    .iter()\n                    .map(|(k, v)| format!(\"{k}={v}\"))\n                    .join(\"&\")\n            )?;\n        }\n        Ok(())\n    }\n}\n\nimpl Dsn {\n    /// Parse from a DSN string.\n    #[inline]\n    pub fn parse(dsn: impl AsRef<str>) -> Result<Self, DsnError> {\n        dsn.as_ref().parse()\n    }\n}\n\nimpl TryFrom<&str> for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Dsn::from_str(value)\n    }\n}\n\nimpl TryFrom<&String> for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: &String) -> Result<Self, Self::Error> {\n        Dsn::from_str(value)\n    }\n}\n\nimpl TryFrom<String> for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: String) -> Result<Self, Self::Error> {\n        Dsn::from_str(&value)\n    }\n}\n\nimpl TryFrom<&Dsn> for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: &Dsn) -> Result<Self, Self::Error> {\n        Ok(value.clone())\n    }\n}\nimpl FromStr for Dsn {\n    type Err = DsnError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let dsn = DsnParser::parse(Rule::dsn, s)?.next().unwrap();\n\n        let mut to = Dsn::default();\n        for pair in dsn.into_inner() {\n            match pair.as_rule() {\n                Rule::scheme => {\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::driver => to.driver = inner.as_str().to_string(),\n                            Rule::protocol => to.protocol = Some(inner.as_str().to_string()),\n                            _ => unreachable!(),\n                        }\n                    }\n                }\n                Rule::SCHEME_IDENT => (),\n                Rule::username_with_password => {\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::username => to.username = Some(inner.as_str().to_string()),\n                            Rule::password => to.password = Some(inner.as_str().to_string()),\n                            _ => unreachable!(),\n                        }\n                    }\n                }\n                Rule::protocol_with_addresses => {\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::addresses => {\n                                for inner in inner.into_inner() {\n                                    match inner.as_rule() {\n                                        Rule::address => {\n                                            let mut addr = Address::default();\n                                            for inner in inner.into_inner() {\n                                                match inner.as_rule() {\n                                                    Rule::host => {\n                                                        addr.host = Some(inner.as_str().to_string())\n                                                    }\n                                                    Rule::port => {\n                                                        addr.port = Some(inner.as_str().parse()?)\n                                                    }\n                                                    Rule::path => {\n                                                        addr.path = Some(\n                                                            urlencoding::decode(inner.as_str())\n                                                                .expect(\"UTF-8\")\n                                                                .to_string(),\n                                                        )\n                                                    }\n                                                    _ => unreachable!(),\n                                                }\n                                            }\n                                            to.addresses.push(addr);\n                                        }\n                                        _ => unreachable!(),\n                                    }\n                                }\n                            }\n                            Rule::protocol => to.protocol = Some(inner.as_str().to_string()),\n                            _ => unreachable!(),\n                        }\n                    }\n                }\n                Rule::database => {\n                    to.database = Some(pair.as_str().to_string());\n                }\n                Rule::fragment => {\n                    to.fragment = Some(pair.as_str().to_string());\n                }\n                Rule::param => {\n                    let (mut name, mut value) = (\"\".to_string(), \"\".to_string());\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::name => name = inner.as_str().to_string(),\n                            Rule::value => value = inner.as_str().to_string(),\n                            _ => unreachable!(),\n                        }\n                    }\n                    to.params.insert(name, value);\n                }\n                Rule::EOI => {}\n                _ => unreachable!(),\n            }\n        }\n        Ok(to)\n    }\n}\n\n#[test]\nfn username_with_password() {\n    let s = \"taos://\";\n\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos:///\";\n\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), \"taos://\");\n\n    let s = \"taos://root@\";\n\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n    let s = \"taos://root:taosdata@\";\n\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn host_port_mix() {\n    let s = \"taos://localhost\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            addresses: vec![Address {\n                host: Some(\"localhost\".to_string()),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@:6030\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                port: Some(6030),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@localhost:6030\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                host: Some(\"localhost\".to_string()),\n                port: Some(6030),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n#[test]\nfn username_with_host() {\n    let s = \"taos://root@localhost\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                host: Some(\"localhost\".to_string()),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@:6030\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                port: Some(6030),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@localhost:6030\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address::new(\"localhost\", 6030)],\n            ..Default::default()\n        }\n    );\n\n    let s = \"taos://root:taosdata@localhost:6030\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            addresses: vec![Address::new(\"localhost\", 6030)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn username_with_multi_addresses() {\n    let s = \"taos://root@host1.domain:6030,host2.domain:6031\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![\n                Address::new(\"host1.domain\", 6030),\n                Address::new(\"host2.domain\", 6031)\n            ],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root:taosdata@host1:6030,host2:6031\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn db_only() {\n    let s = \"taos:///db1\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            database: Some(\"db1\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos:///db1\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            database: Some(\"db1\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn username_with_multi_addresses_database() {\n    let s = \"taos://root@host1:6030,host2:6031/db1\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            database: Some(\"db1\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root:taosdata@host1:6030,host2:6031/db1\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            database: Some(\"db1\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn protocol() {\n    let s = \"taos://root@tcp(host1:6030,host2:6031)/db1\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            database: Some(\"db1\".to_string()),\n            protocol: Some(\"tcp\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), \"taos+tcp://root@host1:6030,host2:6031/db1\");\n\n    let s = \"taos+tcp://root@host1:6030,host2:6031/db1\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            database: Some(\"db1\".to_string()),\n            protocol: Some(\"tcp\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), \"taos+tcp://root@host1:6030,host2:6031/db1\");\n}\n\n#[test]\nfn fragment() {\n    let s = \"postgresql://%2Fvar%2Flib%2Fpostgresql/dbname\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"postgresql\".to_string(),\n            database: Some(\"dbname\".to_string()),\n            addresses: vec![Address {\n                path: Some(\"/var/lib/postgresql\".to_string()),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"unix:///path/to/unix.sock\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"unix\".to_string(),\n            fragment: Some(\"/path/to/unix.sock\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"sqlite:///c:/full/windows/path/to/file.db\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"sqlite\".to_string(),\n            fragment: Some(\"/c:/full/windows/path/to/file.db\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"sqlite://./file.db\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"sqlite\".to_string(),\n            fragment: Some(\"./file.db\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"sqlite://root:pass@/full/unix/path/to/file.db?mode=0666&readonly=true\";\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"sqlite\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"pass\".to_string()),\n            fragment: Some(\"/full/unix/path/to/file.db\".to_string()),\n            params: BTreeMap::from_iter(vec![\n                (\"mode\".to_string(), \"0666\".to_string()),\n                (\"readonly\".to_string(), \"true\".to_string())\n            ]),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn params() {\n    let s = r#\"taos://?abc=abc\"#;\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            params: BTreeMap::from_iter(vec![(\"abc\".to_string(), \"abc\".to_string())]),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = r#\"taos://root@localhost?abc=abc\"#;\n    let dsn = Dsn::from_str(&s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address::from_host(\"localhost\")],\n            params: BTreeMap::from_iter(vec![(\"abc\".to_string(), \"abc\".to_string())]),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn parse_taos_tmq() {\n    let s = \"taos://root:taosdata@localhost/aa23d04011eca42cf7d8c1dd05a37985?topics=aa23d04011eca42cf7d8c1dd05a37985&group.id=tg2\";\n    let _ = Dsn::from_str(&s).unwrap();\n\n}\n","traces":[{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[14154192],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":139,"address":[14154206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[14154320,14156495,14155802],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":147,"address":[14154350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[14154371,14154838,14154768,14154463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[14154912,14156079,14155033,14156364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[14155233,14155304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[14156178,14155388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[14155420,14155845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[14155625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[14155452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[14156425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[14157899,14156512],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":170,"address":[14156546,14156683,14156726,14157213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[14157055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[14156794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[14157299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[14157468,14157701,14157929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[14157455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[14157952],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":212,"address":[14157973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[14125919,14125808],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":218,"address":[14125833,14125896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[14125952],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":224,"address":[14125984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[14158000],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":230,"address":[14158024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[14158096],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":235,"address":[14158113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[14158192,14160224],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":241,"address":[14158231,14158456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[14158417,14158506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[14158514,14158604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[14158783,14158546,14158923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[14158870,14158950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[14159374,14159062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[14159011,14159417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[14159590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[14159832,14159352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[14160254,14160026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[14159905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[14159846,14160335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[14160343,14160430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[14160600,14160377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[14160608,14160674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[14160843,14160642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[14160947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[14160870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[14267177,14267136],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":275,"address":[14160849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[8222944,8222848],"length":1,"stats":{"Line":1},"fn_name":"parse<&str>"},{"line":283,"address":[8222872,8222931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[14161232],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":291,"address":[14161253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[14161280],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":299,"address":[14161312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[14161471,14161360],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":307,"address":[14161385,14161448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[14161504],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":315,"address":[14161528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[14161600,14162117],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":322,"address":[14162143,14162015,14161651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[14162175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[14169590,14169558,14162220,14162328,14166837],"length":1,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[14162539,14162613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[14168724,14162718,14169526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[14168927,14168998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[14169072,14169372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[14169104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[14167858,14168692,14162788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[14168132,14168061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[14168206,14168506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[14168238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[14162896,14166810,14167602,14164653,14167570],"length":1,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[14164864,14164938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[14166783,14167256,14167317,14165056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[14165408,14165334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[14165437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[14167120,14165601,14165477,14166694],"length":1,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[14165881,14165804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[14165977,14166918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[14166455,14166639,14166015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[14166224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[14166053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[14167125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[14167384,14165018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[14163237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[14162995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[14167853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[14162858,14167672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[14163242,14162966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":391,"address":[14163564,14163456,14164402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":392,"address":[14163844,14163767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[14164232,14163924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[14163962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[14164434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[14169636],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":34,"coverable":104},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","metrics.rs"],"content":"use std::{thread, time};\n\nuse anyhow::Result;\nuse taosx::metrics::*;\n\nfn main() -> Result<()> {\n    Metrics::default().init().unwrap();\n\n    loop {\n        thread::sleep(time::Duration::from_secs(1));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","backup.rs"],"content":"use clap::Args;\nuse futures::Future;\nuse parquet::{basic::Compression, schema::types::Type};\nuse std::{\n    fmt::Debug,\n    fs::{self, File},\n    io::Write,\n    path::PathBuf,\n    sync::Arc,\n};\nuse taos::prelude::*;\nuse taos::TaosOptions;\n\nuse taosx::{Database, TaosOpts};\nuse thread_id;\nuse tokio::runtime::Builder;\n\nuse crate::commands::backup::{\n    fetch::{fetch_database_info, fetch_table_list},\n    schema::TaosParquetSchema,\n};\n\nuse self::{fetch::fetch_stable_tag_buffer, serialize::Serialize};\n\nmod fetch;\nmod schema;\nmod serialize;\n\n#[derive(Debug, Args, Clone)]\n/// Backup database or tables to specific files.\n///\n/// Basically, an alternative command to `taosdump`.\npub(crate) struct App {\n    #[clap(short, long)]\n    database: Option<String>,\n    #[clap(short, long)]\n    output: Option<String>,\n    #[clap(short, long)]\n    thread: Option<u32>,\n}\n\nfn allocate_task<Fut: 'static>(\n    table_list: Vec<String>,\n    schema: Arc<Type>,\n    dir: PathBuf,\n    path: &str,\n    mut threads: u32,\n    db: String,\n    f: impl Fn(Arc<Type>, Vec<String>, PathBuf, String) -> Fut,\n) where\n    Fut: Future<Output = ()> + std::marker::Send,\n{\n    let mut own_path = dir;\n    own_path.push(path);\n    fs::create_dir(own_path.clone()).unwrap_or_else(|_| {\n        fs::remove_dir_all(own_path.clone()).unwrap_or_else(|_| {\n            fs::remove_dir(own_path.clone()).unwrap();\n        });\n        fs::create_dir(own_path.clone()).unwrap();\n    });\n    if threads > table_list.len() as _ {\n        threads = table_list.len() as _;\n    }\n    let tables_per_thread = if table_list.len() as u32 % threads == 0 {\n        table_list.len() as u32 / threads\n    } else {\n        table_list.len() as u32 / threads + 1\n    };\n\n    let mut handles = Vec::with_capacity(threads as _);\n    let chunks: Vec<&[String]> = table_list.chunks(tables_per_thread as _).collect();\n    threads = chunks.len() as _;\n\n    log::info!(\n        \"{} threads each deal at most {} tables\",\n        threads,\n        tables_per_thread\n    );\n\n    let runtime = Builder::new_multi_thread()\n        .worker_threads(threads as usize)\n        .enable_all()\n        .build()\n        .unwrap();\n\n    for chunk in chunks {\n        handles.push(runtime.spawn(f(\n            schema.clone(),\n            chunk.to_owned(),\n            own_path.clone(),\n            db.clone(),\n        )));\n    }\n    for handle in handles {\n        runtime.block_on(handle).unwrap();\n    }\n}\n\nimpl App {\n    pub fn run_with_taos_opts(&self, _opts: &TaosOpts) {\n        log::info!(\"prepare config options\");\n\n        let database = self.database.as_deref().unwrap_or(\"test\");\n        let db = String::from(database);\n        let threads = self.thread.unwrap_or(1);\n        let output = self.output.as_deref().unwrap_or(\"./\");\n        let path = PathBuf::from(output);\n\n        log::info!(\"prepare parquet schema\");\n\n        let schema = TaosParquetSchema::default().build();\n\n        log::info!(\"start backup database info\");\n\n        let database = fetch_database_info(db.clone());\n\n        backup_database(database, path.clone());\n\n        log::info!(\"finish backup database info\");\n\n        let (select_list, describe_list, stable_list) = fetch_table_list(db.clone());\n\n        log::info!(\n            \"select list: {:?}; describe list {:?}; stable_list{:?}\",\n            select_list,\n            describe_list,\n            stable_list\n        );\n\n        log::info!(\"start backup table meta info\");\n        allocate_task(\n            describe_list,\n            schema.clone(),\n            path.clone(),\n            \"table.info\",\n            threads,\n            db.clone(),\n            backup_table_schema,\n        );\n        log::info!(\"finish backup table meta info\");\n        log::info!(\"start backup table tags\");\n        allocate_task(\n            stable_list,\n            schema.clone(),\n            path.clone(),\n            \"tags\",\n            threads,\n            db.clone(),\n            backup_stable_tags,\n        );\n        log::info!(\"finish backup table tags\");\n        log::info!(\"start backup data\");\n        allocate_task(select_list, schema, path, \"chunk\", threads, db, backup_data);\n        log::info!(\"finish backup data\");\n    }\n}\n\nfn backup_database(database: Database, mut path: PathBuf) {\n    path.push(\"db.info\");\n    let mut file = File::create(path.as_path()).unwrap();\n    let j = serde_json::to_string_pretty(&database).unwrap();\n    file.write_all(j.as_bytes()).unwrap();\n}\n\nasync fn backup_table_schema(\n    schema: Arc<Type>,\n    table_list: Vec<String>,\n    mut path: PathBuf,\n    db: String,\n) {\n    let thread_id = thread_id::get();\n    path.push(format!(\"{}.parquet\", thread_id));\n    let file = File::create(path.as_path()).unwrap();\n    let taos = TaosOptions::new().database(db.clone()).build().unwrap();\n    let mut serialize = Serialize::new(file, Compression::SNAPPY, schema);\n    for tbname in table_list {\n        let describe = taos.describe(&tbname).await.unwrap();\n        serialize.serialze_table_meta(&tbname, describe);\n    }\n}\n\nasync fn backup_stable_tags(\n    schema: Arc<Type>,\n    table_list: Vec<String>,\n    mut path: PathBuf,\n    database: String,\n) {\n    let thread_id = thread_id::get();\n    path.push(format!(\"{}.parquet\", thread_id));\n    let file = File::create(path.as_path()).unwrap();\n    let mut serialize = Serialize::new(file, Compression::SNAPPY, schema);\n    let taos = TaosOptions::new()\n        .database(database.clone())\n        .build()\n        .unwrap();\n    for tbname in table_list {\n        let tag_buffer = fetch_stable_tag_buffer(database.clone(), tbname.clone()).await;\n        let mut res = taos\n            .query(format!(\"select tbname{} from {}\", tag_buffer, tbname).as_str())\n            .await\n            .unwrap();\n        let stream = res.block_stream();\n        serialize.serialize_tag(&tbname, stream).await;\n    }\n}\n\nasync fn backup_data(\n    schema: Arc<Type>,\n    tbname_list: Vec<String>,\n    mut path: PathBuf,\n    database: String,\n) {\n    let thread_id = thread_id::get();\n    path.push(format!(\"{}.parquet\", thread_id));\n    let file = File::create(path.as_path()).unwrap();\n    let taos = TaosOptions::new().database(database).build().unwrap();\n    let mut serialize = Serialize::new(file, Compression::SNAPPY, schema);\n    for tbname in tbname_list {\n        let mut res = taos\n            .query(format!(\"select * from {}\", tbname).as_str())\n            .await\n            .unwrap();\n        let stream = res.block_stream();\n        serialize.serialize_data(&tbname, stream).await;\n    }\n}\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","backup_parquet.rs"],"content":"use libtaos::Taos;\nuse parquet::{\n    basic::{\n        Compression, ConvertedType, LogicalType, Repetition, TimeUnit, TimestampType,\n        Type as PhysicalType,\n    },\n    file::{\n        properties::WriterProperties,\n        writer::{FileWriter, SerializedFileWriter},\n    },\n    schema::types::Type,\n};\nuse std::{fs, path::PathBuf, sync::Arc};\nuse taos::r2d2::TaosPool;\nuse taos::BlockExt;\n\npub async fn generate_parquet_schema(taos: &Taos, db: String, stb: &str) -> Arc<Type> {\n    let mut fields = vec![];\n    taos.use_database(&db).await.unwrap();\n    let res = taos.describe(stb).await.unwrap();\n    for i in 0..res.cols.len() {\n        match res.cols[i].type_ {\n            libtaos::TaosDataType::Null => todo!(),\n            libtaos::TaosDataType::Bool => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::BOOLEAN)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::TinyInt => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::INT_8)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::SmallInt => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::INT_16)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Int => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::BigInt => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::INT64)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Float => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::FLOAT)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Double => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::DOUBLE)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Binary => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::BYTE_ARRAY)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Timestamp => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::INT64)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_logical_type(Some(LogicalType::TIMESTAMP(TimestampType {\n                        is_adjusted_to_u_t_c: false,\n                        unit: TimeUnit::MILLIS(Default::default()),\n                    })))\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::NChar => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::BYTE_ARRAY)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_logical_type(Some(LogicalType::STRING(Default::default())))\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::UTinyInt => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_8)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::USmallInt => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_16)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::UInt => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_32)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::UBigInt => fields.push(Arc::new(\n                Type::primitive_type_builder(&i.to_string(), PhysicalType::INT64)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_64)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Json => todo!(),\n            libtaos::TaosDataType::Unknown => todo!(),\n        }\n    }\n    Arc::new(\n        Type::group_type_builder(\"schema\")\n            .with_fields(&mut fields)\n            .build()\n            .unwrap(),\n    )\n}\n\npub async fn backup_data_parquet(\n    pool: TaosPool,\n    db: String,\n    tb: String,\n    schema: Arc<Type>,\n    target: PathBuf,\n) {\n    let props = Arc::new(\n        WriterProperties::builder()\n            .set_compression(Compression::SNAPPY)\n            .build(),\n    );\n    let mut path = target.clone();\n    path.push(format!(\"{}.parquet\", tb));\n    let file = fs::File::create(path).unwrap();\n    let mut writer = SerializedFileWriter::new(file, schema, props).unwrap();\n    let taos = pool.get().unwrap();\n    let res = taos\n        .query(format!(\"select * from {}.{} \", db, tb).as_str())\n        .await\n        .unwrap();\n    let stream = res.fetch_block_stream();\n    use futures::future;\n    use futures::stream::StreamExt;\n    stream\n        .enumerate()\n        .for_each(|(_, partial)| {\n            // log::debug!(\"num of row in block: {}\", partial.num_of_rows());\n            let mut row_group_writer = writer.next_row_group().unwrap();\n            for col in partial.columns_iter() {\n                let data_writer = row_group_writer.next_column().unwrap();\n                if let Some(mut writer) = data_writer {\n                    use taos::block::BorrowedColumn::*;\n                    match writer {\n                        parquet::column::writer::ColumnWriter::BoolColumnWriter(ref mut typed) => {\n                            match col {\n                                Bool(is_nulls, values) => {\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n                                _ => unreachable!(),\n                            }\n                        }\n                        parquet::column::writer::ColumnWriter::Int32ColumnWriter(ref mut typed) => {\n                            // let values;\n                            match col {\n                                TinyInt(is_nulls, values) => {\n                                    let values: Vec<i32> =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(&values, None, None).unwrap();\n                                    // std::mem::transmute::<*const i32>(values.ptr()).\n\n                                    // values = values\n                                    //     .into_iter()\n                                    //     .map(|v| match v {\n                                    //         Some(u) => Some(u as i32),\n                                    //         None => None,\n                                    //     })\n                                    //     .collect::<Option<Vec<i32>>>()\n                                    //     .unwrap()\n                                }\n                                SmallInt(is_nulls, values) => {\n                                    let values: Vec<i32> =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n                                Int(is_nulls, values) => {\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n                                UTinyInt(is_nulls, values) => {\n                                    let values: Vec<i32> =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n                                USmallInt(is_nulls, values) => {\n                                    let values: Vec<i32> =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n                                UInt(is_nulls, values) => {\n                                    // let values: Vec<i32> = values.into_iter().map(|v| *v as _).collect();\n                                    let len = values.len();\n                                    let ptr: *mut i32 = values.as_ptr() as _;\n                                    let values = unsafe { std::slice::from_raw_parts(ptr, len) };\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n\n                                _ => unreachable!(),\n                            }\n                            // typed.write_batch(&values, None, None).unwrap();\n                        }\n                        parquet::column::writer::ColumnWriter::Int64ColumnWriter(ref mut typed) => {\n                            // let values;\n                            match col {\n                                BigInt(is_nulls, values) => {\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n                                UBigInt(is_nulls, values) => {\n                                    // let values: Vec<i32> = values.into_iter().map(|v| *v as _).collect();\n                                    let len = values.len();\n                                    let ptr: *mut i64 = values.as_ptr() as _;\n                                    let values = unsafe { std::slice::from_raw_parts(ptr, len) };\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n                                Timestamp(is_nulls, values) => {\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n                                _ => unreachable!(),\n                            }\n                            // typed.write_batch(&values, None, None).unwrap();\n                        }\n                        parquet::column::writer::ColumnWriter::FloatColumnWriter(ref mut typed) => {\n                            // let values;\n                            match col {\n                                Float(is_nulls, values) => {\n                                    typed.write_batch(&values, None, None).unwrap();\n                                }\n                                _ => unreachable!(),\n                            }\n                        }\n                        parquet::column::writer::ColumnWriter::DoubleColumnWriter(\n                            ref mut typed,\n                        ) => match col {\n                            Double(is_nulls, values) => {\n                                typed.write_batch(&values, None, None).unwrap();\n                            }\n                            _ => unreachable!(),\n                        },\n                        parquet::column::writer::ColumnWriter::ByteArrayColumnWriter(\n                            ref mut typed,\n                        ) => {\n                            let mut values = vec![];\n                            match col {\n                                Binary(v) => {\n                                    for f in v.into_iter() {\n                                        match f {\n                                            Some(u) => values.push(\n                                                parquet::data_type::ByteArray::from(u.to_vec()),\n                                            ),\n                                            None => {\n                                                values.push(parquet::data_type::ByteArray::from(\"\"))\n                                            }\n                                        }\n                                    }\n                                }\n                                NChar(v) => {\n                                    for f in v.into_iter() {\n                                        match f {\n                                            Some(u) => values.push(\n                                                parquet::data_type::ByteArray::from(u),\n                                            ),\n                                            None => {\n                                                values.push(parquet::data_type::ByteArray::from(\"\"))\n                                            }\n                                        }\n                                    }\n                                }\n                                _ => unreachable!(),\n                            }\n                            typed.write_batch(&values, None, None).unwrap();\n                        }\n                        _ => unreachable!(),\n                    }\n                    row_group_writer.close_column(writer).unwrap();\n                }\n            }\n            writer.close_row_group(row_group_writer).unwrap();\n            future::ready(())\n        })\n        .await;\n    writer.close().unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","fetch.rs"],"content":"use futures::TryStreamExt;\nuse taos::prelude::*;\nuse taosx::Database;\nuse tokio::runtime::Builder;\n#[derive(::serde::Deserialize, Debug)]\npub struct Table {\n    pub table_name: String,\n    pub stable_name: String,\n}\n\npub fn fetch_table_list(database: String) -> (Vec<String>, Vec<String>, Vec<String>) {\n    let mut select_list = vec![];\n    let mut describe_list = vec![];\n    let mut stable_list = vec![];\n    let taos = TaosOptions::new().database(database).build().unwrap();\n    let tables: Vec<Table> = Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            taos.query(\"show tables\")\n                .await\n                .unwrap()\n                .deserialize_stream()\n                .try_collect()\n                .await\n                .unwrap()\n        });\n    for table in tables {\n        select_list.push(table.table_name.clone());\n        if table.stable_name.is_empty() {\n            describe_list.push(table.table_name);\n        } else if !describe_list.contains(&table.stable_name) {\n            stable_list.push(table.stable_name.clone());\n            describe_list.push(table.stable_name);\n        }\n    }\n    (select_list, describe_list, stable_list)\n}\n\npub fn fetch_database_info(database: String) -> Database {\n    let taos = TaosOptions::new()\n        .database(database.clone())\n        .build()\n        .unwrap();\n    let dbs: Vec<Database> = Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            taos.query(\"show databases\")\n                .await\n                .unwrap()\n                .deserialize_stream()\n                .try_collect()\n                .await\n                .unwrap()\n        });\n    for db in dbs {\n        if db.name == database {\n            return db;\n        }\n    }\n    panic!(\"cannot find database {}\", database);\n}\n\npub async fn fetch_stable_tag_buffer(database: String, stable: String) -> String {\n    let mut tag_buffer = String::from(\"\");\n    let taos = TaosOptions::new()\n        .database(database.clone())\n        .build()\n        .unwrap();\n    let describe = taos\n        .describe(format!(\"{}.{}\", database.clone(), stable).as_str())\n        .await\n        .unwrap();\n    for col in describe {\n        if col.is_tag() {\n            tag_buffer += \",\";\n            tag_buffer += col.field();\n        }\n    }\n    tag_buffer\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","schema.rs"],"content":"use parquet::basic::{Repetition, Type as PhysicalType};\nuse parquet::schema::types::Type;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone, Default)]\npub struct TaosParquetSchema {\n    fields: Vec<Arc<Type>>,\n}\n\nimpl TaosParquetSchema {\n    fn add_required_byte_array_col(mut self, name: &str) -> Self {\n        self.fields.push(Arc::new(\n            Type::primitive_type_builder(name, PhysicalType::BYTE_ARRAY)\n                .with_repetition(Repetition::REQUIRED)\n                .build()\n                .unwrap(),\n        ));\n        self\n    }\n\n    fn add_group(mut self, group: Arc<Type>) -> Self {\n        self.fields.push(group);\n        self\n    }\n\n    fn build_repeated_group(mut self, name: &str) -> Arc<Type> {\n        Arc::new(\n            Type::group_type_builder(name)\n                .with_fields(&mut self.fields)\n                .with_repetition(Repetition::REPEATED)\n                .build()\n                .unwrap(),\n        )\n    }\n\n    fn build_schema(mut self, name: &str) -> Arc<Type> {\n        Arc::new(\n            Type::group_type_builder(name)\n                .with_fields(&mut self.fields)\n                .build()\n                .unwrap(),\n        )\n    }\n\n    pub fn build(self) -> Arc<Type> {\n        self.add_group(\n            TaosParquetSchema::default()\n                .add_required_byte_array_col(\"data\")\n                .build_repeated_group(\"table_info\"),\n        )\n        .build_schema(\"table\")\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","serialize.rs"],"content":"use std::{fmt::Debug, sync::Arc};\n\nuse futures::{future, StreamExt};\nuse parquet::{\n    basic::Compression,\n    column::writer::*,\n    data_type::{ByteArray, ByteArrayType},\n    file::{\n        properties::WriterProperties,\n        writer::{FileWriter, ParquetWriter, SerializedFileWriter},\n    },\n    schema::types::Type,\n};\n\nuse taos::{\n    block::{BlockStream, Describe},\n    helpers::ColumnMeta,\n    prelude::BlockExt,\n};\nuse taosx::{TaosBlock, TaosDescribe, TaosTag};\n\npub struct Serialize<W: ParquetWriter + 'static> {\n    writer: SerializedFileWriter<W>,\n}\n\nimpl<W: ParquetWriter + 'static> Serialize<W> {\n    pub fn new(target: W, compression: Compression, schema: Arc<Type>) -> Self {\n        let props = Arc::new(\n            WriterProperties::builder()\n                .set_compression(compression)\n                .build(),\n        );\n        let writer = SerializedFileWriter::new(target, schema, props).unwrap();\n\n        Self { writer }\n    }\n\n    fn serialize<T>(&mut self, source: T)\n    where\n        T: serde::Serialize + serde::de::DeserializeOwned + Debug,\n    {\n        let mut row_group = self.writer.next_row_group().unwrap();\n        let mut column_writer = row_group.next_column().unwrap().unwrap();\n        let typed = get_typed_column_writer_mut::<ByteArrayType>(&mut column_writer);\n        let encoded = bincode::serialize(&source).unwrap();\n        typed\n            .write_batch(&[ByteArray::from(encoded)], Some(&[1]), Some(&[0]))\n            .unwrap();\n        row_group.close_column(column_writer).unwrap();\n        self.writer.close_row_group(row_group).unwrap();\n    }\n\n    pub fn serialze_table_meta(&mut self, name: &str, describe: Describe) {\n        let taos_describe = TaosDescribe::new(name.to_string(), describe);\n        self.serialize(taos_describe);\n    }\n\n    pub async fn serialize_tag(&mut self, name: &str, stream: BlockStream) {\n        stream\n            .enumerate()\n            .for_each(|(_, block)| {\n                let taos_tags = TaosTag::new(name.to_string(), block.iter_rows());\n                self.serialize(taos_tags);\n                future::ready(())\n            })\n            .await;\n    }\n\n    pub async fn serialize_data(&mut self, name: &str, stream: BlockStream) {\n        stream\n            .enumerate()\n            .for_each(|(_, block)| {\n                let taos_block = TaosBlock::new(name.to_string(), block.columns_iter());\n                self.serialize(taos_block);\n                future::ready(())\n            })\n            .await;\n    }\n}\n\nimpl<W: ParquetWriter + 'static> Drop for Serialize<W> {\n    fn drop(&mut self) {\n        self.writer.close().unwrap();\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","export.rs"],"content":"use clap::Args;\nuse taosx::TaosOpts;\n\n#[derive(Debug, Args)]\n/// Export db or table to specific files.\npub(crate) struct App {\n    name: Option<String>,\n}\nimpl App {\n    pub fn run_with_taos_opts(&self, _opts: &TaosOpts) {\n        todo!()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","import.rs"],"content":"use clap::Args;\nuse taos::query::Dsn;\nuse taosx::TaosOpts;\n\n#[derive(Debug, Args)]\n/// Import external files to TDengine.\npub(crate) struct App {\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for source TDengine: taos:///db1, for eg.\n    from: Dsn,\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for target TDengine: taos:///db2, for eg.\n    to: Dsn,\n}\n\nimpl App {\n    pub fn run_with_taos_opts(&self, _opts: &TaosOpts) {\n        todo!()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","mod.rs"],"content":"#[path = \"backup/backup.rs\"]\npub mod backup;\npub mod export;\npub mod import;\n#[path = \"restore/restore.rs\"]\npub mod restore;\n\npub mod sync;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","restore","deserialize.rs"],"content":"use parquet::{\n    file::{reader::FileReader, serialized_reader::SerializedFileReader},\n    record::Field,\n};\nuse std::io::BufReader;\nuse std::{fs::File, path::PathBuf};\n\nuse taosx::Database;\n\npub fn deserialize_database(path: PathBuf) -> Database {\n    let file = File::open(path).unwrap();\n    let reader = BufReader::new(file);\n    serde_json::from_reader(reader).unwrap()\n}\n\npub struct Deserialize<T: serde::de::DeserializeOwned> {\n    parquet_reader: SerializedFileReader<File>,\n    pub output: Vec<T>,\n}\n\nimpl<T: serde::de::DeserializeOwned> Deserialize<T> {\n    pub fn new(source: String) -> Self {\n        let parquet_reader = SerializedFileReader::try_from(source).unwrap();\n        let output: Vec<T> = Vec::new();\n        Self {\n            parquet_reader,\n            output,\n        }\n    }\n\n    pub async fn deserialize(&mut self) {\n        let iter = self.parquet_reader.get_row_iter(None).unwrap();\n        for row in iter {\n            let (_, field) = row.get_column_iter().next().unwrap();\n            if let Field::ListInternal(list) = field {\n                for element in list.elements() {\n                    if let Field::Group(g) = element {\n                        let (_, fields) = g.get_column_iter().next().unwrap();\n                        if let Field::Bytes(b) = fields {\n                            self.output\n                                .push(bincode::deserialize::<T>(b.data()).unwrap());\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","restore","restore.rs"],"content":"use clap::Args;\nuse futures::Future;\nuse std::path::PathBuf;\nuse tokio::runtime::Builder;\n\nuse taos::prelude::*;\nuse taosx::{TaosBlock, TaosDescribe, TaosOpts, TaosTag};\npub(crate) mod deserialize;\n\nuse self::deserialize::{deserialize_database, Deserialize};\n#[derive(Debug, Args)]\n/// Restore from a backup output directory.\n\npub(crate) struct App {\n    #[clap(short, long)]\n    database: Option<String>,\n    #[clap(short, long)]\n    input: Option<String>,\n    #[clap(short, long)]\n    thread: Option<u32>,\n}\n\nfn allocate_task<Fut: 'static>(\n    db: String,\n    mut dir: PathBuf,\n    path: &str,\n    mut threads: u32,\n    f: impl Fn(Vec<String>, String) -> Fut,\n) where\n    Fut: Future<Output = ()> + std::marker::Send,\n{\n    dir.push(path);\n    let mut filelist = vec![];\n    for element in dir.read_dir().unwrap() {\n        let filename = element.unwrap().path();\n        if let Some(extension) = filename.extension() {\n            if extension == \"parquet\" {\n                filelist.push(filename.to_str().unwrap().to_string());\n            }\n        }\n    }\n    if threads > filelist.len() as _ {\n        threads = filelist.len() as _;\n    }\n    let file_per_threads = if filelist.len() as u32 % threads == 0 {\n        filelist.len() as u32 / threads\n    } else {\n        filelist.len() as u32 / threads + 1\n    };\n\n    let mut handles = Vec::with_capacity(threads as _);\n    let chunks: Vec<&[String]> = filelist.chunks(file_per_threads as _).collect();\n    threads = chunks.len() as _;\n\n    log::info!(\n        \"{} threads each deal with at most {} files\",\n        threads,\n        file_per_threads\n    );\n\n    let runtime = Builder::new_multi_thread()\n        .worker_threads(threads as usize)\n        .enable_all()\n        .build()\n        .unwrap();\n    for chunk in chunks {\n        handles.push(runtime.spawn(f(chunk.to_owned(), db.clone())))\n    }\n    for handle in handles {\n        runtime.block_on(handle).unwrap();\n    }\n}\n\nimpl App {\n    pub fn run_with_taos_opts(&self, _opts: &TaosOpts) {\n        let threads = self.thread.unwrap_or(1);\n        let input = self.input.as_deref().unwrap_or(\"./\");\n        let path = PathBuf::from(input);\n\n        let db = restore_database(path.clone());\n\n        allocate_task(\n            db.clone(),\n            path.clone(),\n            \"table.info\",\n            threads,\n            restore_table_info,\n        );\n\n        allocate_task(db.clone(), path.clone(), \"tags\", threads, restore_tags);\n\n        allocate_task(db, path, \"chunk\", threads, restore_data);\n    }\n}\n\nfn restore_database(mut path: PathBuf) -> String {\n    path.push(\"db.info\");\n    let taos = TaosOptions::new().build().unwrap();\n    let database = deserialize_database(path);\n    Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            taos.query(format!(\"create database if not exists {}\", database.name))\n                .await\n                .unwrap()\n        });\n\n    database.name\n}\n\nasync fn restore_table_info(filelist: Vec<String>, db: String) {\n    let taos = TaosOptions::new().database(db).build().unwrap();\n    for file in filelist {\n        let mut deserialize = Deserialize::<TaosDescribe>::new(file);\n        deserialize.deserialize().await;\n        let describes = deserialize.output;\n        for describe in describes {\n            let mut col_buffer = String::from(\"\");\n            let mut tag_buffer = String::from(\"\");\n            for col in describe.describe {\n                match col {\n                    taosx::TaosColumnMeta::Column(des) => {\n                        if des.ty == Ty::VarChar || des.ty == Ty::NChar {\n                            col_buffer +=\n                                format!(\"{} {}({}),\", des.field.as_str(), des.ty, des.length)\n                                    .as_str();\n                        } else {\n                            col_buffer += format!(\"{} {},\", des.field.as_str(), des.ty,).as_str();\n                        }\n                    }\n                    taosx::TaosColumnMeta::Tag(des) => {\n                        if des.ty == Ty::VarChar || des.ty == Ty::NChar {\n                            tag_buffer +=\n                                format!(\"{} {}({}),\", des.field.as_str(), des.ty, des.length)\n                                    .as_str();\n                        } else {\n                            tag_buffer += format!(\"{} {},\", des.field.as_str(), des.ty,).as_str();\n                        }\n                    }\n                }\n            }\n            col_buffer.pop();\n            tag_buffer.pop();\n            let sql = format!(\n                \"create table {} ({}) tags ({})\",\n                describe.name, col_buffer, tag_buffer\n            );\n            taos.stmt(sql).unwrap().execute().unwrap();\n        }\n    }\n}\n\nasync fn restore_tags(filelist: Vec<String>, db: String) {\n    let taos = TaosOptions::new().database(db).build().unwrap();\n    for file in filelist {\n        let mut deserialize = Deserialize::<TaosTag>::new(file);\n        deserialize.deserialize().await;\n        let taostags = deserialize.output;\n        for taostag in taostags {\n            let stbname = taostag.name;\n            for tag in taostag.tags {\n                let mut sql = String::new();\n                for (index, value) in tag.into_iter().enumerate() {\n                    if index == 0 {\n                        if let Value::VarChar(b) = value {\n                            sql = format!(\"create table {} using {} tags (\", b, &stbname);\n                        }\n                    } else {\n                        match value {\n                            Value::Null => sql += \"NULL,\",\n                            Value::Bool(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::TinyInt(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::SmallInt(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::Int(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::BigInt(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::Float(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::Double(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::VarChar(v) => {\n                                sql += format!(\"\\'{}\\',\", v).as_str();\n                            }\n                            Value::Timestamp(v) => sql += format!(\"{},\", v.as_raw_i64()).as_str(),\n                            Value::NChar(v) => sql += format!(\"\\'{}\\',\", v).as_str(),\n                            Value::UTinyInt(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::USmallInt(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::UInt(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::UBigInt(v) => sql += format!(\"{},\", v).as_str(),\n                            Value::Json(v) => sql += format!(\"{},\", v).as_str(),\n                            _ => todo!(),\n                        }\n                    }\n                }\n                sql.pop();\n                sql += \")\";\n                taos.stmt(sql).unwrap().execute().unwrap();\n            }\n        }\n    }\n}\n\nasync fn restore_data(filelist: Vec<String>, db: String) {\n    let taos = TaosOptions::new().database(db).build().unwrap();\n    for file in filelist {\n        let mut deserialize = Deserialize::<TaosBlock>::new(file);\n        deserialize.deserialize().await;\n        let taos_blocks = deserialize.output;\n        for taos_block in taos_blocks {\n            let col_num = taos_block.data.len();\n            let mut prepare = format!(\"insert into {} values (\", taos_block.name);\n            for _ in 0..col_num {\n                prepare += \"?,\";\n            }\n            prepare.pop();\n            prepare += \")\";\n            let mut stmt = taos.stmt(prepare).expect(\"prepare\");\n            let col_vec = taos_block.to_column_vec();\n            let bind: Vec<_> = col_vec.iter().map(|v| v.into()).collect();\n            stmt.multi_bind(&bind).expect(\"bind erro\");\n            stmt.execute().expect(\"execute error\");\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","restore","restore_parquet.rs"],"content":"use bitvec_simd::BitVec;\nuse glob::glob;\nuse parquet::basic::ConvertedType;\nuse parquet::column::reader::{ColumnReader, ColumnReaderImpl};\nuse parquet::data_type::{ByteArray, ByteArrayType, DataType};\nuse parquet::file::reader::FileReader;\nuse parquet::file::serialized_reader::SerializedFileReader;\nuse std::path::PathBuf;\n// use taos::block::serde::Block;\n// use taos::block::Block;\nuse taos::block::Column as Block;\nuse taos::r2d2::TaosPool;\n\npub fn get_parquet_files<'a>(path: PathBuf) -> Vec<String> {\n    let mut file_list = vec![];\n    let paths = glob(format!(\"{}/*.parquet\", path.as_os_str().to_str().unwrap()).as_str()).unwrap();\n    for entry in paths {\n        match entry {\n            Ok(path) => {\n                let filename = path.to_str().unwrap().split(\"/\").last().unwrap();\n                file_list.push(filename.to_string())\n            }\n            Err(e) => println!(\"{:?}\", e),\n        }\n    }\n    file_list\n}\n\nfn read<T>(mut column_reader: ColumnReaderImpl<T>, num_rows: usize) -> Vec<T::T>\nwhere\n    T: DataType,\n    T::T: Default + Copy,\n{\n    let mut data = vec![];\n    const BATCH_SIZE: usize = 100;\n    let mut values = [T::T::default(); BATCH_SIZE];\n    for _ in 0..(num_rows + BATCH_SIZE - 1) / BATCH_SIZE {\n        let (num, _) = column_reader\n            .read_batch(BATCH_SIZE, None, None, &mut values)\n            .unwrap();\n        data.extend(&values[0..num]);\n    }\n    data\n}\n\nfn read_str(mut column_reader: ColumnReaderImpl<ByteArrayType>, num_rows: usize) -> Vec<ByteArray> {\n    let mut data = vec![];\n    const BATCH_SIZE: usize = 10;\n    for _ in 0..(num_rows + BATCH_SIZE - 1 / BATCH_SIZE) {\n        let mut values = vec![];\n        for _ in 0..BATCH_SIZE {\n            values.push(ByteArray::new());\n        }\n        column_reader\n            .read_batch(BATCH_SIZE, None, None, &mut values)\n            .unwrap();\n        data.extend(values);\n    }\n    let _ = data.split_off(num_rows);\n    log::debug!(\"data: {:?}\", data);\n    data\n}\n\npub async fn restore_parquet(pool: TaosPool, path: PathBuf, filename: String, database: String) {\n    let taos = pool.get().unwrap();\n    taos.query(format!(\"use {}\", database)).await.unwrap();\n    let tb = filename.split(\".\").next().unwrap();\n    let parquet_reader =\n        SerializedFileReader::try_from(format!(\"{}/{}.parquet\", path.to_str().unwrap(), tb))\n            .unwrap();\n    let read_schema = parquet_reader.metadata().file_metadata().schema();\n    let mut sql = format!(\"insert into {} values(\", tb);\n    let fields = read_schema.get_fields();\n    let column_num = fields.len();\n    for i in 0..column_num {\n        if i != column_num - 1 {\n            sql += \"?,\";\n        } else {\n            sql += \"?)\";\n        }\n    }\n\n    for row_group in 0..parquet_reader.num_row_groups() {\n        let row_group_reader = parquet_reader.get_row_group(row_group).unwrap();\n        let blocks: Vec<_> = (0..row_group_reader.num_columns())\n            .map(|col_num| {\n                let col_reader = row_group_reader.get_column_reader(col_num).unwrap();\n                let row_num = row_group_reader.metadata().num_rows() as usize;\n                let nulls = BitVec::zeros(row_num);\n\n                match col_reader {\n                    ColumnReader::BoolColumnReader(v) => {\n                        let column = read(v, row_num);\n                        Block::Bool(nulls, column)\n                    }\n                    ColumnReader::ByteArrayColumnReader(v) => {\n                        let column = read_str(v, row_num);\n                        match fields.get(col_num).unwrap().get_basic_info().logical_type() {\n                            Some(_) => Block::NChar(\n                                column\n                                    .into_iter()\n                                    .map(|v| {\n                                        Some(std::str::from_utf8(v.data()).unwrap().to_string())\n                                    })\n                                    .collect(),\n                            ),\n                            None => Block::Binary(\n                                column\n                                    .into_iter()\n                                    .map(|v| Some(v.data().to_vec()))\n                                    .collect::<Vec<Option<Vec<u8>>>>()\n                                    .to_vec(),\n                            ),\n                        }\n                    }\n                    ColumnReader::DoubleColumnReader(v) => {\n                        let column = read(v, row_num);\n                        Block::Double(nulls, column)\n                    }\n                    ColumnReader::FloatColumnReader(v) => {\n                        let column = read(v, row_num);\n                        Block::Float(nulls, column)\n                    }\n                    ColumnReader::Int32ColumnReader(v) => {\n                        let column = read(v, row_num);\n\n                        let values = match fields\n                            .get(col_num)\n                            .unwrap()\n                            .get_basic_info()\n                            .converted_type()\n                        {\n                            ConvertedType::UINT_8 => Block::UTinyInt(\n                                nulls,\n                                column.into_iter().map(|v| v as u8).collect::<Vec<u8>>(),\n                            ),\n                            ConvertedType::UINT_16 => Block::USmallInt(\n                                nulls,\n                                column.into_iter().map(|v| v as u16).collect::<Vec<u16>>(),\n                            ),\n                            ConvertedType::UINT_32 => Block::UInt(\n                                nulls,\n                                column.into_iter().map(|v| v as u32).collect::<Vec<u32>>(),\n                            ),\n                            ConvertedType::INT_8 => Block::TinyInt(\n                                nulls,\n                                column.into_iter().map(|v| v as i8).collect::<Vec<i8>>(),\n                            ),\n                            ConvertedType::INT_16 => Block::SmallInt(\n                                nulls,\n                                column.into_iter().map(|v| v as i16).collect::<Vec<i16>>(),\n                            ),\n                            ConvertedType::NONE => Block::Int(nulls, column),\n                            _ => unreachable!(),\n                        };\n                        values\n                    }\n                    ColumnReader::Int64ColumnReader(v) => {\n                        let column = read(v, row_num);\n                        match fields.get(col_num).unwrap().get_basic_info().logical_type() {\n                            Some(_) => Block::Timestamp(nulls, column),\n                            None => match fields\n                                .get(col_num)\n                                .unwrap()\n                                .get_basic_info()\n                                .converted_type()\n                            {\n                                ConvertedType::NONE => Block::BigInt(nulls, column),\n                                ConvertedType::UINT_64 => Block::UBigInt(\n                                    nulls,\n                                    column.into_iter().map(|v| v as u64).collect::<Vec<u64>>(),\n                                ),\n                                _ => unreachable!(),\n                            },\n                        }\n                    }\n                    _ => unreachable!(),\n                }\n            })\n            .collect();\n\n        let bind: Vec<_> = blocks.iter().map(|b| b.into()).collect();\n        let mut stmt = taos.stmt(&sql).unwrap();\n        stmt.multi_bind(&bind).unwrap();\n        stmt.execute().unwrap();\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","sync","mod.rs"],"content":"use anyhow::Result;\nuse clap::Args;\nuse futures::prelude::*;\nuse taos::query::Dsn;\nuse taosx::plugins::sink::taos::TaosSinkBuilder;\nuse taosx::plugins::source::taos::TaosSourceBuilder;\nuse taosx::stream::source::XSourceBuilder;\nuse taosx::stream::stream::XSinkBuilder;\n\nuse taosx::stream::transformer::Action;\nuse taosx::TaosOpts;\n\n#[derive(Debug, Args)]\n/// Import external files to TDengine.\npub(crate) struct App {\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for source TDengine: taos:///db1, for eg.\n    from: Dsn,\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for target TDengine: taos:///db2, for eg.\n    to: Dsn,\n\n    /// Transformer actions.\n    ///\n    /// Supported action format:\n    ///\n    /// - 'add-tag:tag1=value1': add a tag named `tag1`, and valued `value1`.\n    /// - 'select:subset:a,b,c': select three columns: `a`, `b`, `c`\n    /// - 'select:exclude:a,b,c': select all columns except the three: `a`, `b`, `c`\n    /// - 'rename-table:prefix:v1_': rename all tables as `v1_{{ name }}`\n    /// - 'rename-super-table:suffix:_stb': rename all super tables as suffixed '_stb'\n    /// - 'rename-child-stable:template:prefix_{{ name }}_stb': rename all super tables with prefix 'prefix_' and suffix '_stb'\n    #[clap(short = 'T', long)]\n    transform: Vec<Action>,\n    /// Number of workers for TMQ consumers.\n    #[clap(short = 'j', long)]\n    workers: Option<usize>,\n}\n\nimpl App {\n    pub async fn run_with_taos_opts(self, _opts: &TaosOpts) -> Result<()> {\n        log::debug!(\"app: {self:?}\");\n\n        let mut source_builder = TaosSourceBuilder::from_dsn(self.from)?;\n        let max_workers = source_builder.max_workers();\n\n        let sink_builder = TaosSinkBuilder::from_dsn(self.to)?.with_transformer(self.transform);\n\n        let mut workers = self.workers.unwrap_or(max_workers);\n        if max_workers != 0 && workers > max_workers {\n            log::warn!(\"maximum workers for the stream is {max_workers} while you want {workers}, reduce to limit\");\n            workers = max_workers;\n        }\n        if workers == 0 {\n            workers = 1;\n        }\n        let mut handlers = Vec::new();\n        log::info!(\"use {workers} workers (max: {max_workers})\");\n\n        for _ in 0..workers {\n            let source = source_builder.build_source()?;\n            let sink = sink_builder.build_sink()?;\n            handlers.push(tokio::spawn(async move { source.forward(sink).await }));\n        }\n\n        for hd in handlers {\n            hd.await??;\n        }\n\n        let summary = sink_builder.summary();\n\n        log::info!(\n            \"Summary: total synced {} blocks with {} rows\",\n            summary.blocks(),\n            summary.rows()\n        );\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","main.rs"],"content":"mod commands;\nuse clap::{Parser, Subcommand};\nuse log::Level;\nuse pretty_env_logger::env_logger::fmt::Color;\nuse std::io::prelude::*;\nuse taosx::TaosOpts;\n\n#[derive(Parser, Debug)]\n#[clap(author, version, about)]\nstruct Cli {\n    #[clap(flatten)]\n    options: TaosOpts,\n    #[clap(short, long)]\n    log_level: Option<log::LevelFilter>,\n    #[clap(subcommand)]\n    command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    Export(commands::export::App),\n    Import(commands::import::App),\n    Backup(commands::backup::App),\n    Restore(commands::restore::App),\n    Sync(commands::sync::App),\n    #[clap(external_subcommand)]\n    External(Vec<String>),\n}\n\npub fn cli<'help>() -> clap::Command<'help> {\n    clap::Command::new(\"taosx\")\n}\n\n#[tokio::main(flavor = \"multi_thread\", worker_threads = 10)]\nasync fn main() -> anyhow::Result<()> {\n    let cli = Cli::parse();\n\n    let mut builder = pretty_env_logger::formatted_timed_builder();\n    if let Some(level) = cli.log_level {\n        builder.filter_level(level);\n    } else if let Ok(s) = ::std::env::var(\"RUST_LOG\") {\n        builder.parse_filters(&s);\n    } else {\n        builder.filter_level(log::LevelFilter::Info);\n    }\n    builder\n        .format_module_path(true)\n        .format(|buf, record| -> std::result::Result<(), std::io::Error> {\n            fn colored_level<'a>(\n                style: &'a mut pretty_env_logger::env_logger::fmt::Style,\n                level: Level,\n            ) -> pretty_env_logger::env_logger::fmt::StyledValue<'a, &'static str> {\n                match level {\n                    Level::Trace => style.set_color(Color::Magenta).value(\"TRACE\"),\n                    Level::Debug => style.set_color(Color::Blue).value(\"DEBUG\"),\n                    Level::Info => style.set_color(Color::Green).value(\"INFO\"),\n                    Level::Warn => style.set_color(Color::Yellow).value(\"WARN \"),\n                    Level::Error => style.set_color(Color::Red).value(\"ERROR\"),\n                }\n            }\n            let mut style = buf.style();\n            let level = colored_level(&mut style, record.level());\n            let mut mod_path = buf.style();\n\n            let mod_path = mod_path.set_bold(true).value(format!(\n                \"{}:{}\",\n                record.file().unwrap_or(\"unknown\"),\n                record.line().unwrap_or(0),\n            ));\n            writeln!(\n                buf,\n                \"[{:29} {: <5}] {} > {}\",\n                chrono::Local::now().format(\"%Y-%m-%dT%H:%M:%S.%f\"),\n                level,\n                mod_path,\n                record.args()\n            )\n        })\n        // .is_test(true)\n        .init();\n    let command = cli.command;\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    match command {\n        Commands::Export(app) => {\n            app.run_with_taos_opts(&cli.options);\n        }\n        Commands::Import(app) => {\n            app.run_with_taos_opts(&cli.options);\n        }\n        Commands::Backup(app) => {\n            app.run_with_taos_opts(&cli.options);\n        }\n        Commands::Restore(app) => {\n            app.run_with_taos_opts(&cli.options);\n        }\n        Commands::Sync(app) => {\n            app.run_with_taos_opts(&cli.options).await?;\n        }\n\n        Commands::External(args) => {\n            let (name, args) = args.split_first().unwrap();\n            println!(\"Call external plugin taosx-{name}: {args:?}\");\n            let cmd = format!(\"taosx-{name}\");\n            std::process::Command::new(&cmd)\n                .args(args)\n                .spawn()\n                .expect(&format!(\"unable to run command {cmd}\"));\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","config","mod.rs"],"content":"use anyhow::Result;\nuse linked_hash_map::LinkedHashMap as HashMap;\nuse mdsn::Dsn;\nuse serde::{Deserialize, Serialize};\n\npub struct XSource {\n    plugin: String,\n    dsn: Dsn,\n    options: HashMap<String, String>,\n}\n\npub struct XTransformer {\n    pub name: String,\n    pub options: HashMap<String, String>,\n}\n\npub struct XSink {\n    dsn: Dsn,\n    options: HashMap<String, String>,\n}\npub struct XStream {\n    pub from: Vec<XSource>,\n    pub transformer: Vec<XTransformer>,\n    pub to: Vec<XSink>,\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n    use anyhow::Result;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","lib.rs"],"content":"use bitvec_simd::BitVec;\nuse chrono_tz::Tz;\nuse clap::Args;\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse taos::prelude::*;\nuse taos::{block::*, helpers::ColumnMeta};\n\nuse url::Url;\n\npub mod config;\npub mod metrics;\npub mod plugins;\npub mod stream;\npub mod task;\npub mod util;\n\n#[derive(Debug, Args)]\npub struct TaosUri {\n    pub uri: Url,\n}\n#[derive(Debug, Args)]\npub struct TaosOpts {\n    /// TDengine host\n    #[clap(short, long, env = \"TAOS_HOST\", group = \"taos-opts\")]\n    pub host: Option<String>,\n    /// TDengine port\n    #[clap(short, long, env = \"TAOS_PORT\", group = \"taos-opts\")]\n    pub port: Option<u16>,\n    /// TDengine username\n    #[clap(short, long, env = \"TAOS_USERNAME\", group = \"taos-opts\")]\n    pub username: Option<String>,\n    /// TDengine password for the user\n    #[clap(short = 'P', long, env = \"TAOS_PASSWORD\", group = \"taos-opts\")]\n    pub password: Option<String>,\n    /// Choose database for the connection\n    #[clap(short, long, env = \"TAOS_DATABASE\", group = \"taos-opts\")]\n    pub database: Option<String>,\n    #[clap(short, long, env = \"TZ\")]\n    /// Timezone, example: Asia/Shanghai\n    pub timezone: Option<Tz>,\n    #[clap(short, long, env = \"TAOS_CFG_DIR\")]\n    /// TDengine config directory\n    pub cfg_dir: Option<PathBuf>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Database {\n    pub name: String,\n    pub replica: i16,\n    pub quorum: i16,\n    pub days: i16,\n    pub keep: Option<String>,\n    // pub cache: i32,\n    pub blocks: i32,\n    pub minrows: i32,\n    pub maxrows: i32,\n    pub wallevel: i8,\n    pub fsync: i32,\n    pub comp: i8,\n    pub cachelast: i8,\n    pub precision: String,\n    pub update: i8,\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct TaosDescribe {\n    pub name: String,\n    pub describe: Describe,\n}\n\npub type TaosColumnMeta = ColumnMeta;\nimpl TaosDescribe {\n    pub fn new(name: String, describe: Describe) -> Self {\n        Self { name, describe }\n    }\n}\n\n// #[derive(Debug, Deserialize, Serialize, Clone)]\n// pub enum TaosColumnMeta {\n//     Column(TaosDescribed),\n//     Tag(TaosDescribed),\n// }\n\n// #[derive(Debug, Deserialize, Serialize, Clone)]\n// pub struct TaosDescribed {\n//     pub field: String,\n//     pub r#type: TaosDataType,\n//     pub length: usize,\n// }\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct TaosTag {\n    pub name: String,\n    pub tags: Vec<Vec<Value>>,\n}\n\nimpl TaosTag {\n    pub fn new<'b, T: BlockExt>(name: String, iter: taos::query::RowsIter<'b, T>) -> Self {\n        let mut values = vec![];\n        for row in iter {\n            let mut tmp = vec![];\n            for bv in row {\n                tmp.push(bv.1.into_value());\n            }\n            values.push(tmp);\n        }\n        Self { name, tags: values }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct TaosBlock {\n    pub name: String,\n    pub data: Vec<TaosColumn>,\n}\n\nimpl TaosBlock {\n    pub fn new<'b>(name: String, iter: impl Iterator<Item = BorrowedColumn<'b>>) -> Self {\n        let mut data = vec![];\n        for col in iter {\n            data.push(TaosColumn::new(col.into_owned()));\n        }\n        Self { name, data }\n    }\n\n    pub fn to_column_vec(&self) -> Vec<Column> {\n        self.data.to_vec().iter().map(|v| v.to_column()).collect()\n    }\n\n    // pub fn to_multi_bind(&self) -> Vec<MultiBind> {\n    //     self.data\n    //         .to_vec()\n    //         .iter()\n    //         .map(|v| v.to_column().to_multi_bind())\n    //         .collect()\n    // }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\n\npub enum TaosColumn {\n    Null(usize),\n    Bool(Vec<bool>, Vec<bool>),  // 1\n    TinyInt(Vec<bool>, Vec<i8>), // 2\n    SmallInt(Vec<bool>, Vec<i16>),\n    Int(Vec<bool>, Vec<i32>),\n    BigInt(Vec<bool>, Vec<i64>),\n    Float(Vec<bool>, Vec<f32>),\n    Double(Vec<bool>, Vec<f64>),\n    Binary(Vec<Option<Vec<u8>>>),\n    Timestamp(Vec<bool>, Vec<i64>),\n    NChar(Vec<Option<String>>),\n    UTinyInt(Vec<bool>, Vec<u8>),\n    USmallInt(Vec<bool>, Vec<u16>),\n    UInt(Vec<bool>, Vec<u32>),\n    UBigInt(Vec<bool>, Vec<u64>), // 14\n    Json(Vec<bool>, Vec<u8>),\n    VarChar(Vec<bool>, Vec<Vec<u8>>),\n    VarBinary(Vec<bool>, Vec<Vec<u8>>),\n    Decimal(Vec<bool>, Vec<f64>),\n    Blob(Vec<bool>, Vec<Vec<u8>>),\n}\n\nimpl TaosColumn {\n    pub fn new(column: Column) -> Self {\n        match column {\n            Column::Null(v) => Self::Null(v),\n            Column::Bool(is_nulls, v) => Self::Bool(is_nulls.into_bools(), v),\n            Column::TinyInt(is_nulls, v) => Self::TinyInt(is_nulls.into_bools(), v),\n            Column::SmallInt(is_nulls, v) => Self::SmallInt(is_nulls.into_bools(), v),\n            Column::Int(is_nulls, v) => Self::Int(is_nulls.into_bools(), v),\n            Column::BigInt(is_nulls, v) => Self::BigInt(is_nulls.into_bools(), v),\n            Column::Float(is_nulls, v) => Self::Float(is_nulls.into_bools(), v),\n            Column::Double(is_nulls, v) => Self::Double(is_nulls.into_bools(), v),\n            Column::Binary(v) => Self::Binary(v),\n            Column::Timestamp(is_nulls, v) => Self::Timestamp(is_nulls.into_bools(), v),\n            Column::NChar(v) => Self::NChar(v),\n            Column::UTinyInt(is_nulls, v) => Self::UTinyInt(is_nulls.into_bools(), v),\n            Column::USmallInt(is_nulls, v) => Self::USmallInt(is_nulls.into_bools(), v),\n            Column::UInt(is_nulls, v) => Self::UInt(is_nulls.into_bools(), v),\n            Column::UBigInt(is_nulls, v) => Self::UBigInt(is_nulls.into_bools(), v),\n            Column::Json(is_nulls, v) => Self::Json(is_nulls.into_bools(), v),\n            Column::VarChar(is_nulls, v) => Self::VarChar(is_nulls.into_bools(), v),\n            Column::VarBinary(is_nulls, v) => Self::VarBinary(is_nulls.into_bools(), v),\n            Column::Decimal(is_nulls, v) => Self::Decimal(is_nulls.into_bools(), v),\n            Column::Blob(is_nulls, v) => Self::Blob(is_nulls.into_bools(), v),\n        }\n    }\n\n    pub fn to_multi_bind(&self) -> Column {\n        match self {\n            TaosColumn::Null(v) => Column::Null(v.to_owned()),\n            TaosColumn::Bool(is_nulls, v) => Column::Bool(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::TinyInt(is_nulls, v) => Column::TinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::SmallInt(is_nulls, v) => Column::SmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Int(is_nulls, v) => Column::Int(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::BigInt(is_nulls, v) => Column::BigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Float(is_nulls, v) => Column::Float(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Double(is_nulls, v) => Column::Double(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Binary(v) => Column::Binary(v.to_owned()),\n            TaosColumn::Timestamp(is_nulls, v) => Column::Timestamp(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::NChar(v) => Column::NChar(v.to_owned()),\n            TaosColumn::UTinyInt(is_nulls, v) => Column::UTinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::USmallInt(is_nulls, v) => Column::USmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UInt(is_nulls, v) => Column::UInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UBigInt(is_nulls, v) => Column::UBigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Json(is_nulls, v) => Column::Json(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarChar(is_nulls, v) => Column::VarChar(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarBinary(is_nulls, v) => Column::VarBinary(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Decimal(is_nulls, v) => Column::Decimal(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Blob(is_nulls, v) => Column::Blob(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n        }\n    }\n\n    pub fn to_column(&self) -> Column {\n        match self {\n            TaosColumn::Null(v) => Column::Null(v.to_owned()),\n            TaosColumn::Bool(is_nulls, v) => Column::Bool(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::TinyInt(is_nulls, v) => Column::TinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::SmallInt(is_nulls, v) => Column::SmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Int(is_nulls, v) => Column::Int(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::BigInt(is_nulls, v) => Column::BigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Float(is_nulls, v) => Column::Float(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Double(is_nulls, v) => Column::Double(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Binary(v) => Column::Binary(v.to_owned()),\n            TaosColumn::Timestamp(is_nulls, v) => Column::Timestamp(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::NChar(v) => Column::NChar(v.to_owned()),\n            TaosColumn::UTinyInt(is_nulls, v) => Column::UTinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::USmallInt(is_nulls, v) => Column::USmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UInt(is_nulls, v) => Column::UInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UBigInt(is_nulls, v) => Column::UBigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Json(is_nulls, v) => Column::Json(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarChar(is_nulls, v) => Column::VarChar(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarBinary(is_nulls, v) => Column::VarBinary(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Decimal(is_nulls, v) => Column::Decimal(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Blob(is_nulls, v) => Column::Blob(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n        }\n    }\n}\n","traces":[{"line":72,"address":[4323058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4323144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4738550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4739056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4738930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4739069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[5032539,5031568],"length":1,"stats":{"Line":0},"fn_name":"deunicode_with_tofu_cow"},{"line":87,"address":[5035809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5032589,5032576,5031713],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":89,"address":[4739136],"length":1,"stats":{"Line":0},"fn_name":"into_owned"},{"line":98,"address":[4592496,4592233,4592352,4592606,4592144,4592185,4592278,4592472],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":99,"address":[5035856],"length":1,"stats":{"Line":0},"fn_name":"try_init_timed"},{"line":100,"address":[5032137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5035883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4739184],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":103,"address":[4592560,4592158,4592223,4592394,4592372,4592416,4592516,4592538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5032251,5032308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4739233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4742616,4742592,4742664],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":119,"address":[10784413,10784254,10784511,10784478,10784558,10784211,10784349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4742654,4742611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4592931,4592668,4593229,4593115,4592976,4592707,4592892,4592752,4593022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8564064],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":127,"address":[5032738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5036030,5036090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4739831,4740605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4739941,4739995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4740063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4740152,4740070,4740101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[4740074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4582538,4582503,4579904],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":165,"address":[4396050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[4396091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[10780386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[5037249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[4581124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5266816],"length":1,"stats":{"Line":0},"fn_name":"is_synchronous<std::io::util::Sink>"},{"line":171,"address":[4450784],"length":1,"stats":{"Line":0},"fn_name":"nfd<unicode_normalization::stream_safe::StreamSafe<core::str::iter::Chars>>"},{"line":172,"address":[4450795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[4450845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4581149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[10780611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[4457712],"length":1,"stats":{"Line":0},"fn_name":"nfkd<core::str::iter::Chars>"},{"line":177,"address":[4457733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[4457743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4146004,4146229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4146235,4146024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4450864],"length":1,"stats":{"Line":0},"fn_name":"nfc<unicode_normalization::stream_safe::StreamSafe<core::str::iter::Chars>>"},{"line":182,"address":[4146247,4146064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[4457791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[4146104,4146317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[4146374,4146124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4457808],"length":1,"stats":{"Line":0},"fn_name":"nfkc<core::str::iter::Chars>"},{"line":187,"address":[4457829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[4146673,4146656],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":192,"address":[4717797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[4717800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4581786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[4457856],"length":1,"stats":{"Line":0},"fn_name":"stream_safe<core::str::iter::Chars>"},{"line":199,"address":[5033512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[4083632],"length":1,"stats":{"Line":0},"fn_name":"base_url"},{"line":203,"address":[4083667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[11894392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[4083680],"length":1,"stats":{"Line":0},"fn_name":"encoding_override"},{"line":208,"address":[4083701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5033585,5033664],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":212,"address":[4581918,4580481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[4582017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5034037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[4945780,4944756,4944884,4945012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[5034366,5034400,5034464],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":222,"address":[4582368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4582296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4582336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[4582522,4580145,4580260,4582423,4582553,4580085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[5033647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[5034556,5034649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[4083728],"length":1,"stats":{"Line":0},"fn_name":"syntax_violation_callback"},{"line":237,"address":[4083771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[5034712,5034851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4083907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[4083840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4083899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[10781255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4083991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[5039715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[5039817,5039972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[5039787,5040002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[5039924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[12448734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[7686436,7686370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4584601,4584706,4582576],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":267,"address":[4582659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[4813456,4813472,4813744,4813461,4813491,4813758],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":269,"address":[4582870,4582806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[11013086,11013056,11012997,11012976,11013038,11013008,11012992,11012981],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":272,"address":[4583386,4583054,4582962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[4084000],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":276,"address":[4084033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[4584013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[5070190,5070255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[10781440],"length":1,"stats":{"Line":1},"fn_name":"ensure"},{"line":284,"address":[5070384,5070425,5070473,5070518],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":287,"address":[5070508,5070411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[4584485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[4584523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[4945299,4945171,4945427,4946067,4945555,4945811,4945939,4945043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[4584569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[13990765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[12454064,12456738,12456789,12456840,12456432,12456687,12456330,12455040,12456016,12456032,12455986,12456381,12454016,12456021,12456483,12456534,12456273,12456585,12454033,12456636,12455010],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":301,"address":[4583165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[4583245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[4584721,4582924,4582821,4583364,4582997,4584620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[11010800],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":310,"address":[4584752,4584877],"length":1,"stats":{"Line":0},"fn_name":"reordered_levels"},{"line":313,"address":[4584840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[4957233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[8565383,8565646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[4585106,4584912],"length":1,"stats":{"Line":0},"fn_name":"reordered_levels_per_char"},{"line":321,"address":[8565822,8565337,8565792,8565706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[5149977,5150103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[4585137,4584998,4585093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[4953969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[4586515,4586672,4585216],"length":1,"stats":{"Line":1},"fn_name":"reorder_line"},{"line":333,"address":[5150238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[4585543,4585451,4586702,4586688],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":337,"address":[5150302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[4585888,4585659],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":128},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","metrics","mod.rs"],"content":"use metrics::{counter, describe_gauge, gauge, histogram, register_gauge, register_histogram};\nuse metrics_exporter_prometheus::PrometheusBuilder;\nuse std::{\n    collections::HashSet,\n    net::SocketAddr,\n    time::{Duration, Instant},\n};\n\n#[derive(Debug, Default)]\npub struct Metrics {\n    listen: Option<SocketAddr>,\n    push: Option<String>,\n    push_interval: Option<Duration>,\n    interval: Option<u16>,\n}\n\npub fn process_metrics_init() {\n    register_gauge!(\"taosx_process_cpu_percent\");\n\n    describe_gauge!(\"taosx_process_cpu_percent\", \"CPU percent of the process\");\n}\n\npub fn process_metrics() -> anyhow::Result<()> {\n    let ps = procfs::process::Process::myself()?;\n    let stat = &ps.stat;\n    let ticks = procfs::ticks_per_second()?;\n    let mut proc = psutil::process::Process::current()?;\n\n    let cpu = proc.cpu_percent()?;\n    gauge!(\"taosx_process_cpu_percent\", cpu as f64);\n\n    let mem = proc.memory_percent()?;\n    gauge!(\n        \"taosx_process_mem_percent\",\n        (mem * 10000.0) as u64 as f64 / 100.0\n    );\n\n    let threads = ps.tasks()?.count();\n    gauge!(\"taosx_process_threads\", threads as f64);\n\n    let open_files = proc.open_files()?.len();\n    gauge!(\"taosx_process_open_files\", open_files as f64);\n\n    let uptime = (ps.stat.utime + ps.stat.stime) as f64 / ticks as f64;\n    gauge!(\"taosx_process_uptime\", uptime as f64);\n\n    let io = ps.io()?;\n    gauge!(\"taosx_process_io_read_bytes\", io.read_bytes as f64);\n    gauge!(\"taosx_process_io_write_bytes\", io.write_bytes as f64);\n\n    let fd = ps.fd()?;\n    let mut inodes = HashSet::new();\n    for fd in fd {\n        use procfs::process::FDTarget;\n        match fd.target {\n            FDTarget::Net(inode) => {\n                inodes.insert(inode);\n            }\n            FDTarget::Socket(inode) => {\n                inodes.insert(inode);\n            }\n            _ => {}\n        }\n    }\n\n    let (mut rx, mut tx) = (0, 0);\n\n    let tcp = procfs::net::tcp().unwrap();\n    let tcp6 = procfs::net::tcp6().unwrap();\n    for entry in tcp.into_iter().chain(tcp6) {\n        // find the process (if any) that has an open FD to this entry's inode\n        let local_address = format!(\"{}\", entry.local_address);\n        let remote_addr = format!(\"{}\", entry.remote_address);\n        let state = format!(\"{:?}\", entry.state);\n        if inodes.contains(&entry.inode) {\n            log::debug!(\n                \"{:<26} {:<26} {:<15} {:<12} {}/{} {}/{}\",\n                local_address,\n                remote_addr,\n                state,\n                entry.inode,\n                stat.pid,\n                stat.comm,\n                entry.rx_queue,\n                entry.tx_queue\n            );\n            rx += entry.rx_queue;\n            tx += entry.tx_queue;\n        }\n    }\n\n    gauge!(\"taosx_process_net_rx\", rx as f64);\n    gauge!(\"taosx_process_net_tx\", tx as f64);\n    Ok(())\n}\n\nimpl Metrics {\n    pub fn init(self) -> anyhow::Result<()> {\n        let mut exporter = PrometheusBuilder::new();\n        let interval = self.interval();\n        let dur = Duration::from_secs(interval as u64);\n\n        if let Some(listen) = self.listen {\n            exporter = exporter.with_http_listener(listen);\n        }\n        if let Some(push) = self.push {\n            let interval = self.push_interval.unwrap_or(Duration::from_secs(30));\n            exporter = exporter.with_push_gateway(push, interval)?;\n        }\n        let _ = exporter.install()?;\n        process_metrics_init();\n        std::thread::spawn(move || loop {\n            let _ = process_metrics();\n            metrics::increment_counter!(\"up seconds\");\n            std::thread::sleep(dur);\n        });\n        Ok(())\n    }\n\n    pub fn interval(&self) -> u16 {\n        self.interval.unwrap_or(1)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","mod.rs"],"content":"mod sync;\n\npub mod sink;\npub mod source;\npub mod transformer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","sink","mod.rs"],"content":"pub mod taos;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","sink","taos","mod.rs"],"content":"use itertools::Itertools;\nuse linked_hash_map::LinkedHashMap;\nuse mdsn::IntoDsn;\nuse std::{\n    cell::Cell,\n    fmt::Debug,\n    sync::{\n        atomic::{AtomicUsize, Ordering},\n        Arc,\n    },\n    task::Poll,\n};\n\nuse futures::{Sink, Stream, TryStreamExt};\nuse taos::{\n    block::{itypes::IsValue, Describe, Ty},\n    helpers::{ColumnMeta, Described},\n    query::Dsn,\n    tmq::{Consumer, TmqBuilder},\n};\n\nuse crate::{\n    stream::{\n        stream::*,\n        transformer::{Action, AddTag, AddTagOpts, Select},\n    },\n    util::sync_table,\n};\nuse taos::prelude::sync::*;\n\npub struct TaosSinkBuilder {\n    dsn: Dsn,\n    builder: Manager,\n    worker: AtomicUsize,\n    transformer: Arc<Option<Vec<Action>>>,\n    metrics: Arc<Summary>,\n}\n\n#[derive(Debug)]\npub struct TaosSink {\n    id: usize,\n    taos: Taos,\n    transformer: Arc<Option<Vec<Action>>>,\n    metrics: Arc<Summary>,\n}\n\nimpl XSinkBuilder for TaosSinkBuilder {\n    type Error = Error;\n\n    fn from_dsn<T: IntoDsn>(dsn: T) -> Result<Self, Self::Error> {\n        let mut dsn = dsn.into_dsn()?;\n        if let Some(db) = dsn.database.take() {\n            let taos = Taos::from_dsn(&dsn)?;\n            let db_info: Option<String> = taos.query_one(format!(\n                \"select * from information_schema.user_databases where name = \\\"{db}\\\"\"\n            ))?;\n            if db_info.is_none() {\n                log::warn!(\"create database {db} with default parameters since it's not exist\");\n                taos.exec(format!(\"create database if not exists {db}\"))?;\n            } else {\n                taos.exec(format!(\"create topic if not exists {db} as database {db}\"))?;\n                dsn.params.insert(\"topics\".to_string(), db.to_string());\n            }\n            dsn.database = Some(db);\n        } else {\n            return Err(Error::InvalidDatabase(\n                \"taos sink plugin requires a database name\".to_string(),\n            ));\n        }\n\n        let builder = Manager::from_dsn(&dsn)?;\n        Ok(Self {\n            dsn,\n            builder,\n            transformer: Arc::new(None),\n            worker: AtomicUsize::new(0),\n            metrics: Default::default(),\n        })\n    }\n\n    fn with_transformer(mut self, transformer: Vec<Action>) -> Self {\n        self.transformer = Arc::new(Some(transformer));\n        self\n    }\n\n    fn build_sink(&self) -> Result<XSink<Self::Error>, Self::Error> {\n        let id = self\n            .worker\n            .fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n        Ok(TaosSink {\n            id,\n            taos: self.builder.connect()?,\n            transformer: self.transformer.clone(),\n            metrics: self.metrics.clone(),\n        }\n        .into())\n    }\n\n    fn summary(&self) -> &Summary {\n        &self.metrics\n    }\n}\n\npub fn sync_table_with_transformer(\n    from: &Taos,\n    to: &Taos,\n    db: &str,\n    table: &str,\n    transformer: &[Action],\n) -> Result<(), Error> {\n    use taos::prelude::sync::*;\n    assert!(transformer.len() > 0);\n\n    let stable: Option<String> = from\n        .query_one(format!(\n            \"select stable_name from information_schema.user_tables where db_name = '{db}' and table_name = \\\"{table}\\\"\"\n        ))?\n        .unwrap();\n\n    if let Some(stable) = stable {\n        let desc = from.describe(&format!(\"{db}.`{stable}`\"))?;\n        let mut stable2 = stable.to_string();\n\n        let transformed_desc =\n            transformer\n                .iter()\n                .fold(desc.clone(), |mut desc, action| match action {\n                    Action::AddTag(add_tag) => {\n                        desc.push(ColumnMeta::Tag(Described {\n                            field: add_tag.name.clone(),\n                            ty: Ty::VarChar,\n                            length: add_tag.len,\n                        }));\n                        desc\n                    }\n                    Action::Select(select) => match select {\n                        Select::Subset { subset } => desc\n                            .into_iter()\n                            .filter(|f| subset.contains(&f.field))\n                            .collect(),\n                        Select::Rename { rename } => desc\n                            .into_iter()\n                            .map(|mut f| {\n                                if let Some(v) = rename.get(f.field()) {\n                                    f.field = v.to_string();\n                                    f\n                                } else {\n                                    f\n                                }\n                            })\n                            .collect(),\n                        Select::Exclude { exclude } => desc\n                            .into_iter()\n                            .filter(|f| !exclude.contains(&f.field))\n                            .collect(),\n                    },\n                    Action::RenameChildTable(rename) | Action::RenameTable(rename) => {\n                        match rename {\n                            crate::stream::transformer::RenameOpts::Prefix { prefix } => {\n                                stable2 = format!(\"{prefix}{stable}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Suffix { suffix } => {\n                                stable2 = format!(\"{stable}{suffix}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Template { template } => {\n                                stable2 = template.replace(\"{{ name }}\", &stable);\n                            }\n                        }\n                        desc\n                    }\n                    _ => desc,\n                });\n\n        log::trace!(\"create {stable2}\");\n        let sql = transformed_desc.to_create_table_sql(&stable2);\n        to.exec(sql)?;\n\n        let names = transformer.iter().fold(\n            desc.tag_names().map(ToString::to_string).collect_vec(),\n            |names, action| match action {\n                Action::Select(select) => match select {\n                    Select::Subset { subset } => names\n                        .into_iter()\n                        .filter(|name| subset.contains(name))\n                        .collect_vec(),\n                    Select::Rename { rename } => names\n                        .into_iter()\n                        .map(|f| {\n                            if let Some(v) = rename.get(&f) {\n                                format!(\"`{f}` as `{v}`\")\n                            } else {\n                                f\n                            }\n                        })\n                        .collect_vec(),\n                    Select::Exclude { exclude } => names\n                        .into_iter()\n                        .filter(|name| !exclude.contains(name))\n                        .collect_vec(),\n                },\n                _ => names,\n            },\n        );\n\n        let names = names.join(\",\");\n        let children: Vec<Vec<Value>> = from\n            .query(format!(\"select tbname,{names} from {stable}\"))?\n            .deserialize()\n            .try_collect()?;\n\n        let children = transformer\n            .iter()\n            .fold(children, |children, action| match action {\n                Action::AddTag(add_tag) => match &add_tag.opts {\n                    AddTagOpts::Value { value } => children\n                        .into_iter()\n                        .map(|mut v| {\n                            v.push(Value::VarChar(value.clone()));\n                            v\n                        })\n                        .collect_vec(),\n                    AddTagOpts::Template { template: _ } => todo!(),\n                },\n                Action::RenameChildTable(rename) | Action::RenameTable(rename) => match rename {\n                    crate::stream::transformer::RenameOpts::Prefix { prefix } => children\n                        .into_iter()\n                        .map(|mut child| {\n                            let name = child[0].strict_as_str();\n                            child[0] = Value::VarChar(format!(\"{prefix}{name}\"));\n                            child\n                        })\n                        .collect_vec(),\n                    crate::stream::transformer::RenameOpts::Suffix { suffix } => children\n                        .into_iter()\n                        .map(|mut child| {\n                            let name = child[0].strict_as_str();\n                            child[0] = Value::VarChar(format!(\"{name}{suffix}\"));\n                            child\n                        })\n                        .collect_vec(),\n                    crate::stream::transformer::RenameOpts::Template { template } => children\n                        .into_iter()\n                        .map(|mut child| {\n                            let name = child[0].strict_as_str();\n                            child[0] = Value::VarChar(template.replace(\"{{ name }}\", name));\n                            child\n                        })\n                        .collect_vec(),\n                },\n                _ => children,\n            });\n\n        // todo: use par_iter to speed up tables creation.\n        // todo: single table not work, blocked by https://jira.taosdata.com:18080/browse/TD-16117\n        for child in children {\n            let tbname = child[0].to_string().unwrap();\n            let tags_values = child[1..].into_iter().map(|v| v.to_sql_value()).join(\",\");\n            to.exec(format!(\n                \"create table if not exists {tbname} using {stable2} tags({tags_values})\"\n            ))\n            .unwrap();\n        }\n\n        // let fields: Vec<Value> = from\n        //     .query_one(format!(\n        //         \"select {names} from {stable} where tbname = '{table}'\"\n        //     ))?\n        //     .unwrap();\n\n        // let tags_values = fields.into_iter().map(|v| v.to_sql_value()).join(\",\");\n        // to.exec(format!(\n        //     \"create table if not exists {table} using {stable} tags({tags_values})\"\n        // ))?;\n    } else {\n        let mut table = table.to_string();\n        log::info!(\"describe table {table}\");\n        let desc = from.describe(&format!(\"{db}.`{table}`\"))?;\n        log::info!(\"table {table}: {desc:?}\");\n\n        let desc = transformer\n            .iter()\n            .fold(desc.clone(), |desc, action| match action {\n                Action::Select(select) => match select {\n                    Select::Subset { subset } => desc\n                        .into_iter()\n                        .filter(|f| subset.contains(&f.field))\n                        .collect(),\n                    Select::Rename { rename } => desc\n                        .into_iter()\n                        .map(|mut f| {\n                            if let Some(v) = rename.get(f.field()) {\n                                f.field = v.to_string();\n                                f\n                            } else {\n                                f\n                            }\n                        })\n                        .collect(),\n                    Select::Exclude { exclude } => desc\n                        .into_iter()\n                        .filter(|f| !exclude.contains(&f.field))\n                        .collect(),\n                },\n                Action::RenameTable(rename) => {\n                    match rename {\n                        crate::stream::transformer::RenameOpts::Prefix { prefix } => {\n                            table = format!(\"{prefix}{table}\");\n                        }\n                        crate::stream::transformer::RenameOpts::Suffix { suffix } => {\n                            table = format!(\"{table}{suffix}\");\n                        }\n                        crate::stream::transformer::RenameOpts::Template { template } => {\n                            table = template.replace(\"{{ name }}\", &table);\n                        }\n                    }\n                    desc\n                }\n                _ => desc,\n            });\n        let sql = desc.to_create_table_sql(&table);\n        log::info!(\"exec sql: {sql}\");\n        to.exec(sql).unwrap();\n    }\n    Ok(())\n}\n\nimpl Sink<(&Taos, SyncBlock)> for TaosSink {\n    type Error = Error;\n\n    fn poll_ready(\n        self: std::pin::Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> std::task::Poll<Result<(), Self::Error>> {\n        Poll::Ready(Ok(()))\n    }\n\n    fn start_send(\n        mut self: std::pin::Pin<&mut Self>,\n        item: (&Taos, SyncBlock),\n    ) -> Result<(), Self::Error> {\n        self.consume_block(item.0, &item.1)\n    }\n\n    fn poll_flush(\n        self: std::pin::Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> std::task::Poll<Result<(), Self::Error>> {\n        Poll::Ready(Ok(()))\n    }\n\n    fn poll_close(\n        self: std::pin::Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> std::task::Poll<Result<(), Self::Error>> {\n        Poll::Ready(Ok(()))\n    }\n}\n\nimpl TaosxSink for TaosSink {\n    type Error = Error;\n\n    fn batch_size(&self) -> usize {\n        1\n    }\n\n    fn flush(&mut self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn consume_block(&mut self, taos: &Taos, block: &SyncBlock) -> Result<(), Self::Error> {\n        let idx = self.id;\n        let db = block.tmq_db_name().unwrap();\n        taos.exec(format!(\"use {db}\"))?;\n        let table = block.tmq_table_name().unwrap();\n        log::debug!(\"[{idx}] db: {db}, table: {table}\");\n\n        if let Some(transformer) = self.transformer.as_ref() {\n            // if self.taos.exec(format!(\"describe {table}\")).is_err() {\n            //     sync_table_with_transformer(taos, &self.taos, db, &table, &transformer)?;\n            // }\n            // let mut table = table.to_string();\n            // let fields = block.fields();\n\n            // let mut bind: Vec<TaosMultiBind> = Vec::new();\n\n            // for action in transformer {\n            //     match action {\n            //         Action::Select(Select::Subset { subset }) => {\n            //             bind = block\n            //                 .columns_iter()\n            //                 .zip(fields)\n            //                 .filter_map(|(col, field)| {\n            //                     if subset.contains(&field.name().to_string()) {\n            //                         Some(col.into())\n            //                     } else {\n            //                         None\n            //                     }\n            //                 })\n            //                 .collect()\n            //         }\n            //         Action::Select(Select::Exclude { exclude }) => {\n            //             bind = block\n            //                 .columns_iter()\n            //                 .zip(fields)\n            //                 .filter_map(|(col, field)| {\n            //                     if !exclude.contains(&field.name().to_string()) {\n            //                         Some(col.into())\n            //                     } else {\n            //                         None\n            //                     }\n            //                 })\n            //                 .collect()\n            //         }\n            //         Action::RenameChildTable(rename) | Action::RenameTable(rename) => {\n            //             match rename {\n            //                 crate::stream::transformer::RenameOpts::Prefix { prefix } => {\n            //                     table = format!(\"{prefix}{table}\");\n            //                 }\n            //                 crate::stream::transformer::RenameOpts::Suffix { suffix } => {\n            //                     table = format!(\"{table}{suffix}\");\n            //                 }\n            //                 crate::stream::transformer::RenameOpts::Template { template } => {\n            //                     table = template.replace(\"{{ name }}\", &table);\n            //                 }\n            //             }\n            //         }\n            //         _ => (),\n            //     }\n            // }\n            // if bind.is_empty() {\n            //     bind = block.columns_iter().map(Into::into).collect();\n            // }\n\n            // let questions = std::iter::repeat(\"?\").take(bind.len()).join(\",\");\n            // let mut stmt = self\n            //     .taos\n            //     .stmt(format!(\"insert into {table} values({questions})\"))?;\n            // stmt.multi_bind(&bind)?;\n            // stmt.execute()?;\n            // let inserted = stmt.affected_rows();\n            // log::info!(\"[{idx}] inserted {inserted} rows into {table}\");\n            // return Ok(());\n            let mut table2 = table.to_string();\n            let fields = block.fields();\n\n            let mut bind: Vec<TaosMultiBind> = Vec::new();\n\n            for action in transformer {\n                match action {\n                    Action::Select(Select::Subset { subset }) => {\n                        bind = block\n                            .columns_iter()\n                            .zip(fields)\n                            .filter_map(|(col, field)| {\n                                if subset.contains(&field.name().to_string()) {\n                                    Some(col.into())\n                                } else {\n                                    None\n                                }\n                            })\n                            .collect()\n                    }\n                    Action::Select(Select::Exclude { exclude }) => {\n                        bind = block\n                            .columns_iter()\n                            .zip(fields)\n                            .filter_map(|(col, field)| {\n                                if !exclude.contains(&field.name().to_string()) {\n                                    Some(col.into())\n                                } else {\n                                    None\n                                }\n                            })\n                            .collect()\n                    }\n                    Action::RenameChildTable(rename) | Action::RenameTable(rename) => {\n                        match rename {\n                            crate::stream::transformer::RenameOpts::Prefix { prefix } => {\n                                table2 = format!(\"{prefix}{table}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Suffix { suffix } => {\n                                table2 = format!(\"{table}{suffix}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Template { template } => {\n                                table2 = template.replace(\"{{ name }}\", &table);\n                            }\n                        }\n                    }\n                    _ => (),\n                }\n            }\n            if bind.is_empty() {\n                bind = block.columns_iter().map(Into::into).collect();\n            }\n\n            if self.taos.exec(format!(\"describe {table2}\")).is_err() {\n                sync_table_with_transformer(taos, &self.taos, db, &table, &transformer)?;\n            }\n            let questions = std::iter::repeat(\"?\").take(bind.len()).join(\",\");\n            let mut stmt = self\n                .taos\n                .stmt(format!(\"insert into {table2} values({questions})\"))?;\n            stmt.multi_bind(&bind)?;\n            stmt.execute()?;\n            let inserted = stmt.affected_rows();\n            self.metrics.blocks.fetch_add(1, Ordering::SeqCst);\n            self.metrics.rows.fetch_add(inserted, Ordering::SeqCst);\n            log::info!(\"[{idx}] inserted {inserted} rows into {table2}\");\n            return Ok(());\n        }\n\n        if self.taos.exec(format!(\"describe {table}\")).is_err() {\n            log::info!(\"[{idx}] synchronize table schema {table}\");\n            sync_table(taos, &self.taos, &db, &table)?;\n            log::info!(\"[{idx}] synchronize table {table} done\");\n        }\n\n        let bind: Vec<TaosMultiBind> = block.columns_iter().map(|col| col.into()).collect();\n        let questions = std::iter::repeat(\"?\").take(bind.len()).join(\",\");\n        let mut stmt = self\n            .taos\n            .stmt(format!(\"insert into {table} values({questions})\"))?;\n        stmt.multi_bind(&bind)?;\n        stmt.execute()?;\n        let inserted = stmt.affected_rows();\n        self.metrics.blocks.fetch_add(1, Ordering::SeqCst);\n        self.metrics.rows.fetch_add(inserted, Ordering::SeqCst);\n        log::info!(\"[{idx}] inserted {inserted} rows into {table}\");\n        Ok(())\n    }\n\n    fn consume_raw_block(&mut self, _: &[u8]) -> Result<(), Self::Error> {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_line(\n        &mut self,\n        item: &str,\n        precision: SchemalessPrecision,\n    ) -> Result<(), Self::Error> {\n        self.taos\n            .schemaless_insert([item], SchemalessProtocol::Line, precision)?;\n        Ok(())\n    }\n\n    fn consume_schemaless_telnet(\n        &mut self,\n        item: &str,\n        precision: SchemalessPrecision,\n    ) -> Result<(), Self::Error> {\n        self.taos\n            .schemaless_insert([item], SchemalessProtocol::Telnet, precision)?;\n        Ok(())\n    }\n\n    fn consume_schemaless_json(\n        &mut self,\n        item: &str,\n        precision: SchemalessPrecision,\n    ) -> Result<(), Self::Error> {\n        self.taos\n            .schemaless_insert([item], SchemalessProtocol::Json, precision)?;\n        Ok(())\n    }\n}\n\n#[taos::test(log_level = \"debug\", databases = 2)]\nasync fn test(taos: &Taos, databases: &[&str]) -> Result<(), Error> {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut tmq = TmqBuilder::from_dsn(format!(\n        \"taos:///{db1}?topics={db1}&group.id={db1}&wait=1000\"\n    ))?\n    .build()?;\n\n    let db2 = databases[1];\n\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?\n        .build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    while let Some(rs) = tmq.poll() {\n        let mut rs = rs?;\n        for block in rs.blocks_iter() {\n            log::info!(\"send block\");\n            sink.send((taos, block)).await?;\n        }\n    }\n    drop(tmq);\n\n    taos.exec(format!(\"drop topic {db1}\"))?;\n\n    let taos2 = Taos::from_dsn(format!(\"taos:///{db2}\"))?;\n\n    let mut rs = taos2.query(\"select * from stb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    Ok(())\n}\n\n#[taos::test(log_level = \"trace\", databases = 2)]\nasync fn test_with_action_add_tag(taos: &Taos, databases: &[&str]) -> Result<(), Error> {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut tmq =\n        TmqBuilder::from_dsn(format!(\"taos:///{db1}?topics={db1}&group.id={db1}\"))?.build()?;\n\n    let db2 = databases[1];\n\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?\n        .with_transformer(vec![Action::AddTag(AddTag {\n            name: \"f1\".to_string(),\n            len: 10,\n            opts: AddTagOpts::value(\"v1\"),\n        })])\n        .build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    while let Some(rs) = tmq.poll() {\n        let mut rs = rs?;\n        for block in rs.blocks_iter() {\n            log::info!(\"send block\");\n            sink.send((taos, block)).await?;\n        }\n    }\n    drop(tmq);\n\n    taos.exec(format!(\"drop topic {db1}\"))?;\n\n    let taos2 = Taos::from_dsn(format!(\"taos:///{db2}\"))?;\n    taos2.exec(\"reset query cache\")?;\n\n    let mut rs = taos2.query(\"select tbname, f1 from stb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from tb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from tb2\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    Ok(())\n}\n#[taos::test(log_level = \"trace\", databases = 2)]\nasync fn test_with_transformer(taos: &Taos, databases: &[&str]) -> Result<(), Error> {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut tmq =\n        TmqBuilder::from_dsn(format!(\"taos:///{db1}?topics={db1}&group.id={db1}\"))?.build()?;\n\n    let db2 = databases[1];\n\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?\n        .with_transformer(vec![\n            Action::AddTag(AddTag {\n                name: \"f1\".to_string(),\n                len: 10,\n                opts: AddTagOpts::value(\"v1\"),\n            }),\n            Action::Select(crate::stream::transformer::Select::exclude(vec![\n                \"c_bool\".to_string()\n            ])),\n            Action::RenameTable(crate::stream::transformer::RenameOpts::prefix(\"p_\")),\n        ])\n        .build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    while let Some(rs) = tmq.poll() {\n        let mut rs = rs?;\n        for block in rs.blocks_iter() {\n            log::info!(\"send block\");\n            sink.send((taos, block)).await?;\n        }\n    }\n    drop(tmq);\n\n    taos.exec(format!(\"drop topic {db1}\"))?;\n\n    let taos2 = Taos::from_dsn(format!(\"taos:///{db2}\"))?;\n\n    let mut rs = taos2.query(\"select * from p_stb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from p_tb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from p_tb2\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    Ok(())\n}\n\n#[taos::test(log_level = \"debug\", precision = \"ns\")]\nasync fn sink_sml_line(taos: &Taos) -> Result<(), Error> {\n    let database = \"_rs_sml_\";\n    taos.exec(format!(\"drop database if exists {database}\"))?;\n    taos.exec(format!(\"create database {database} schemaless 1\"))?;\n    let lines = vec![\"st,t1=abc c1=3i64,c3=\\\"def\\\",c2=false 1626006833639000000\"];\n    let builder = TaosSinkBuilder::from_dsn(format!(\"taos:///{database}\"))?;\n    let mut sink = builder.build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    for line in lines {\n        sink.send(XLine::new_line(line)).await?;\n    }\n\n    let taos = builder.builder.connect()?;\n    let table = taos.describe(\"st\")?;\n    dbg!(table);\n\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Weather {\n        _ts: String,\n        c1: i64,\n        c2: bool,\n        c3: String,\n    }\n    let mut rs = taos.query(\"select * from st\")?;\n    for block in rs.blocks_iter() {\n        dbg!(block.deserialize_into_vec::<Weather>());\n    }\n    Ok(())\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","source","csv","mod.rs"],"content":"use taos::query::Dsn;\n\npub struct Csv {\n    dsn: Dsn,\n}\n\nimpl Csv {\n    fn from_dsn(dsn: impl Into<Dsn>) -> Result<Self, anyhow::Error> {\n        let dsn = dsn.into();\n        Ok(Self { dsn })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","source","mod.rs"],"content":"pub mod csv;\npub mod taos;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","source","taos.rs"],"content":"use itertools::Itertools;\nuse linked_hash_map::LinkedHashMap;\nuse mdsn::{DsnError, IntoDsn};\nuse serde::Deserialize;\n\nuse std::{\n    any::Any,\n    borrow::Cow,\n    collections::{BTreeSet, HashMap},\n    ffi::c_void,\n    fmt::Debug,\n    marker::PhantomData,\n    ops::{Deref, DerefMut},\n    pin::Pin,\n    sync::{Arc, Weak},\n    task::Poll, str::FromStr,\n};\n\nuse futures::{Sink, Stream, StreamExt, TryStreamExt};\nuse taos::{\n    block::{itypes::IsValue, BlockStream, Field, Ty},\n    prelude::AsyncFetchable,\n    query::Dsn,\n    tmq::{Consumer, TmqBuilder},\n};\n\nuse crate::{\n    plugins::sink::taos::TaosSinkBuilder,\n    stream::{source::XSourceBuilder, stream::XSinkBuilder, transformer::Action},\n    util::sync_table,\n};\n\nuse crate::stream::stream::{SinkProtocol, TaosxSinkItem};\n\npub use taos::prelude::sync::*;\n\n#[derive(Debug)]\npub enum TaosItem {\n    Block(Arc<Taos>, SyncBlock),\n}\n\nimpl<'a> TaosxSinkItem for TaosItem {\n    fn protocol(&self) -> SinkProtocol {\n        match self {\n            Self::Block(_, _) => SinkProtocol::Block,\n        }\n    }\n\n    fn as_block(&self) -> (&Taos, &SyncBlock) {\n        match self {\n            Self::Block(taos, block) => (taos.as_ref(), &block),\n        }\n    }\n\n    fn as_raw_block(&self) -> Option<std::borrow::Cow<[u8]>> {\n        None\n    }\n\n    fn as_record(&self) -> Option<std::borrow::Cow<[Value]>> {\n        None\n    }\n\n    fn precision(&self) -> SchemalessPrecision {\n        SchemalessPrecision::NonConfigured\n    }\n\n    fn as_schemaless_line(&self) -> Option<&str> {\n        None\n    }\n\n    fn as_schemaless_telnet(&self) -> Option<&str> {\n        None\n    }\n\n    fn as_schemaless_json(&self) -> Option<&str> {\n        None\n    }\n\n    const PROTOCOL: SinkProtocol = SinkProtocol::__NoneExhaustive;\n}\n\npub struct TaosSourceBuilder {\n    from: Dsn,\n    manager: Manager,\n    tmq_builder: TmqBuilder,\n    max_workers: usize,\n    protocol: SinkProtocol,\n}\n\n#[derive(Debug)]\npub struct TaosSource {\n    taos: Arc<Taos>,\n    consumer: Consumer,\n    protocol: SinkProtocol,\n    rs: Option<ResultSet>,\n    blocks: Option<BlockStream>,\n}\n\nimpl Drop for TaosSource {\n    fn drop(&mut self) {\n        self.blocks.take();\n        self.rs.take();\n    }\n}\n\nuse taos::prelude::Error;\n\nimpl XSourceBuilder for TaosSourceBuilder {\n    type Error = Error;\n\n    type Item = TaosItem;\n    type XSource = TaosSource;\n\n    const NAME: &'static str = \"taos\";\n\n    fn from_dsn<T: IntoDsn>(dsn: T) -> Result<Self, Self::Error> {\n        let mut dsn = dsn.into_dsn()?;\n        if dsn.database.is_none() {\n            Err(DsnError::RequireDatabase(\n                \"please input a database or topic/stream name\".to_string(),\n            ))?;\n        }\n\n        let mut max_workers = 0;\n        let db = dsn.database.take().unwrap(); // unwrap is safe.\n\n        let taos = Taos::from_dsn(&dsn)?;\n\n        let topics: HashMap<_, _> = taos\n            .topics()?\n            .into_iter()\n            .map(|topic| (topic.name().to_string(), topic))\n            .collect();\n\n        #[derive(Default, Deserialize)]\n        struct VGroups {\n            vgroups: usize,\n        }\n        // For `?topics=` options.\n        if let Some(opt) = dsn.params.get(\"topics\") {\n            let topic_names = opt.split(\",\").map(|s| s.to_string()).collect_vec();\n            if topic_names.is_empty() {\n                return Err(Error::InvalidTopic(\"topics is empty\".to_string()));\n            }\n            let mut db_name = None;\n            {\n                for topic_name in topic_names {\n                    if let Some(topic) = topics.get(&topic_name) {\n                        let db = topic.db_name();\n                        let vgroups: VGroups = taos\n                            .query_one(format!(\n                            \"select * from information_schema.user_databases where name = '{db}'\"))?\n                            .unwrap_or_default();\n                        if max_workers < vgroups.vgroups {\n                            max_workers = vgroups.vgroups;\n                        }\n                        if let Some(db1) = db_name.as_ref() {\n                            if db1 != topic.db_name() {\n                                // return Err(Error::InvalidTopic(\n                                //     \"topics should be in same database\".to_string(),\n                                // ));\n                                log::warn!(\"subscribe topics in different database\");\n                            }\n                        } else {\n                            db_name = Some(topic.db_name().to_string());\n                        }\n                    } else {\n                        return Err(Error::InvalidTopic(format!(\"topic {topic_name} not found\")));\n                    }\n                }\n            }\n            dsn.database = db_name;\n            // check group id\n            if !dsn.params.contains_key(\"group.id\") {\n                let opt = opt.to_string();\n                dsn.params.insert(\"group.id\".to_string(), opt);\n            }\n        } else {\n            // If no `topics` option in params, check if the database identity is topic(s) or not.\n            dsn.params.insert(\"topics\".to_string(), db.to_string());\n            for db in db.split(\",\") {\n                if let Some(topic) = topics.get(db) {\n                    let db_name = topic.db_name();\n                    dsn.database = Some(db_name.to_string());\n                } else {\n                    // todo: support subscribe stable/table.\n                    let db_info: Option<String> = taos.query_one(format!(\n                        \"select * from information_schema.user_databases where name = \\\"{db}\\\"\"\n                    ))?;\n                    if db_info.is_none() {\n                        return Err(Error::InvalidDatabase(db.to_string()));\n                    }\n                    taos.exec(format!(\"create topic if not exists {db} as database {db}\"))?;\n                    dsn.database = Some(db.to_string());\n                }\n\n                let vgroups: VGroups = taos\n                    .query_one(format!(\n                        \"select * from information_schema.user_databases where name = '{db}'\"\n                    ))?\n                    .unwrap_or_default();\n                if max_workers < vgroups.vgroups {\n                    max_workers = vgroups.vgroups;\n                }\n            }\n\n            if !dsn.params.contains_key(\"group.id\") {\n                dsn.params.insert(\"group.id\".to_string(), db.to_string());\n            }\n        }\n        // check group id\n        if !dsn.params.contains_key(\"wait\") {\n            dsn.params.insert(\"wait\".to_string(), \"10\".to_string());\n        }\n        let manager = Manager::from_dsn(dsn.clone())?;\n\n        Ok(Self {\n            from: dsn.clone(),\n            manager,\n            tmq_builder: TmqBuilder::from_dsn(dsn)?,\n            max_workers,\n            protocol: SinkProtocol::Block,\n        })\n    }\n\n    fn dsn(&self) -> Cow<Dsn> {\n        Cow::Borrowed(&self.from)\n    }\n\n    fn build_source(&mut self) -> Result<Self::XSource, Self::Error> {\n        Ok(TaosSource {\n            taos: Arc::new(self.manager.connect()?),\n            consumer: self.tmq_builder.build()?,\n            protocol: SinkProtocol::Block,\n            rs: None,\n            blocks: None,\n        })\n    }\n\n    fn protocol(&self) -> SinkProtocol {\n        todo!()\n    }\n\n    fn max_workers(&self) -> usize {\n        self.max_workers\n    }\n\n    fn database_options(&self) -> Vec<(String, String)> {\n        unimplemented!()\n    }\n\n    fn schema_iter<I>(&self) -> I\n    where\n        I: Iterator<Item = crate::stream::source::XSchema>,\n    {\n        unimplemented!()\n    }\n}\n\nimpl Stream for TaosSource {\n    type Item = Result<TaosItem, Error>;\n\n    fn poll_next(\n        mut self: Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> Poll<Option<Self::Item>> {\n        match self.protocol {\n            SinkProtocol::ResultSet => todo!(),\n            SinkProtocol::Block => {\n                if let Some(blocks) = self.blocks.as_mut() {\n                    match blocks.poll_next_unpin(cx) {\n                        Poll::Pending => Poll::Pending,\n                        Poll::Ready(None) => {\n                            self.blocks = None;\n                            self.rs = None;\n                            match self.consumer.poll_next_unpin(cx) {\n                                Poll::Pending => Poll::Pending,\n                                Poll::Ready(None) => Poll::Ready(None),\n                                Poll::Ready(Some(rs)) => match rs {\n                                    Ok(mut rs) => {\n                                        self.blocks = Some(rs.block_stream());\n                                        self.rs = Some(rs);\n                                        self.blocks.as_mut().unwrap().poll_next_unpin(cx).map(\n                                            |block| {\n                                                block.map(|block| {\n                                                    Ok(TaosItem::Block(self.taos.clone(), block))\n                                                })\n                                            },\n                                        )\n                                    }\n                                    Err(err) => Poll::Ready(Some(Err(err.into()))),\n                                },\n                            }\n                        }\n                        Poll::Ready(Some(block)) => {\n                            Poll::Ready(Some(Ok(TaosItem::Block(self.taos.clone(), block))))\n                        }\n                    }\n                } else {\n                    match self.consumer.poll_next_unpin(cx) {\n                        Poll::Pending => Poll::Pending,\n                        Poll::Ready(None) => Poll::Ready(None),\n                        Poll::Ready(Some(rs)) => match rs {\n                            Ok(mut rs) => {\n                                self.blocks = Some(rs.block_stream());\n                                self.rs = Some(rs);\n                                self.blocks\n                                    .as_mut()\n                                    .unwrap()\n                                    .poll_next_unpin(cx)\n                                    .map(|block| {\n                                        block.map(|block| {\n                                            Ok(TaosItem::Block(self.taos.clone(), block))\n                                        })\n                                    })\n                            }\n                            Err(_) => Poll::Ready(None),\n                        },\n                    }\n                }\n            }\n            SinkProtocol::RawBlock => todo!(),\n            SinkProtocol::Record => todo!(),\n            SinkProtocol::SmlLine => todo!(),\n            SinkProtocol::SmlTelnet => todo!(),\n            SinkProtocol::SmlJson => todo!(),\n            _ => todo!(),\n        }\n    }\n}\n\n#[taos::test(log_level = \"trace\", databases = 2)]\nasync fn test(taos: &Taos, databases: &[&str]) -> anyhow::Result<()> {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut source_builder = TaosSourceBuilder::from_dsn(format!(\"taos:///{db1}?wait=1000\"))?;\n    let mut source = source_builder.build_source()?;\n\n    let mut rows = 0;\n    let mut tables = std::collections::BTreeSet::new();\n    while let Some(Ok(item)) = source.next().await {\n        println!(\"{:?}\", item);\n        let block = item.as_block().1;\n        rows += block.num_of_rows();\n        let table = block.tmq_table_name().unwrap();\n        tables.insert(table.to_string());\n    }\n    anyhow::ensure!(rows == 8);\n    anyhow::ensure!(tables.into_iter().collect_vec() == vec![\"tb1\", \"tb2\", \"tb3\", \"tb4\"]);\n\n    taos.exec_many([\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db2 = databases[1];\n    let transformers = vec![Action::from_str(\"add-tag:f1(10)=value1\")?];\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?.with_transformer(transformers).build_sink()?;\n\n    source.forward(&mut sink).await?;\n\n    Ok(())\n}\n\n#[taos::test(log_level = \"debug\")]\nasync fn test_sync() -> anyhow::Result<()> {\n    return Ok(());\n    let db1 = \"abc1\";\n    // if taos.query_one::<String>(\"select name from information_schema.user_databases where name = abc1\")?.is_none() {\n    //     return Ok(());\n    // }\n    let mut source_builder =\n        TaosSourceBuilder::from_dsn(format!(\"taos:///{db1}?group.id=1&wait=20000\"))?;\n    let source = source_builder.build_source()?;\n    let db2 = \"abc2\";\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?.build_sink()?;\n\n    source.forward(&mut sink).await?;\n\n    Ok(())\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","sync","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","transformer","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","mod.rs"],"content":"pub mod sink;\npub mod source;\npub mod transformer;\n\npub mod stream;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","sink.rs"],"content":"use std::iter::Product;\n\nuse linked_hash_map::LinkedHashMap;\nuse taos::query::Dsn;\n\n#[repr(C)]\npub enum SourceType {\n    Database,\n}\npub trait ISSourceType {\n    const SOURCE_TYPE: SourceType;\n}\n\npub trait TaosxSource: Sized {\n    type Error;\n    const NAME: &'static str;\n    const KEYS: &'static [&'static str];\n\n    fn new(dsn: Dsn, opts: LinkedHashMap<&'static str, String>) -> Result<Self, Self::Error>;\n\n    type Product;\n    fn produce(&mut self) -> Self::Product;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","source.rs"],"content":"use itertools::Itertools;\nuse linked_hash_map::LinkedHashMap;\nuse mdsn::{DsnError, IntoDsn};\n\nuse std::{\n    any::Any,\n    borrow::Cow,\n    collections::{BTreeSet, HashMap},\n    ffi::c_void,\n    fmt::Debug,\n    marker::PhantomData,\n    ops::{Deref, DerefMut},\n    pin::Pin,\n    sync::{Arc, Weak},\n    task::Poll,\n};\n\nuse futures::{Sink, Stream, StreamExt, TryStreamExt};\nuse taos::{\n    block::{itypes::IsValue, BlockStream, Field, Ty},\n    prelude::AsyncFetchable,\n    query::Dsn,\n    tmq::{Consumer, TmqBuilder},\n};\n\nuse crate::{plugins::sink::taos::TaosSinkBuilder, stream::stream::XSinkBuilder, util::sync_table};\n\nuse super::stream::{SinkProtocol, TaosxSinkItem};\n\npub use taos::prelude::sync::*;\n\npub enum XSchema {\n    STableBegin,\n    STableSpan {\n        name: String,\n        tags: Vec<Field>,\n        fields: Vec<Field>,\n        options: Vec<(String, String)>,\n    },\n    STableEnd,\n    TableBegin,\n    Table {\n        name: String,\n        fields: Vec<Field>,\n        options: Vec<(String, String)>,\n    },\n    TableEnd,\n    ChildTableBegin,\n    ChildTable {\n        name: String,\n        stable: String,\n        fields: Vec<Value>,\n    },\n    ChildTableEnd,\n}\n\npub trait XSourceBuilder\nwhere\n    Self: Sized,\n{\n    type Error: std::error::Error;\n    type Item: TaosxSinkItem;\n    type XSource: Stream<Item = Result<Self::Item, Self::Error>>;\n\n    const NAME: &'static str;\n\n    fn from_dsn<T: IntoDsn>(dsn: T) -> Result<Self, Self::Error>;\n\n    fn dsn(&self) -> Cow<Dsn>;\n\n    fn max_workers(&self) -> usize {\n        0\n    }\n\n    fn database_options(&self) -> Vec<(String, String)> {\n        unimplemented!()\n    }\n\n    fn schema_iter<I>(&self) -> I\n    where\n        I: Iterator<Item = XSchema>,\n    {\n        unimplemented!()\n    }\n\n    fn protocol(&self) -> SinkProtocol;\n\n    fn build_source(&mut self) -> Result<Self::XSource, Self::Error>;\n}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","stream","mod.rs"],"content":"use derive_more::{Deref, DerefMut};\nuse mdsn::IntoDsn;\nuse std::{\n    borrow::Cow,\n    fmt::Debug,\n    pin::Pin,\n    sync::atomic::{AtomicUsize, Ordering},\n};\n\nuse taos::prelude::{SchemalessPrecision, SyncBlock, Taos, Value};\n\nuse super::transformer::Action;\n\n#[derive(Debug, Clone, Copy)]\n#[non_exhaustive]\npub enum SinkProtocol {\n    /// TDengine result set type for [taos::Taos] only.\n    ResultSet,\n    /// A stream data block from tmq consumer.\n    Block,\n    /// Raw block as a single bytes.\n    RawBlock,\n    /// A record for a table or stable.\n    Record,\n    /// InfluxDB line protocol record.\n    SmlLine,\n    /// OpenTSDB telnet protocol record string.\n    SmlTelnet,\n    /// OpenTSDB json protocol.\n    SmlJson,\n    #[non_exhaustive]\n    __NoneExhaustive,\n}\n\n#[derive(Debug, Default)]\npub struct Summary {\n    pub blocks: AtomicUsize,\n    pub rows: AtomicUsize,\n}\n\nimpl Summary {\n    pub fn blocks(&self) -> usize {\n        self.blocks.load(Ordering::Acquire)\n    }\n    pub fn rows(&self) -> usize {\n        self.rows.load(Ordering::Acquire)\n    }\n}\n\npub trait XSinkBuilder\nwhere\n    Self: Sized,\n{\n    type Error: std::error::Error;\n    fn from_dsn<T: IntoDsn>(dsn: T) -> Result<Self, Self::Error>;\n\n    fn with_transformer(self, transformers: Vec<Action>) -> Self;\n\n    fn build_sink(&self) -> Result<XSink<Self::Error>, Self::Error>;\n\n    fn summary(&self) -> &Summary;\n\n    fn build_sink_for_protocol(&self, _: SinkProtocol) -> Result<XSink<Self::Error>, Self::Error> {\n        self.build_sink()\n    }\n}\n\n#[derive(Debug, Deref, DerefMut)]\npub struct XSink<E>(Box<dyn TaosxSink<Error = E>>);\n\nimpl<E, T> From<T> for XSink<E>\nwhere\n    E: 'static + Send + Sync + std::error::Error,\n    T: 'static + TaosxSink<Error = E>,\n{\n    fn from(value: T) -> Self {\n        XSink(Box::new(value))\n    }\n}\n\nimpl<E, I> futures::Sink<I> for XSink<E>\nwhere\n    E: 'static + Send + Sync + std::error::Error,\n    I: TaosxSinkItem,\n{\n    type Error = E;\n\n    fn poll_ready(\n        self: std::pin::Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> std::task::Poll<Result<(), Self::Error>> {\n        std::task::Poll::Ready(Ok(()))\n    }\n\n    fn start_send(self: std::pin::Pin<&mut Self>, item: I) -> Result<(), Self::Error> {\n        let sink = Pin::into_inner(self);\n        match item.protocol() {\n            SinkProtocol::ResultSet => todo!(),\n            SinkProtocol::Block => {\n                let (taos, block) = item.as_block();\n                sink.consume_block(taos, block)\n            }\n            SinkProtocol::RawBlock => {\n                if let Some(block) = item.as_raw_block() {\n                    sink.consume_raw_block(&block)\n                } else {\n                    Ok(())\n                }\n            }\n            SinkProtocol::Record => todo!(),\n            SinkProtocol::SmlLine => {\n                if let Some(line) = item.as_schemaless_line() {\n                    sink.consume_schemaless_line(line, item.precision())\n                } else {\n                    Ok(())\n                }\n            }\n            SinkProtocol::SmlTelnet => {\n                if let Some(line) = item.as_schemaless_telnet() {\n                    sink.consume_schemaless_telnet(line, item.precision())\n                } else {\n                    Ok(())\n                }\n            }\n            SinkProtocol::SmlJson => {\n                if let Some(line) = item.as_schemaless_json() {\n                    sink.consume_schemaless_json(line, item.precision())\n                } else {\n                    Ok(())\n                }\n            }\n            _ => todo!(),\n        }\n    }\n\n    fn poll_flush(\n        self: std::pin::Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> std::task::Poll<Result<(), Self::Error>> {\n        std::task::Poll::Ready(Ok(()))\n    }\n\n    fn poll_close(\n        self: std::pin::Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> std::task::Poll<Result<(), Self::Error>> {\n        std::task::Poll::Ready(Ok(()))\n    }\n}\n\npub type TaosxSinkError = anyhow::Error;\npub trait TaosxSink: Debug + Send {\n    type Error: 'static + Send + Sync + std::error::Error;\n    fn batch_size(&self) -> usize {\n        1\n    }\n\n    fn flush(&mut self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn consume_block(&mut self, _: &Taos, _: &SyncBlock) -> Result<(), Self::Error> {\n        unimplemented!()\n    }\n\n    fn consume_raw_block(&mut self, _: &[u8]) -> Result<(), Self::Error> {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_line(\n        &mut self,\n        _: &str,\n        _: SchemalessPrecision,\n    ) -> Result<(), Self::Error> {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_telnet(\n        &mut self,\n        _: &str,\n        _: SchemalessPrecision,\n    ) -> Result<(), Self::Error> {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_json(\n        &mut self,\n        _: &str,\n        _: SchemalessPrecision,\n    ) -> Result<(), Self::Error> {\n        unimplemented!()\n    }\n}\n\npub trait TaosxSinkItem: Send {\n    const PROTOCOL: SinkProtocol;\n\n    fn protocol(&self) -> SinkProtocol {\n        Self::PROTOCOL\n    }\n\n    fn as_block(&self) -> (&Taos, &SyncBlock) {\n        unimplemented!()\n    }\n\n    fn as_raw_block(&self) -> Option<Cow<[u8]>> {\n        None\n    }\n\n    fn as_record(&self) -> Option<Cow<[Value]>> {\n        None\n    }\n\n    fn precision(&self) -> SchemalessPrecision {\n        SchemalessPrecision::NonConfigured\n    }\n\n    fn as_schemaless_line(&self) -> Option<&str> {\n        None\n    }\n\n    fn as_schemaless_telnet(&self) -> Option<&str> {\n        None\n    }\n\n    fn as_schemaless_json(&self) -> Option<&str> {\n        None\n    }\n}\n\nimpl TaosxSinkItem for (&Taos, SyncBlock) {\n    const PROTOCOL: SinkProtocol = SinkProtocol::Block;\n    fn as_block(&self) -> (&Taos, &SyncBlock) {\n        (self.0, &self.1)\n    }\n}\n\nimpl TaosxSinkItem for (&Taos, &SyncBlock) {\n    const PROTOCOL: SinkProtocol = SinkProtocol::Block;\n    fn as_block(&self) -> (&Taos, &SyncBlock) {\n        (self.0, self.1)\n    }\n}\n\npub struct XLine<'a>(&'a str, SchemalessPrecision);\n\nimpl<'a> XLine<'a> {\n    pub fn new_line(input: &'a str) -> Self {\n        XLine(input, SchemalessPrecision::Nanoseconds)\n    }\n    pub fn new_line_with_precision(input: &'a str, precision: SchemalessPrecision) -> Self {\n        XLine(input, precision)\n    }\n}\n\nimpl<'a> TaosxSinkItem for XLine<'a> {\n    const PROTOCOL: SinkProtocol = SinkProtocol::SmlLine;\n    fn precision(&self) -> SchemalessPrecision {\n        self.1\n    }\n    fn as_schemaless_line(&self) -> Option<&str> {\n        Some(self.0)\n    }\n}\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":58},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","transformer.rs"],"content":"use std::str::FromStr;\n\nuse linked_hash_map::LinkedHashMap as HashMap;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum AddTagOpts {\n    Value { value: String },\n    Template { template: String },\n}\n\nimpl AddTagOpts {\n    pub fn value(value: impl Into<String>) -> Self {\n        Self::Value {\n            value: value.into(),\n        }\n    }\n    pub fn template(template: impl Into<String>) -> Self {\n        Self::Template {\n            template: template.into(),\n        }\n    }\n}\n\nconst fn default_tag_length() -> usize {\n    100\n}\n\n#[derive(Debug, Deserialize, PartialEq, Eq)]\npub struct AddTag {\n    pub name: String,\n    #[serde(flatten)]\n    pub opts: AddTagOpts,\n\n    #[serde(default = \"default_tag_length\")]\n    pub len: usize,\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum AddTagParseError {\n    #[error(\"Empty AddTag option\")]\n    Empty,\n    #[error(\"Invalid AddTag option: {0}\")]\n    Invalid(String),\n}\n\nimpl FromStr for AddTag {\n    type Err = AddTagParseError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        if s.is_empty() {\n            return Err(AddTagParseError::Empty);\n        }\n        use lazy_static::lazy_static;\n        use regex::Regex;\n        lazy_static! {\n            static ref RE: Regex =\n                Regex::new(r\"(?P<f>[^=()\\s]+)(\\((?P<l>\\d+)\\))?=((?P<t>.*\\{\\{.*\\}\\}.*)|(?P<v>.*))\")\n                    .unwrap();\n        }\n        // RE.matches(s).into_iter()\n        if let Some(cap) = RE.captures(s) {\n            let name = cap[\"f\"].to_string();\n            let len = cap\n                .name(\"l\")\n                .and_then(|m| m.as_str().parse().ok())\n                .unwrap_or_else(default_tag_length);\n            if let Some(v) = cap.name(\"v\") {\n                Ok(AddTag {\n                    name,\n                    len,\n                    opts: AddTagOpts::value(v.as_str()),\n                })\n            } else if let Some(t) = cap.name(\"t\") {\n                Ok(AddTag {\n                    name,\n                    len,\n                    opts: AddTagOpts::template(t.as_str()),\n                })\n            } else {\n                unreachable!()\n            }\n        } else {\n            Err(AddTagParseError::Invalid(s.to_string()))\n        }\n    }\n}\n\n#[test]\nfn parse_add_tag() {\n    let errors = [\n        (\"\", AddTagParseError::Empty),\n        (\"a\", AddTagParseError::Invalid(\"\".to_string())),\n    ];\n    for (s, e) in errors {\n        let ee = AddTag::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let add_tags = [\n        (\n            \"f1=v1\",\n            AddTag {\n                name: \"f1\".to_string(),\n                opts: AddTagOpts::Value {\n                    value: \"v1\".to_string(),\n                },\n                len: 100,\n            },\n        ),\n        (\n            \"f1(200)=v1\",\n            AddTag {\n                name: \"f1\".to_string(),\n                opts: AddTagOpts::Value {\n                    value: \"v1\".to_string(),\n                },\n                len: 200,\n            },\n        ),\n        (\n            \"f1(200)={{ host }}\",\n            AddTag {\n                name: \"f1\".to_string(),\n                opts: AddTagOpts::Template {\n                    template: \"{{ host }}\".to_string(),\n                },\n                len: 200,\n            },\n        ),\n    ];\n    for (s, a) in add_tags {\n        let aa = AddTag::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum RenameOpts {\n    Prefix { prefix: String },\n    Suffix { suffix: String },\n    Template { template: String },\n}\n\nimpl RenameOpts {\n    pub fn prefix(prefix: impl Into<String>) -> Self {\n        Self::Prefix {\n            prefix: prefix.into(),\n        }\n    }\n    pub fn suffix(input: impl Into<String>) -> Self {\n        Self::Suffix {\n            suffix: input.into(),\n        }\n    }\n    pub fn template(input: impl Into<String>) -> Self {\n        Self::Template {\n            template: input.into(),\n        }\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum RenameParseError {\n    #[error(\"Empty rename option is not valid\")]\n    Empty,\n    #[error(\"Empty rename option for variant: {0}\")]\n    EmptyOptionForVariant(&'static str),\n    #[error(\n        \"Invalid rename option: {0} which should match pattern `<prefix|suffix|template>:<value>`\"\n    )]\n    FormatError(String),\n    #[error(\"Invalid rename variant: {0} while parsing `{1}`\")]\n    InvalidVariant(String, String),\n}\n\nimpl FromStr for RenameOpts {\n    type Err = RenameParseError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        use RenameParseError::*;\n        if s.is_empty() {\n            return Err(Empty);\n        }\n        let (variant, option) = s.split_once(':').ok_or(FormatError(s.to_string()))?;\n        match variant {\n            \"prefix\" => {\n                if option.is_empty() {\n                    Err(EmptyOptionForVariant(\"prefix\"))\n                } else {\n                    Ok(RenameOpts::prefix(option))\n                }\n            }\n            \"suffix\" => {\n                if option.is_empty() {\n                    Err(EmptyOptionForVariant(\"suffix\"))\n                } else {\n                    Ok(RenameOpts::suffix(option))\n                }\n            }\n            \"template\" => {\n                if option.is_empty() {\n                    Err(EmptyOptionForVariant(\"template\"))\n                } else {\n                    Ok(RenameOpts::template(option))\n                }\n            }\n            variant => Err(InvalidVariant(variant.to_string(), s.to_string())),\n        }\n    }\n}\n\n#[test]\nfn test_rename_opts_from_str() {\n    use RenameParseError::*;\n    let errors = [\n        (\"\", Empty),\n        (\"a\", FormatError(\"a\".to_string())),\n        (\"a:\", InvalidVariant(\"a\".to_string(), \"a:\".to_string())),\n        (\"prefix:\", EmptyOptionForVariant(\"prefix\")),\n        (\"suffix:\", EmptyOptionForVariant(\"suffix\")),\n        (\"template:\", EmptyOptionForVariant(\"template\")),\n    ];\n    for (s, e) in errors {\n        let ee = RenameOpts::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let actions = [\n        (\"prefix:v1_\", RenameOpts::prefix(\"v1_\")),\n        (\"suffix:_v1\", RenameOpts::suffix(\"_v1\")),\n        (\"template:v1_v1\", RenameOpts::template(\"v1_v1\")),\n    ];\n    for (s, a) in actions {\n        let aa = RenameOpts::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\n#[derive(Debug, Deserialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum Select {\n    Subset { subset: Vec<String> },\n    Exclude { exclude: Vec<String> },\n    Rename { rename: HashMap<String, String> },\n}\n\nimpl Select {\n    pub fn subset(subset: Vec<String>) -> Self {\n        Self::Subset { subset }\n    }\n\n    pub fn exclude(exclude: Vec<String>) -> Self {\n        Self::Exclude { exclude }\n    }\n\n    pub fn rename<I: IntoIterator<Item = (impl Into<String>, impl Into<String>)>>(\n        rename: I,\n    ) -> Self {\n        Self::Rename {\n            rename: rename\n                .into_iter()\n                .map(|(a, b)| (a.into(), b.into()))\n                .collect(),\n        }\n    }\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum SelectParseError {\n    #[error(\"Empty select option\")]\n    Empty,\n    #[error(\"Empty select option for variant: {0}\")]\n    EmptyOptionForVariant(&'static str),\n    #[error(\"Invalid select option: {0}, use like `select:<type>:<opts>`\")]\n    InvalidSelect(String),\n    #[error(\"Invalid select variant: {0} while parsing `{1}`\")]\n    InvalidVariant(String, String),\n    #[error(\"Invalid rename option: {0} while parsing `{1}`\")]\n    InvalidRename(String, String),\n}\n\nimpl FromStr for Select {\n    type Err = SelectParseError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        if s.is_empty() {\n            return Err(SelectParseError::Empty);\n        }\n        let (select, fields) = s\n            .split_once(':')\n            .ok_or(SelectParseError::InvalidSelect(s.to_string()))?;\n        match select {\n            \"subset\" => {\n                if fields.is_empty() {\n                    return Err(SelectParseError::EmptyOptionForVariant(\"subset\"));\n                }\n                let v = fields.split(\",\").map(ToString::to_string).collect();\n                Ok(Select::subset(v))\n            }\n            \"exclude\" => {\n                if fields.is_empty() {\n                    return Err(SelectParseError::EmptyOptionForVariant(\"exclude\"));\n                }\n                let v = fields.split(\",\").map(ToString::to_string).collect();\n                Ok(Select::exclude(v))\n            }\n            \"rename\" => {\n                if fields.is_empty() {\n                    return Err(SelectParseError::EmptyOptionForVariant(\"rename\"));\n                }\n                use itertools::Itertools;\n                let v: Vec<_> = fields\n                    .split(\",\")\n                    .map(|f| {\n                        f.split_once(\"=\")\n                            .ok_or(SelectParseError::InvalidRename(\n                                f.to_string(),\n                                s.to_string(),\n                            ))\n                            .map(|(f, v)| (f.to_string(), v.to_string()))\n                    })\n                    .try_collect()?;\n                Ok(Select::rename(v))\n            }\n            t => Err(SelectParseError::InvalidVariant(\n                t.to_string(),\n                s.to_string(),\n            )),\n        }\n    }\n}\n\n#[test]\nfn test_select_from_str() {\n    let errors = [\n        (\"\", SelectParseError::Empty),\n        (\"a\", SelectParseError::InvalidSelect(\"a\".to_string())),\n        (\n            \"a:\",\n            SelectParseError::InvalidVariant(\"a\".to_string(), \"a:\".to_string()),\n        ),\n        (\"subset:\", SelectParseError::EmptyOptionForVariant(\"subset\")),\n        (\n            \"exclude:\",\n            SelectParseError::EmptyOptionForVariant(\"exclude\"),\n        ),\n        (\"rename:\", SelectParseError::EmptyOptionForVariant(\"rename\")),\n        (\n            \"rename:a,b\",\n            SelectParseError::InvalidRename(\"a\".to_string(), \"rename:a,b\".to_string()),\n        ),\n    ];\n    for (s, e) in errors {\n        let ee = Select::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let selects = [\n        (\n            \"subset:a,b\",\n            Select::subset(vec![\"a\".to_string(), \"b\".to_string()]),\n        ),\n        (\n            \"exclude:a,b\",\n            Select::exclude(vec![\"a\".to_string(), \"b\".to_string()]),\n        ),\n        (\"rename:a=b,c=d\", Select::rename([(\"a\", \"b\"), (\"c\", \"d\")])),\n    ];\n    for (s, a) in selects {\n        let aa = Select::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\n#[derive(Debug, Deserialize, PartialEq, Eq)]\n#[serde(tag = \"action\")]\npub enum Action {\n    Select(Select),\n    AddTag(AddTag),\n    RenameTable(RenameOpts),\n    RenameChildTable(RenameOpts),\n    RenameSuperTable(RenameOpts),\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum ActionParseError {\n    #[error(\"Empty action option is not valid\")]\n    EmptyAction,\n    #[error(\"Invalid action: {0}, use `<action>:<option>` format\")]\n    FormatError(String),\n    #[error(\"Unsupported action type: {0}\")]\n    Unsupported(String),\n    #[error(\"AddTag parse error: {0}\")]\n    AddTagError(#[from] AddTagParseError),\n    #[error(\"Select parse error: {0}\")]\n    SelectError(#[from] SelectParseError),\n    #[error(\"Rename parse error: {0}\")]\n    RenameError(#[from] RenameParseError),\n}\n\nimpl FromStr for Action {\n    type Err = ActionParseError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        use ActionParseError::*;\n        if s.is_empty() {\n            return Err(EmptyAction);\n        }\n        use convert_case::{Case, Casing};\n        let (action, option) = s.split_once(\":\").ok_or(FormatError(s.to_string()))?;\n        match action.to_case(Case::Pascal).as_str() {\n            \"AddTag\" => Ok(Action::AddTag(AddTag::from_str(option)?)),\n            \"Select\" => Ok(Action::Select(Select::from_str(option)?)),\n            \"RenameTable\" => Ok(Action::RenameTable(RenameOpts::from_str(option)?)),\n            \"RenameSuperTable\" => Ok(Action::RenameSuperTable(RenameOpts::from_str(option)?)),\n            \"RenameChildTable\" => Ok(Action::RenameChildTable(RenameOpts::from_str(option)?)),\n            _ => Err(Unsupported(action.to_string())),\n        }\n    }\n}\n\n#[test]\nfn test_action_from_str() {\n    use ActionParseError::*;\n    let errors = [\n        (\"\", EmptyAction),\n        (\"a\", FormatError(\"a\".to_string())),\n        (\"a:\", Unsupported(\"a\".to_string())),\n        (\"add-tag:\", AddTagError(AddTagParseError::Empty)),\n        (\"select:\", SelectError(SelectParseError::Empty)),\n        (\"rename-table:\", RenameError(RenameParseError::Empty)),\n    ];\n    for (s, e) in errors {\n        let ee = Action::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let actions = [\n        (\n            \"add-tag:a=b\",\n            Action::AddTag(AddTag {\n                name: \"a\".to_string(),\n                len: 100,\n                opts: AddTagOpts::value(\"b\"),\n            }),\n        ),\n        (\n            \"select:subset:a,b\",\n            Action::Select(Select::subset(vec![\"a\".to_string(), \"b\".to_string()])),\n        ),\n        (\n            \"rename-table:template:v1_v1\",\n            Action::RenameTable(RenameOpts::template(\"v1_v1\")),\n        ),\n    ];\n    for (s, a) in actions {\n        let aa = Action::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\npub trait Transform {\n    fn transform(&mut self, action: &Action) -> anyhow::Result<()>;\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n    use anyhow::Result;\n    #[test]\n    fn action() -> Result<()> {\n        let json = r#\"[\n            { \"action\": \"AddTag\", \"name\": \"f1\", \"value\": \"f2\" },\n            { \"action\": \"AddTag\", \"name\": \"f1\", \"template\": \"{{ host }}\" },\n            { \"action\": \"Select\", \"subset\": [\"a\", \"b\"] },\n            { \"action\": \"Select\", \"rename\": { \"a\": \"a1\", \"b\": \"b1\" } }\n        ]\"#;\n        let addtag: Vec<Action> = serde_json::from_str(json)?;\n        dbg!(addtag);\n        Ok(())\n    }\n\n    #[test]\n    fn test_trait() {\n        struct A;\n        impl Transform for A {\n            fn transform(&mut self, _: &Action) -> anyhow::Result<()> {\n                Ok(())\n            }\n        }\n        let action = Action::from_str(\"select:subset:a,b,c\").unwrap();\n        let mut a = A;\n        a.transform(&action).unwrap();\n    }\n}\n","traces":[{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","task","mod.rs"],"content":"use linked_hash_map::LinkedHashMap;\nuse serde_json::Value;\n\n///\n// {\n//   \"source\": [\n//     \"dsn1\",\n//     \"dsn2\"\n//   ],\n//   \"transformer\": {\n//     \"AddTag\": {\n//       \"city\": {\n//         \"fromOptions\": \"host\"\n//       }\n//     },\n//     \"AlterTable\": {\n//       \"prefix\": \"taosx_\"\n//     }\n//   },\n//   \"sink\": [\n//     \"sink1\",\n//     \"sink2\"\n//   ]\n// }\npub struct Task {\n    source: Vec<Source>,\n    transformer: Transformers,\n    sink: Vec<Sink>,\n}\n\npub struct Source {\n    plugin: String,\n    dsn: String,\n    options: Value,\n}\n\npub struct Sink {\n    dsn: String,\n    options: LinkedHashMap<String, String>,\n}\n\nimpl Sink {\n    pub fn plugin<T>(&self) -> Box<dyn SinkPlugin<Stream = T>> {\n        unimplemented!()\n    }\n}\n\npub trait SinkPlugin {\n    type Stream;\n\n    fn accepted_content(&self) -> Vec<String>;\n\n    fn consume(&mut self, stream: Self::Stream);\n}\n\npub struct Transformers(LinkedHashMap<String, TransformerOptions>);\n\npub struct TransformerOptions(Value);\n\n#[cfg(test)]\nmod tests {\n    use futures::sink::{self, SinkExt};\n    use taos::prelude::*;\n\n    #[taos::test]\n    async fn sink_unfold(taos: &Taos, database: &str) -> anyhow::Result<()> {\n        let unfold = sink::unfold(0, |mut sum, i: i32| async move {\n            sum += i;\n            eprintln!(\"sum: {sum}, i = {}\", i);\n            Ok::<_, futures::never::Never>(sum)\n        });\n        futures::pin_mut!(unfold);\n        unfold.send(5).await?;\n        unfold.send(5).await?;\n        unfold.send(5).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","util","mod.rs"],"content":"use std::collections::HashMap;\n\nuse futures::prelude::*;\nuse log::info;\nuse serde::Deserialize;\nuse taos::prelude::{Error, Taos};\n\npub async fn sync_schema(from: &Taos, to: &Taos) -> Result<(), Error> {\n    use taos::prelude::*;\n    let stables: Vec<String> = from\n        .query(\"show stables\")\n        .await?\n        .deserialize_stream()\n        .try_collect()\n        .await?;\n    let mut stable_fields = HashMap::new();\n    for stable in stables {\n        // todo: use \"show create\" sql?\n        // from.query(format!(\"show create stable {stable}\")).await?;\n        let desc = from.describe(&stable).await?;\n        let sql = desc.to_create_table_sql(&stable);\n        stable_fields.insert(stable, desc);\n        to.exec(sql).await?;\n    }\n\n    #[derive(Deserialize)]\n    struct Table {\n        table_name: String,\n        db_name: String,\n        stable_name: Option<String>,\n    }\n    let tables: Vec<Table> = from\n        .query(\"show tables\")\n        .await?\n        .deserialize_stream()\n        .try_collect()\n        .await?;\n    use itertools::Itertools;\n    for table in tables {\n        let table_name = &table.table_name;\n        if let Some(stable) = table.stable_name {\n            let fields = &stable_fields[&stable];\n            let tags = fields.tag_names().collect_vec();\n            let names = fields.tag_names().join(\",\");\n            let fields: Vec<Value> = from\n                .query_one(format!(\n                    \"select {names} from {stable} where tbname = '{table_name}'\"\n                ))\n                .await?\n                .unwrap();\n\n            let tags_values = fields.into_iter().map(|v| v.to_sql_value()).join(\",\");\n            to.exec(format!(\n                \"create table if not exists {table_name} using {stable} tags({tags_values})\"\n            ))\n            .await?;\n            // tags.iter().zip(fields).map(|(name, value)| format!(\"\"))\n            // let tags_stmt = tags.map(|_| '?').join(\",\");\n            // let mut stmt = to.stmt(format!(\"create table if not exists ? using ({tags_stmt})\"))?;\n            // stmt.set_tbname_tags(&table.table_name, &fields);\n        } else {\n            let desc = from.describe(table_name).await?;\n            let sql = desc.to_create_table_sql(table_name);\n            to.exec(sql).await?;\n        }\n    }\n\n    // let tables: Vec<\n    Ok(())\n}\n\npub fn sync_table(from: &Taos, to: &Taos, db: &str, table: &str) -> Result<(), Error> {\n    use taos::prelude::sync::*;\n\n    let stable: Option<String> = from\n        .query_one(format!(\n            \"select stable_name from information_schema.user_tables where db_name = '{db}' and table_name = \\\"{table}\\\"\"\n        ))?\n        .unwrap();\n    use itertools::Itertools;\n\n    if let Some(stable) = stable {\n        let desc = from.describe(&format!(\"{db}.`{stable}`\"))?;\n        let sql = desc.to_create_table_sql(&stable);\n        to.exec(sql)?;\n\n        let names = desc.tag_names().join(\",\");\n        let children: Vec<Vec<Value>> = from\n            .query(format!(\"select tbname,{names} from {stable}\"))?\n            .deserialize()\n            .try_collect()?;\n\n        // todo: use par_iter to speed up tables creation.\n        // todo: single table not work, blocked by https://jira.taosdata.com:18080/browse/TD-16117\n        for child in children {\n            let tbname = child[0].to_string().unwrap();\n            let tags_values = child[1..].into_iter().map(|v| v.to_sql_value()).join(\",\");\n            to.exec(format!(\n                \"create table if not exists {tbname} using {stable} tags({tags_values})\"\n            ))?;\n        }\n\n        // let fields: Vec<Value> = from\n        //     .query_one(format!(\n        //         \"select {names} from {stable} where tbname = '{table}'\"\n        //     ))?\n        //     .unwrap();\n\n        // let tags_values = fields.into_iter().map(|v| v.to_sql_value()).join(\",\");\n        // to.exec(format!(\n        //     \"create table if not exists {table} using {stable} tags({tags_values})\"\n        // ))?;\n    } else {\n        info!(\"describe table {table}\");\n        let desc = from.describe(&format!(\"{db}.`{table}`\"))?;\n        info!(\"table {table}: {desc:?}\");\n        let sql = desc.to_create_table_sql(&table);\n        info!(\"exec sql: {sql}\");\n        to.exec(sql)?;\n    }\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","benches","async_query.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\n\nuse taos::{Taos, TaosOptions};\n\nfn bench_query_sync0(taos: &Taos) {\n    use taos::prelude::AsyncQueryable;\n    let _ = taos.query_sync(\"select * from log.logs\");\n}\n\nfn bench_query_sync1(taos: &Taos) {\n    use taos::prelude::sync::Queryable;\n    let _ = taos.query(\"select * from log.logs\");\n}\n\nfn criterion_benchmark(c: &mut Criterion) {\n    // Optionally include some setup\n    let taos = TaosOptions::new().build().unwrap();\n    let mut group = c.benchmark_group(\"query - do nothing\");\n    use criterion::*;\n    group.sampling_mode(SamplingMode::Linear);\n    group.measurement_time(std::time::Duration::from_secs(15));\n    use tokio::runtime;\n\n    let _rt = runtime::Runtime::new().unwrap();\n\n    group.bench_function(\"async\", |b| b.iter(|| bench_query_sync0(&taos)));\n    group.bench_function(\"sync\", |b| b.iter(|| bench_query_sync1(&taos)));\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","examples","benchmark-query.rs"],"content":"use anyhow::Result;\nuse taos::prelude::sync::*;\n\n// Refer to [Jira TD-15233](https://jira.taosdata.com:18080/browse/TD-15233)\nfn main() -> Result<()> {\n    let taos = TaosOptions::new().database(\"abc1\").build()?;\n    let rs: (String, String) = taos\n        .query_one(\"select tbname, location from meters limit 1\")?\n        .unwrap();\n    dbg!(rs);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","examples","db-create-drop.rs"],"content":"use anyhow::Result;\nuse taos::prelude::sync::*;\n\n// Refer to [Jira TD-15233](https://jira.taosdata.com:18080/browse/TD-15233)\nfn main() -> Result<()> {\n    let taos = TaosOptions::new().build()?;\n    taos.exec(\"create database abc\")?;\n    taos.exec(\"drop database abc\")?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","async_query.rs"],"content":"use std::{\n    ffi::c_void,\n    future::Future,\n    marker::PhantomData,\n    os::raw::c_int,\n    pin::Pin,\n    sync::Arc,\n    task::{Context, Poll, Waker},\n};\n\nuse std::sync::Mutex;\nuse taos_sys::ffi::TAOS_RES;\n\nuse crate::prelude::sync::ResultSet;\nuse crate::{util::IntoCStr, Result, Taos};\n\npub struct QueryFuture<'query> {\n    shared_state: Arc<Mutex<SharedState>>,\n    _marker: PhantomData<&'query Taos>,\n}\n\n/// Shared state between the future and the waiting thread\nstruct SharedState {\n    completed: bool,\n    result: *mut TAOS_RES,\n    code: i32,\n    waker: Option<Waker>,\n}\n\nunsafe impl Send for SharedState {}\nunsafe impl Sync for SharedState {}\n\nimpl Unpin for SharedState {}\nimpl<'query> Unpin for QueryFuture<'query> {}\nimpl<'query> Future for QueryFuture<'query> {\n    type Output = Result<ResultSet>;\n    fn poll<'a>(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // Look at the shared state to see if the timer has already completed.\n        let mut shared_state = self.shared_state.lock().unwrap();\n        if shared_state.completed {\n            Poll::Ready(Ok(ResultSet::from_ptr_with_code(\n                shared_state.result,\n                shared_state.code,\n            )?))\n        } else {\n            // Set waker so that the thread can wake up the current task\n            // when the timer has completed, ensuring that the future is polled\n            // again and sees that `completed = true`.\n            //\n            // It's tempting to do this once rather than repeatedly cloning\n            // the waker each time. However, the Future can move between\n            // tasks on the executor, which could cause a stale waker pointing\n            // to the wrong task, preventing from waking up\n            // correctly.\n            //\n            // N.B. it's possible to check for this using the `Waker::will_wake`\n            // function, but we omit that here to keep things simple.\n            shared_state.waker = Some(cx.waker().clone());\n            Poll::Pending\n        }\n    }\n}\nimpl<'query> QueryFuture<'query> {\n    /// Create a new `TimerFuture` which will complete after the provided\n    /// timeout.\n    pub fn new<'a>(taos: &Taos, sql: impl IntoCStr<'a>) -> Self {\n        let shared_state = Arc::new(Mutex::new(SharedState {\n            completed: false,\n            result: std::ptr::null_mut(),\n            code: 0,\n            waker: None,\n        }));\n\n        unsafe extern \"C\" fn async_query_callback(\n            param: *mut c_void,\n            res: *mut TAOS_RES,\n            code: c_int,\n        ) {\n            let param = param as *const Arc<Mutex<SharedState>>;\n            let state = param.read();\n            let mut s = state.lock().unwrap();\n\n            (*s).completed = true;\n            (*s).result = res;\n            (*s).code = code;\n            if let Some(waker) = s.waker.take() {\n                waker.wake()\n            }\n        }\n\n        taos.0.query_a(\n            sql.into_c_str().as_ptr(),\n            async_query_callback as _,\n            Box::into_raw(Box::new(shared_state.clone())) as *mut _,\n        );\n\n        QueryFuture {\n            shared_state,\n            _marker: PhantomData,\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","block","mod.rs"],"content":"use std::{\n    ffi::c_void,\n    marker::PhantomData,\n    os::raw::c_int,\n    sync::{atomic::AtomicU64, Arc, Mutex, RwLock},\n    task::{Poll, Waker},\n};\n\nuse futures::Stream;\n\nuse taos_sys::ffi::*;\nuse taos_sys::*;\n\npub use taos_query::common::*;\n\nuse crate::impls::SyncBlock;\n\n#[derive(Debug)]\npub struct BlockStream {\n    raw: Arc<RawRes>,\n    summary: Arc<(AtomicU64, AtomicU64)>,\n    state: Arc<Mutex<BlockState>>,\n}\n\nimpl BlockStream {\n    pub(crate) fn from_raw(raw: Arc<RawRes>, summary: Arc<(AtomicU64, AtomicU64)>) -> Self {\n        let state = Arc::new(Mutex::new(BlockState {\n            completed: false,\n            result: std::ptr::null_mut(),\n            num_of_rows: 0,\n            waker: None,\n        }));\n\n        Self {\n            raw,\n            state,\n            summary,\n        }\n    }\n    pub(crate) fn append_num_of_rows(&self, num_of_rows: i32) {\n        use std::sync::atomic::Ordering::SeqCst;\n        self.summary.0.fetch_add(1, SeqCst);\n        self.summary.1.fetch_add(num_of_rows as _, SeqCst);\n    }\n}\n\nunsafe impl Send for BlockStream {}\nunsafe impl Sync for BlockStream {}\n\n#[derive(Debug)]\nstruct BlockState {\n    /// Whether or not the sleep time has elapsed\n    completed: bool,\n    result: *mut TAOS_RES,\n    num_of_rows: i32,\n    waker: Option<Waker>,\n}\n\nimpl Stream for BlockStream {\n    // type Item = (*mut TAOS_RES, i32);\n    type Item = SyncBlock;\n\n    fn poll_next(\n        self: std::pin::Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> Poll<Option<Self::Item>> {\n        // todo(3.0): remove these line to use taos_query_a in async/await impl.\n        if crate::client_info().starts_with(\"3\") {\n            let block = if let Ok(Some((data, num_of_rows, lengths))) = self.raw.fetch_block() {\n                log::trace!(\"fetch block: {num_of_rows}\");\n\n                self.append_num_of_rows(num_of_rows);\n\n                Some(SyncBlock {\n                    raw: self.raw.clone(),\n                    fields: None,\n                    precision: self.raw.precision(),\n                    data,\n                    lengths,\n                    num_of_rows: num_of_rows as _,\n                })\n            } else {\n                None\n            };\n            return Poll::Ready(block);\n        }\n\n        let mut s = self.state.lock().unwrap();\n        unsafe extern \"C\" fn async_fetch_callback(\n            param: *mut c_void,\n            res: *mut TAOS_RES,\n            num_of_rows: c_int,\n        ) {\n            let param = param as *const Arc<Mutex<BlockState>>;\n            let state = param.read();\n            let mut s = state.lock().unwrap();\n\n            (*s).completed = true;\n            (*s).result = res;\n            (*s).num_of_rows = num_of_rows;\n            if let Some(waker) = s.waker.take() {\n                waker.wake()\n            }\n        }\n\n        if s.completed && s.num_of_rows != 0 {\n            let num_of_rows = s.num_of_rows;\n            s.completed = false;\n            s.num_of_rows = 0;\n            drop(s);\n\n            self.append_num_of_rows(num_of_rows);\n\n            // Wake up poll.\n            Poll::Ready(Self::Item::from_async_query(\n                self.raw.clone(),\n                self.raw.block(),\n                num_of_rows,\n            ))\n        } else if s.completed && s.num_of_rows == 0 {\n            Poll::Ready(None)\n        } else {\n            let res = if s.result.is_null() {\n                self.raw.as_ptr()\n            } else {\n                s.result\n            };\n            s.waker = Some(cx.waker().clone());\n            drop(s);\n\n            unsafe {\n                taos_fetch_rows_a(\n                    res,\n                    async_fetch_callback as _,\n                    Box::into_raw(Box::new(self.state.clone())) as *mut _,\n                );\n            }\n            Poll::Pending\n        }\n    }\n}\n","traces":[{"line":26,"address":[3686113,3685840,3686140],"length":1,"stats":{"Line":0},"fn_name":"from_raw"},{"line":27,"address":[3685975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3685963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[3686160],"length":1,"stats":{"Line":0},"fn_name":"append_num_of_rows"},{"line":42,"address":[3686182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[3686227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3687516,3686288,3687483],"length":1,"stats":{"Line":0},"fn_name":"poll_next"},{"line":68,"address":[3686335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3687478,3686462,3686560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[3686835,3686624,3686738,3686929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[3686899,3687110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[3687357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[3687124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[3687194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3687285,3687206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[3687349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3686549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[3687572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3687648,3686435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[3689890,3689440],"length":1,"stats":{"Line":0},"fn_name":"async_fetch_callback"},{"line":94,"address":[3689479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[3689495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3689573,3689506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3689706,3689639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[3689710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[3689744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[3689916,3689777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3689956,3690017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[3687843,3687735,3688443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[3687950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3688002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[3688041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[3688083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3688118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3688378,3688425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[3688167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[3688245,3688321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3688632,3687920,3688494,3689369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3688603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[3688571,3688642,3688805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3688694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3688794,3688670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3688777,3688812,3689081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[3689046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3689103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[3689312,3689116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3689362],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":47},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","helpers","mod.rs"],"content":"// mod describe;\n// pub use describe::*;\n\n// mod database;\n// pub use database::*;\npub use taos_query::helpers::*;\n\n#[cfg(feature = \"test\")]\npub mod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","helpers","tests.rs"],"content":"use std::{io::Write, ops::Deref, str::FromStr, sync::Once};\n\nuse log::Level;\nuse pretty_env_logger::env_logger::fmt::{Color, StyledValue};\n\nuse crate::prelude::sync::*;\n\nuse anyhow::Result;\n\nuse taos_query::common::Precision;\n\n/// Used in [test(naming = \"uuid-v1\")] macro to choose database naming strategy\n#[derive(Debug)]\npub enum NamingStrategy {\n    Random,\n    UuidV1,\n    Named(String),\n}\n\nimpl NamingStrategy {\n    fn name(&self) -> String {\n        use NamingStrategy::*;\n        match self {\n            Random => {\n                // randomly generate\n                use faker_rand::lorem::Word;\n                use rand::rngs::ThreadRng;\n                use rand::Rng;\n                static mut RNG: Option<ThreadRng> = None;\n                const ONCE: Once = Once::new();\n                ONCE.call_once(|| unsafe {\n                    RNG = Some(rand::thread_rng());\n                });\n                let rng = unsafe { RNG.as_mut().unwrap() };\n                String::from_iter([rng.gen::<Word>().to_string(), rng.gen::<Word>().to_string()])\n            }\n            UuidV1 => {\n                // time-based uuid generator\n                use uuid::v1::{Context, Timestamp};\n                use uuid::Uuid;\n\n                use rand::rngs::ThreadRng;\n                use rand::Rng;\n                static mut RNG: Option<ThreadRng> = None;\n                const ONCE: Once = Once::new();\n                ONCE.call_once(|| unsafe {\n                    RNG = Some(rand::thread_rng());\n                });\n                let context = Context::new(unsafe { RNG.as_mut().unwrap().gen() });\n                let dur = std::time::SystemTime::now()\n                    .duration_since(std::time::SystemTime::UNIX_EPOCH)\n                    .expect(\"\");\n                let ts = Timestamp::from_unix(&context, dur.as_secs(), dur.subsec_nanos());\n\n                let mut node = [0u8; 6];\n                for i in 0..6 {\n                    node[i] = unsafe { RNG.as_mut().unwrap() }.gen();\n                }\n                let mut uuid: Vec<_> = Uuid::new_v1(ts, &node)\n                    .as_hyphenated()\n                    .to_string()\n                    .replace(\"-\", \"\")\n                    .chars()\n                    .collect();\n                for _ in 0..uuid.len() {\n                    if uuid[0].is_alphabetic() {\n                        log::trace!(\n                            \"create database with name: {}\",\n                            String::from_iter(uuid.clone())\n                        );\n                        break;\n                    } else {\n                        uuid.rotate_left(1);\n                    }\n                }\n                if uuid[0].is_alphabetic() {\n                    String::from_iter(uuid)\n                } else {\n                    self.name()\n                }\n            }\n            Named(name) => name.clone(),\n        }\n    }\n}\n\nimpl Iterator for NamingStrategy {\n    type Item = String;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        Some(self.name())\n    }\n}\n\nimpl Default for NamingStrategy {\n    fn default() -> Self {\n        NamingStrategy::UuidV1\n    }\n}\n\nimpl From<()> for NamingStrategy {\n    fn from(_: ()) -> Self {\n        NamingStrategy::default()\n    }\n}\n\nimpl From<&str> for NamingStrategy {\n    fn from(s: &str) -> Self {\n        match s {\n            \"random\" => NamingStrategy::Random,\n            \"uuid-v1\" | \"uuidv1\" | \"UuidV1\" => NamingStrategy::UuidV1,\n            _ => NamingStrategy::Named(s.to_string()),\n        }\n    }\n}\nimpl From<String> for NamingStrategy {\n    fn from(s: String) -> Self {\n        match s.as_str() {\n            \"random\" => NamingStrategy::Random,\n            \"uuid-v1\" | \"uuidv1\" | \"UuidV1\" => NamingStrategy::UuidV1,\n            _ => NamingStrategy::Named(s),\n        }\n    }\n}\n\n#[derive(Debug)]\n/// Used in [test(drop = \"<strategy>\")] macro to make sure to drop before/after test.\npub enum DroppingStrategy {\n    None,\n    Before,\n    After,\n    Always,\n}\n\nimpl DroppingStrategy {\n    fn drop_after(&self) -> bool {\n        use DroppingStrategy::*;\n        matches!(self, After | Always)\n    }\n    fn drop_before(&self) -> bool {\n        use DroppingStrategy::*;\n        matches!(self, Before | Always)\n    }\n}\n\nimpl From<&str> for DroppingStrategy {\n    fn from(s: &str) -> Self {\n        match s.as_ref() {\n            \"none\" => DroppingStrategy::None,\n            \"before\" => DroppingStrategy::Before,\n            \"after\" => DroppingStrategy::After,\n            \"always\" => DroppingStrategy::Always,\n            _ => unreachable!(\"invalid drop strategy used in [test] macro\"),\n        }\n    }\n}\n\nimpl From<String> for DroppingStrategy {\n    fn from(s: String) -> Self {\n        Self::from(s.as_str())\n    }\n}\n\nimpl From<()> for DroppingStrategy {\n    fn from(_: ()) -> Self {\n        DroppingStrategy::default()\n    }\n}\n\nimpl Default for DroppingStrategy {\n    fn default() -> Self {\n        DroppingStrategy::Always\n    }\n}\n\n#[derive(Debug)]\npub enum PrecisionStrategy {\n    Preset(Precision),\n    Random,\n    Cyclic,\n}\n\nimpl PrecisionStrategy {\n    fn precision(&self) -> Precision {\n        use PrecisionStrategy::*;\n        match self {\n            Preset(p) => p.clone(),\n            Random => {\n                //\n                use rand::rngs::ThreadRng;\n                use rand::Rng;\n                static mut RNG: Option<ThreadRng> = None;\n                const ONCE: Once = Once::new();\n                ONCE.call_once(|| unsafe {\n                    RNG = Some(rand::thread_rng());\n                });\n                let rng = unsafe { RNG.as_mut().unwrap() };\n                rng.gen::<u8>().into()\n            }\n            Cyclic => {\n                static mut ITER: u64 = 0;\n                let p = match unsafe { ITER % 3 } {\n                    0 => Precision::Millisecond,\n                    1 => Precision::Microsecond,\n                    2 => Precision::Nanosecond,\n                    _ => unreachable!(),\n                };\n                unsafe { ITER += 1 };\n                p\n            }\n        }\n    }\n}\n\nimpl Iterator for PrecisionStrategy {\n    type Item = Precision;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        Some(self.precision())\n    }\n}\n\nimpl From<()> for PrecisionStrategy {\n    fn from(_: ()) -> Self {\n        PrecisionStrategy::default()\n    }\n}\n\nimpl Default for PrecisionStrategy {\n    fn default() -> Self {\n        PrecisionStrategy::Preset(Precision::Millisecond)\n    }\n}\n\nimpl From<&str> for PrecisionStrategy {\n    fn from(s: &str) -> Self {\n        PrecisionStrategy::from_str(s).expect(&format!(\"invalid precision strategy: {}\", s))\n    }\n}\n\nimpl FromStr for PrecisionStrategy {\n    type Err = crate::Error;\n\n    fn from_str(s: &str) -> crate::Result<Self> {\n        use PrecisionStrategy::*;\n        match Precision::from_str(s) {\n            Ok(p) => Ok(Preset(p)),\n            Err(_) => match s {\n                \"random\" => Ok(Random),\n                \"cyclic\" => Ok(Cyclic),\n                _ => Err(err!('str \"unsupported strategy {}\")),\n            },\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum LogLevel {\n    /// Default,\n    Default,\n    /// A level lower than all log levels.\n    Off,\n    /// Corresponds to the `Error` log level.\n    Error,\n    /// Corresponds to the `Warn` log level.\n    Warn,\n    /// Corresponds to the `Info` log level.\n    Info,\n    /// Corresponds to the `Debug` log level.\n    Debug,\n    /// Corresponds to the `Trace` log level.\n    Trace,\n}\n\nimpl LogLevel {\n    fn to_log_level_filter(&self) -> Option<log::LevelFilter> {\n        use LogLevel::*;\n        match self {\n            Default => None,\n            Off => Some(log::LevelFilter::Off),\n            Error => Some(log::LevelFilter::Error),\n            Warn => Some(log::LevelFilter::Warn),\n            Info => Some(log::LevelFilter::Info),\n            Debug => Some(log::LevelFilter::Debug),\n            Trace => Some(log::LevelFilter::Trace),\n        }\n    }\n}\nimpl Default for LogLevel {\n    fn default() -> Self {\n        LogLevel::Default\n    }\n}\n\nimpl From<&str> for LogLevel {\n    fn from(s: &str) -> Self {\n        use LogLevel::*;\n        match s {\n            \"off\" => Off,\n            \"error\" => Error,\n            \"warn\" => Warn,\n            \"info\" => Info,\n            \"debug\" => Debug,\n            \"trace\" => Trace,\n            _ => Off,\n        }\n    }\n}\n\nimpl From<()> for LogLevel {\n    fn from(_: ()) -> Self {\n        Self::default()\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Common {\n    log_level: LogLevel,\n}\n\nimpl Common {\n    pub fn log_level(mut self, level: impl Into<LogLevel>) -> Self {\n        self.log_level = level.into();\n        self\n    }\n\n    pub fn init(&self) -> Result<()> {\n        println!(\"* common init started\");\n        static LOGGER_INIT: Once = Once::new();\n        LOGGER_INIT.call_once(|| {\n            let mut builder = pretty_env_logger::formatted_timed_builder();\n            if let Some(lv) = self.log_level.to_log_level_filter() {\n                builder.filter_level(lv);\n            } else {\n                if let Ok(s) = ::std::env::var(\"RUST_LOG\") {\n                    builder.parse_filters(&s);\n                }\n            }\n            builder\n                .format_module_path(true)\n                .format(|buf, record| -> std::result::Result<(), std::io::Error> {\n                    fn colored_level<'a>(\n                        style: &'a mut pretty_env_logger::env_logger::fmt::Style,\n                        level: Level,\n                    ) -> StyledValue<'a, &'static str> {\n                        match level {\n                            Level::Trace => style.set_color(Color::Magenta).value(\"TRACE\"),\n                            Level::Debug => style.set_color(Color::Blue).value(\"DEBUG\"),\n                            Level::Info => style.set_color(Color::Green).value(\"INFO\"),\n                            Level::Warn => style.set_color(Color::Yellow).value(\"WARN \"),\n                            Level::Error => style.set_color(Color::Red).value(\"ERROR\"),\n                        }\n                    }\n                    let mut style = buf.style();\n                    let level = colored_level(&mut style, record.level());\n                    let mut mod_path = buf.style();\n\n                    let mod_path = mod_path.set_bold(true).value(format!(\n                        \"{}:{}\",\n                        record.file().unwrap_or(\"unknown\"),\n                        record.line().unwrap_or(0),\n                    ));\n                    writeln!(\n                        buf,\n                        \"[{:29} {: <5}] {} > {}\",\n                        chrono::Local::now().format(\"%Y-%m-%dT%H:%M:%S.%f\"),\n                        level,\n                        mod_path,\n                        record.args()\n                    )\n                })\n                // .is_test(true)\n                .init();\n        });\n        log::info!(\"common init done\");\n        Ok(())\n    }\n}\n#[derive(Debug, Default)]\n\npub struct Builder {\n    naming: NamingStrategy,\n    precision: PrecisionStrategy,\n    dropping: DroppingStrategy,\n    databases: usize,\n}\nimpl Builder {\n    pub fn new(\n        naming: impl Into<NamingStrategy>,\n        drop: impl Into<DroppingStrategy>,\n        precision: impl Into<PrecisionStrategy>,\n        databases: usize,\n    ) -> Self {\n        Self {\n            naming: naming.into(),\n            precision: precision.into(),\n            dropping: drop.into(),\n            databases,\n        }\n    }\n\n    pub fn naming(mut self, naming: impl Into<NamingStrategy>) -> Self {\n        self.naming = naming.into();\n        self\n    }\n    pub fn dropping(mut self, drop: impl Into<DroppingStrategy>) -> Self {\n        self.dropping = drop.into();\n        self\n    }\n    pub fn precision(mut self, precision: impl Into<PrecisionStrategy>) -> Self {\n        self.precision = precision.into();\n        self\n    }\n    pub fn databases(mut self, databases: usize) -> Self {\n        self.databases = databases.into();\n        self\n    }\n\n    pub fn build(self) -> Result<TaosWrapper> {\n        let opts = TaosOptions::new();\n        log::trace!(\"use options: {opts:#?}\");\n\n        let taos = opts.build()?;\n        log::info!(\"connected\");\n\n        let db: Vec<_> = self\n            .naming\n            .into_iter()\n            .zip(self.precision.into_iter())\n            .take(self.databases)\n            .collect();\n        let mut used = false;\n        for (name, precision) in &db {\n            if self.dropping.drop_before() {\n                taos.exec(format!(\"drop database if exists {}\", name))?;\n            }\n            taos.exec(format!(\n                \"create database if not exists {} precision '{}' keep 36500\",\n                name, precision\n            ))?;\n            if !used {\n                taos.exec(format!(\"use {}\", name))?;\n                used = true;\n            }\n        }\n        Ok(TaosWrapper {\n            taos,\n            db,\n            drop: self.dropping,\n        })\n    }\n}\n\npub struct TaosWrapper {\n    taos: Taos,\n    db: Vec<(String, Precision)>,\n    drop: DroppingStrategy,\n}\n\nimpl Deref for TaosWrapper {\n    type Target = Taos;\n\n    fn deref(&self) -> &Self::Target {\n        &self.taos\n    }\n}\n\nimpl Drop for TaosWrapper {\n    fn drop(&mut self) {\n        self.clean().unwrap();\n    }\n}\n\nimpl TaosWrapper {\n    pub fn taos(&self) -> &Taos {\n        &self.taos\n    }\n\n    pub fn databases_with_precision(&self) -> &[(String, Precision)] {\n        &self.db\n    }\n\n    pub fn databases(&self) -> Vec<&str> {\n        self.db.iter().map(|v| v.0.as_str()).collect()\n    }\n\n    pub fn default_database(&self) -> &str {\n        &self.db[0].0\n    }\n\n    fn clean(&self) -> Result<()> {\n        if self.drop.drop_after() {\n            for (name, _) in &self.db {\n                log::trace!(\"drop database: {}\", name);\n                self.taos\n                    .exec(format!(\"drop database if exists {}\", name))?;\n                log::trace!(\"dropped database: {}\", name);\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":21,"address":[3801008,3802275],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":23,"address":[3801047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3801093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[3754929,3754852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3803420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[3803474,3803564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3801134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[3755041,3754964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[3801222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[3801319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[3801428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[3801530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[3801880,3801550,3801742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[3801893,3801766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3801712,3801916,3802190,3802050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[3802399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3802647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3802982,3802866,3802742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3802928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[3803214,3802710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[3803240,3802609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3803294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[3803279,3803367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[3801188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[3803872],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":91,"address":[3803891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3803952],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":97,"address":[3803955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3803968],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":103,"address":[3803980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3804000],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":110,"address":[3804050,3804119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3804091,3804140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3804254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[3804320,3804639],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":118,"address":[3804347,3804419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3804506,3804435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3804533,3804478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3804672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3804768],"length":1,"stats":{"Line":0},"fn_name":"drop_after"},{"line":138,"address":[3804777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3804832],"length":1,"stats":{"Line":0},"fn_name":"drop_before"},{"line":142,"address":[3804841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[3804880],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":148,"address":[3804903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[3804992,3804928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[3805052,3804969,3805013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[3805102,3805063,3805029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[3805155,3805079,3805113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[3805264,3805360],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":160,"address":[3805332,3805273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[3805392],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":166,"address":[3805396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[3805424],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":172,"address":[3805428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[3805440],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":186,"address":[3805454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[3805508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[3755125,3755072],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":195,"address":[3755076,3755153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[3805779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3805830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[3805562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[3805667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[3805677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[3805687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3805695,3805740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[3805730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3805872],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":219,"address":[3805881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[3805920],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":225,"address":[3805924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[3805952],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":231,"address":[3805956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3805984,3806250],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":237,"address":[3806001,3806276,3806401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[3806432,3806782],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":246,"address":[3806475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[3806506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[3806661,3806617,3806549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[3806633,3806730,3806691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[3806750,3806697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[3806832],"length":1,"stats":{"Line":1},"fn_name":"to_log_level_filter"},{"line":278,"address":[3806841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[3806870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[3806881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3806892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[3806903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[3806914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3806925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3806936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[3806960],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":291,"address":[3806964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[3806976],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":299,"address":[3807000,3807064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[3807121,3807082,3807041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[3807098,3807132,3807171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[3807221,3807182,3807148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[3807274,3807235,3807198],"length":1,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[3807251,3807288,3807304],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[3807294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3807328],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":312,"address":[3807332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[3286720,3286768],"length":1,"stats":{"Line":2},"fn_name":"log_level<()>"},{"line":323,"address":[3286731,3286809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[3286748,3286826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[3807360],"length":1,"stats":{"Line":1},"fn_name":"init"},{"line":328,"address":[3807380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[3755583,3755184,3755793],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":331,"address":[3755204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[3755286,3755694,3755228],"length":1,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[3755741,3755343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3755362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[3755548,3755460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[3755715,3755748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[3755824,3757345,3757217],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":342,"address":[3807712],"length":1,"stats":{"Line":0},"fn_name":"colored_level"},{"line":346,"address":[3807747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[3807903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[3807974,3807876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3807849,3808004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[3808034,3807819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[3807789,3808064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[3755871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[3755893,3755976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[3755991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[3756051,3756242,3756386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[3756132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[3756317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[3756716,3756952,3757228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3756677,3756614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[3756927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[3807551,3807614,3807460],"length":1,"stats":{"Line":4},"fn_name":null},{"line":376,"address":[3807592],"length":1,"stats":{"Line":3},"fn_name":null},{"line":414,"address":[3808096,3808220],"length":1,"stats":{"Line":0},"fn_name":"databases"},{"line":415,"address":[3808196,3808133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[3808200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[3809727,3811598,3808256],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":420,"address":[3808293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[3808657,3808563,3808466,3808377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[3808627,3808863,3808977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[3809306,3808933,3809436,3809209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[3809623,3809678,3809378,3809738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[3809558,3809666,3809705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[3809674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[3809765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[3809868,3809773,3810134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[3810497,3810170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[3810239,3810502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[3810201,3811087,3810703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[3810977,3811391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[3811396,3811137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[3811383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[3810014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[3809971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[3809979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[3810011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[3811632],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":469,"address":[3723040],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":470,"address":[3723049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[3811648],"length":1,"stats":{"Line":0},"fn_name":"taos"},{"line":479,"address":[3811664],"length":1,"stats":{"Line":0},"fn_name":"databases_with_precision"},{"line":480,"address":[3811673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[3811712],"length":1,"stats":{"Line":0},"fn_name":"databases"},{"line":484,"address":[3757401,3757376],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":487,"address":[3811856],"length":1,"stats":{"Line":0},"fn_name":"default_database"},{"line":488,"address":[3811865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[3811936],"length":1,"stats":{"Line":0},"fn_name":"clean"},{"line":492,"address":[3811956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[3811998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[3812296,3812101,3812201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[3812582,3812755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[3812267,3812455,3812699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[3812860,3812661,3812800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[3811979],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":26,"coverable":175},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","impls","asyncs.rs"],"content":"use std::ffi::c_void;\nuse std::os::raw::c_int;\n\nuse async_trait::async_trait;\n\nuse taos_query::common::*;\nuse taos_query::{AsyncFetchable, AsyncQueryable};\nuse taos_sys::DroppableRawRes;\n\nuse super::ResultSet;\nuse crate::util::IntoCStr;\nuse crate::Taos;\n\nimpl AsyncFetchable for ResultSet {\n    type BlockStream = crate::block::BlockStream;\n\n    #[inline]\n    fn affected_rows(&self) -> i32 {\n        self.raw.affected_rows()\n    }\n\n    #[inline]\n    fn precision(&self) -> Precision {\n        self.raw.precision()\n    }\n\n    #[inline]\n    fn fields(&self) -> &[Field] {\n        &self.raw.fields()\n    }\n\n    #[inline]\n    fn summary(&self) -> (usize, usize) {\n        use std::sync::atomic::Ordering::SeqCst;\n        (\n            self.summary.0.load(SeqCst) as _,\n            self.summary.1.load(SeqCst) as _,\n        )\n    }\n\n    #[inline]\n    fn block_stream(&mut self) -> Self::BlockStream {\n        crate::block::BlockStream::from_raw(self.raw.raw(), self.summary.clone())\n    }\n}\n\n#[async_trait]\nimpl<'q> AsyncQueryable<'q> for Taos {\n    type Error = super::Error;\n\n    type AsyncResultSet = ResultSet;\n\n    /// Query use taosc query_a API.\n    async fn query<T: AsRef<str> + Send>(\n        &'q self,\n        sql: T,\n    ) -> Result<Self::AsyncResultSet, Self::Error> {\n        // todo(3.0): remove these line to use taos_query_a in async/await impl.\n        if crate::client_info().starts_with(\"3\") {\n            let raw = self.0.query(sql.as_ref())?;\n            return Ok(ResultSet::new(raw));\n        }\n        use tokio::sync::oneshot::{channel, Sender};\n        let (sender, rx) = channel::<Result<Self::AsyncResultSet, taos_error::Error>>();\n\n        pub unsafe extern \"C\" fn async_query_callback(\n            param: *mut c_void,\n            ptr: *mut c_void,\n            code: c_int,\n        ) {\n            let sender = param as *mut Sender<_>;\n            let sender = Box::from_raw(sender);\n            let code = if code > 0 { 0 } else { code };\n            let res = DroppableRawRes::from_ptr_with_code(ptr, code.into()).map(ResultSet::new);\n\n            log::trace!(\n                \"in async query callback, got TAOS_RES: {res:?}, will be send to:{sender:?}\"\n            );\n\n            sender.send(res).unwrap();\n            log::trace!(\"ptr: {ptr:#?}, code: {code}\");\n        }\n        self.0.query_a(\n            sql.as_ref().into_c_str().as_ptr(),\n            async_query_callback as _,\n            Box::into_raw(Box::new(sender)) as *mut _,\n        );\n        Ok(rx.await.unwrap()?)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use anyhow::Result;\n    use taos_macros::test;\n\n    #[test(log_level = \"info\")]\n    async fn async_query_de(taos: &Taos, _database: &str) -> Result<()> {\n        use taos_query::{AsyncFetchable, AsyncQueryable};\n        taos.exec(\n            \"create table tb1 (ts timestamp, level tinyint, content varchar(100),\\\n             dnode_id int, dnode_ep varchar(100))\",\n        )\n        .await?;\n        taos.exec(\"insert into tb1 values(now, 1, '', 1, 'abc')\")\n            .await?;\n        let mut rs = <Taos as AsyncQueryable>::query(taos, \"select * from tb1\").await?;\n\n        assert!(rs.fields().len() == 5);\n        #[derive(Debug, serde::Deserialize)]\n        #[allow(dead_code)]\n        struct Record {\n            ts: String,\n            level: i8,\n            content: String,\n            dnode_id: i32,\n            dnode_ep: String,\n        }\n\n        use futures::prelude::stream::*;\n        use taos_query::BlockExt;\n        while let Some(block) = rs.block_stream().next().await {\n            let des = itertools::Itertools::collect_vec(\n                block.deserialize::<(i64, i32, &str, i32, String)>().take(1),\n            );\n            log::info!(\"first row in block: {:?}\", des);\n        }\n        let (blocks, records) = rs.summary();\n        println!(\"total blocks: {}, total rows: {}\", blocks, records);\n        assert!(records <= 10000);\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[3482160],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":19,"address":[3482169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[3482208],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":24,"address":[3482217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3482256],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":29,"address":[3482265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[3482320],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":36,"address":[3482334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3482379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3482639,3482464,3482611],"length":1,"stats":{"Line":0},"fn_name":"block_stream"},{"line":43,"address":[3482623,3482496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3783280,3783552],"length":1,"stats":{"Line":0},"fn_name":"query<alloc::string::String>"},{"line":59,"address":[3997539,3994792,3997448,3994859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3995019,3997695,3997830,3997621,3994941,3995154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3998039,3995363,3997792,3995116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3997582,3995481,3998178,3994902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4011072,4012468,4012517],"length":1,"stats":{"Line":0},"fn_name":"async_query_callback"},{"line":71,"address":[4011109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4011133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4011162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4011194,4011291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4011531,4011700,4011345,4011434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4011595,4011948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4011974,4012098,4012183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3995901,3998594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3995584,3995703,3998277,3995505,3998202,3998396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[3995867,3998560,3998408,3995715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3705342,3706047],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","impls","mod.rs"],"content":"use std::{\n    ffi::c_void,\n    slice,\n    sync::{atomic::AtomicU64, Arc},\n};\n\nuse bitvec_simd::BitVec;\nuse itertools::Itertools;\nuse mdsn::IntoDsn;\nuse taos_error::Code;\nuse thiserror::Error;\n\nuse taos_query::{common::*, Address, BlockExt, Dsn, DsnError, Fetchable, FromDsn, Queryable};\nuse taos_sys::{DroppableRawRes, RawRes, ffi::TAOS_RES};\n\nuse crate::{util::IntoCStr, Taos, TaosOptions};\n\n#[derive(Debug, Error)]\npub enum Error {\n    #[error(\"Parse dsn error: {0}\")]\n    DsnError(#[from] DsnError),\n    #[error(\"Internal error: {0}\")]\n    Driver(#[from] taos_error::Error),\n    #[error(\"Deserialization error {0}\")]\n    Deserialize(#[from] serde::de::value::Error),\n    #[error(\"Invalid topic: {0}\")]\n    InvalidTopic(String),\n    #[error(\"Invalid database: {0}\")]\n    InvalidDatabase(String),\n    #[error(\"Error: {0}\")]\n    Custom(String),\n    #[error(transparent)]\n    Other(#[from] anyhow::Error),\n}\n\nimpl Error {\n    pub(crate) fn custom<T>(msg: T) -> Self\n    where\n        T: std::fmt::Display,\n    {\n        Error::Custom(format!(\"{msg}\"))\n    }\n}\n\nimpl serde::de::Error for Error {\n    fn custom<T>(msg: T) -> Self\n    where\n        T: std::fmt::Display,\n    {\n        Error::Custom(format!(\"{msg}\"))\n    }\n}\n\n// A result should not be clone-able.\n// Result set live shorter than query lifetime.\n#[derive(Debug)]\npub struct ResultSet {\n    raw: DroppableRawRes,\n    independent: bool,\n    summary: Arc<(AtomicU64, AtomicU64)>,\n}\n\nimpl ResultSet {\n    pub(crate) fn from_ptr(ptr: *mut c_void) -> Result<Self, taos_error::Error> {\n        let raw = RawRes::from_ptr(ptr).map(DroppableRawRes::new)?;\n        Ok(ResultSet {\n            raw,\n            independent: false,\n            summary: Default::default(),\n        })\n    }\n    pub(crate) fn from_ptr_with_code(\n        ptr: *mut c_void,\n        code: impl Into<Code>,\n    ) -> Result<Self, taos_error::Error> {\n        let raw = RawRes::from_ptr_with_code(ptr, code.into()).map(DroppableRawRes::new)?;\n        Ok(ResultSet {\n            raw,\n            independent: false,\n            summary: Default::default(),\n        })\n    }\n\n    pub(crate) fn as_ptr(&self) -> *mut TAOS_RES {\n        self.raw.as_ptr()\n    }\n\n    pub(crate) fn from_raw_res(raw: RawRes) -> Self {\n        Self {\n            raw: DroppableRawRes::new(raw),\n            independent: false,\n            summary: Default::default(),\n        }\n    }\n\n    pub(crate) fn new(raw: DroppableRawRes) -> Self {\n        Self {\n            raw,\n            independent: false,\n            summary: Default::default(),\n        }\n    }\n\n    pub(crate) fn independent(mut self) -> Self {\n        self.independent = true;\n        self\n    }\n\n    pub(crate) fn append_num_of_rows(&self, num_of_rows: i32) {\n        use std::sync::atomic::Ordering::SeqCst;\n        self.summary.0.fetch_add(1, SeqCst);\n        self.summary.1.fetch_add(num_of_rows as _, SeqCst);\n    }\n}\n\n#[derive(Debug)]\npub struct SyncBlock {\n    pub raw: Arc<RawRes>,\n    pub fields: Option<Vec<Field>>,\n    pub precision: Precision,\n    pub data: *mut *mut c_void,\n    pub lengths: *const i32,\n    pub num_of_rows: usize,\n}\n\nunsafe impl Send for SyncBlock {}\nunsafe impl Sync for SyncBlock {}\n\nimpl SyncBlock {\n    pub fn tmq_table_name(&self) -> Option<&str> {\n        self.raw.tmq_table_name()\n    }\n    pub fn tmq_db_name(&self) -> Option<&str> {\n        self.raw.tmq_db_name()\n    }\n}\n\nimpl<'b> BlockExt for SyncBlock {\n    // type Value = BorrowedValue<'b>;\n\n    fn num_of_rows(&self) -> usize {\n        self.num_of_rows\n    }\n\n    fn fields(&self) -> &[Field] {\n        if let Some(fields) = self.fields.as_ref() {\n            fields\n        } else {\n            &self.raw.fields()\n        }\n    }\n\n    fn precision(&self) -> Precision {\n        self.precision\n    }\n\n    fn is_null(&self, row: usize, col: usize) -> bool {\n        self.raw.is_null(row as _, col as _)\n    }\n\n    unsafe fn cell_unchecked(&self, row: usize, col: usize) -> (&Field, BorrowedValue) {\n        let inner = self.data.add(col);\n        // log::debug!(\"inner: {inner:?} at ({row}, {col})\");\n\n        let field = self.get_field_unchecked(col);\n        let is_null = self.is_null(row, col);\n        if is_null {\n            return (field, BorrowedValue::Null);\n        }\n\n        macro_rules! parse_cell {\n            ($f:ident, $t:ty) => {\n                paste::paste! {\n                    BorrowedValue::$f({\n                        (*inner as *const $t).add(row).read()\n                    })\n                }\n            };\n        }\n\n        let read_bytes_from_ptr = |inner: *mut *mut c_void, col: usize| {\n            if crate::client_info().starts_with(\"3\") {\n                let offsets = self.raw.get_column_data_offset(col);\n                let offset = offsets.add(row).read();\n                if offset == -1 {\n                    \"\".as_bytes()\n                } else {\n                    let ptr = (*inner as *const u8).add(offset as usize);\n                    let len = ptr.cast::<i16>().read();\n                    let start = ptr.offset(2);\n\n                    slice::from_raw_parts(start, len as _)\n                }\n            } else {\n                let length = *self.lengths.add(col) as usize;\n                let ptr = (*inner as *const u8).add(row * length as usize);\n                let len = ptr.cast::<i16>().read();\n                let start = ptr.offset(2);\n\n                slice::from_raw_parts(start, len as _)\n            }\n        };\n\n        let value = match field.ty() {\n            Ty::Null => BorrowedValue::Null,\n            Ty::Bool => parse_cell!(Bool, bool),\n            Ty::TinyInt => parse_cell!(TinyInt, i8),\n            Ty::SmallInt => parse_cell!(SmallInt, i16),\n            Ty::Int => parse_cell!(Int, i32),\n            Ty::BigInt => parse_cell!(BigInt, i64),\n            Ty::UTinyInt => parse_cell!(UTinyInt, u8),\n            Ty::USmallInt => parse_cell!(USmallInt, u16),\n            Ty::UInt => parse_cell!(UInt, u32),\n            Ty::UBigInt => parse_cell!(UBigInt, u64),\n            Ty::Float => parse_cell!(Float, f32),\n            Ty::Double => parse_cell!(Double, f64),\n            Ty::Timestamp => {\n                let raw = (*inner as *const i64).add(row).read();\n                let precision = self.precision();\n                BorrowedValue::Timestamp(Timestamp::new(raw, precision))\n            }\n            Ty::VarChar => BorrowedValue::VarChar(std::str::from_utf8_unchecked(\n                read_bytes_from_ptr(inner, col),\n            )),\n            Ty::NChar => BorrowedValue::NChar(\n                std::str::from_utf8_unchecked(read_bytes_from_ptr(inner, col)).into(),\n            ),\n            Ty::Json => BorrowedValue::Json(read_bytes_from_ptr(inner, col).into()),\n            _ => BorrowedValue::Null,\n        };\n        (field as _, value)\n    }\n\n    unsafe fn get_col_unchecked(&self, col: usize) -> BorrowedColumn {\n        let inner = self.data.add(col);\n        let field = self.get_field_unchecked(col);\n        let num_of_rows = self.num_of_rows() as usize;\n        let is_nulls =\n            BitVec::from_bool_iterator((0..num_of_rows as usize).map(|row| self.is_null(row, col)));\n\n        macro_rules! column_transmute {\n            ($f:ident, $t:ty) => {\n                paste::paste! {\n                    BorrowedColumn::$f(is_nulls, {\n                        std::slice::from_raw_parts(*inner as *const $t, num_of_rows)\n                    })\n                }\n            };\n        }\n        match field.ty() {\n            Ty::Null => BorrowedColumn::Null(num_of_rows),\n            Ty::Bool => column_transmute!(Bool, bool),\n            Ty::TinyInt => column_transmute!(TinyInt, i8),\n            Ty::SmallInt => column_transmute!(SmallInt, i16),\n            Ty::Int => column_transmute!(Int, i32),\n            Ty::BigInt => column_transmute!(BigInt, i64),\n            Ty::UTinyInt => column_transmute!(UTinyInt, u8),\n            Ty::USmallInt => column_transmute!(USmallInt, u16),\n            Ty::UInt => column_transmute!(UInt, u32),\n            Ty::UBigInt => column_transmute!(UBigInt, u64),\n            Ty::Float => column_transmute!(Float, f32),\n            Ty::Double => column_transmute!(Double, f64),\n            Ty::Timestamp => {\n                let raw = std::slice::from_raw_parts(*inner as *const i64, num_of_rows);\n                BorrowedColumn::Timestamp(is_nulls, raw)\n            }\n            Ty::VarChar => {\n                let length = self.lengths.add(col);\n                let item = (0..num_of_rows)\n                    .map(|n| {\n                        let ptr = (*inner as *const u8).offset(n as isize * *length as isize);\n                        let len = ptr.cast::<i16>().read();\n                        let start = ptr.offset(2);\n                        if is_nulls.get_unchecked(n) {\n                            None\n                        } else {\n                            Some(slice::from_raw_parts(start, len as _))\n                        }\n                    })\n                    .collect_vec();\n\n                BorrowedColumn::Binary(item)\n            }\n            Ty::NChar => {\n                let length = self.lengths.add(col);\n                let item = (0..num_of_rows)\n                    .map(|n| {\n                        let ptr = (*inner as *const u8).offset(n as isize * *length as isize);\n                        let len = ptr.cast::<i16>().read();\n                        let start = ptr.offset(2);\n                        if is_nulls.get_unchecked(n) {\n                            None\n                        } else {\n                            Some(std::str::from_utf8_unchecked(slice::from_raw_parts(\n                                start as _, len as _,\n                            )))\n                        }\n                    })\n                    .collect_vec();\n\n                BorrowedColumn::NChar(item)\n            }\n            _ => unreachable!(\"unsupported borrowed column type\"),\n        }\n    }\n}\n\nimpl Fetchable for ResultSet {\n    fn fields(&self) -> &[Field] {\n        &self.raw.fields()\n    }\n\n    fn precision(&self) -> Precision {\n        self.raw.precision()\n    }\n\n    fn summary(&self) -> (usize, usize) {\n        use std::sync::atomic::Ordering::SeqCst;\n        (\n            self.summary.0.load(SeqCst) as _,\n            self.summary.1.load(SeqCst) as _,\n        )\n    }\n\n    fn affected_rows(&self) -> i32 {\n        self.raw.affected_rows()\n    }\n}\n\nimpl Iterator for ResultSet {\n    type Item = SyncBlock;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Ok(Some((data, num_of_rows, lengths))) = self.raw.fetch_block() {\n            log::debug!(\"fetch block with {num_of_rows} rows\");\n            self.append_num_of_rows(num_of_rows);\n            let fields = if self.independent {\n                Some(self.raw.fetch_fields())\n            } else {\n                None\n            };\n\n            Some(SyncBlock {\n                raw: self.raw.raw(),\n                fields,\n                precision: self.precision(),\n                data,\n                lengths,\n                num_of_rows: num_of_rows as _,\n            })\n        } else {\n            None\n        }\n    }\n}\n\nimpl<'r, 'q> SyncBlock {\n    #[inline]\n    pub fn from_raw_with_ptr(\n        raw: Arc<RawRes>,\n        data: *mut *mut c_void,\n        num_of_rows: i32,\n    ) -> Option<Self> {\n        let precision = raw.precision();\n        if num_of_rows > 0 {\n            let lengths = raw.fetch_lengths();\n            Some(SyncBlock {\n                raw,\n                data,\n                fields: None,\n                precision: precision,\n                lengths,\n                num_of_rows: num_of_rows as _,\n            })\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    pub fn from_async_query(\n        raw: Arc<RawRes>,\n        data: *mut *mut c_void,\n        num_of_rows: i32,\n    ) -> Option<Self> {\n        Self::from_raw_with_ptr(raw, data, num_of_rows)\n    }\n}\n\nimpl<'q> Queryable<'q> for Taos {\n    type Error = Error;\n\n    type ResultSet = ResultSet;\n\n    fn query<T: AsRef<str>>(&self, sql: T) -> Result<ResultSet, Self::Error> {\n        log::trace!(\"sql: {}\", sql.as_ref());\n        let raw = self.0.query(sql.as_ref())?;\n        Ok(ResultSet::new(raw))\n    }\n}\n\nimpl FromDsn for Taos {\n    type Err = Error;\n\n    fn hygienize(dsn: Dsn) -> Result<(Dsn, Vec<Address>), DsnError> {\n        if dsn.driver != \"taos\" {\n            return Err(DsnError::InvalidDriver(dsn.driver));\n        }\n        Ok((dsn, vec![]))\n    }\n\n    fn from_dsn<T: IntoDsn>(dsn: T) -> Result<Self, Self::Err> {\n        let dsn = dsn.into_dsn()?;\n        if dsn.addresses.len() == 0 {\n            Ok(Taos::new(\n                (),\n                &dsn.username,\n                &dsn.password,\n                &dsn.database,\n                0,\n            )?)\n        } else {\n            let Address { host, port, .. } = &dsn.addresses[0];\n            Ok(Taos::new(\n                host,\n                &dsn.username,\n                &dsn.password,\n                &dsn.database,\n                port.unwrap_or_default(),\n            )?)\n        }\n    }\n\n    fn ping(_dsn: &Dsn) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}\n\n#[taos_macros::test(log_level = \"debug\")]\nfn show_databases(taos: &Taos) -> Result<(), Error> {\n    let mut rs = <Taos as Queryable>::query(taos, \"show databases\")?;\n\n    log::debug!(\"{rs:?}\");\n\n    let fields = rs.fields();\n\n    log::debug!(\"fields[{}]: {fields:?}\", fields.len());\n\n    let precision = rs.precision();\n    log::debug!(\"precision: {}\", precision);\n\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Record {\n        name: String,\n        ntables: u64,\n    }\n\n    for record in rs.deserialize() {\n        let record: Record = record?;\n        println!(\"{record:?}\");\n    }\n\n    Ok(())\n}\n\n#[taos_macros::test(crate, log_level = \"trace\")]\nfn sync_query_on_non_queryable_sql(taos: &Taos, database: &str) -> Result<(), Error> {\n    let mut rs = <Taos as Queryable>::query(taos, format!(\"use {database}\"))?;\n\n    assert!(rs.precision() == Precision::Millisecond); // `ms` is the default precision.\n    assert!(rs.fields().len() == 0);\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Record {\n        ts: String,\n        level: i8,\n        content: String,\n        dnode_id: i32,\n        dnode_ep: String,\n    }\n\n    for record in rs.deserialize() {\n        let _: Record = record?;\n    }\n\n    // Queried 0 rows.\n    assert_eq!(rs.summary(), (0, 0));\n    Ok(())\n}\n\n#[taos_macros::test(crate, log_level = \"info\")]\nfn sync_query_de(taos: &Taos, _database: &str) -> Result<(), Error> {\n    let affected_rows = <Taos as Queryable>::exec(taos, \"use log\")?;\n    assert!(affected_rows == 0);\n    let mut rs = <Taos as Queryable>::query(taos, \"select * from log.logs limit 10000\")?;\n\n    assert!(rs.fields().len() == 5);\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Record {\n        ts: String,\n        level: i8,\n        content: String,\n        dnode_id: i32,\n        dnode_ep: String,\n    }\n\n    for record in rs.deserialize() {\n        let _: Record = record?;\n    }\n    let (blocks, records) = rs.summary();\n    println!(\"total blocks: {}, total rows: {}\", blocks, records);\n    Ok(())\n}\n\n#[taos_macros::test(crate)]\nfn sync_query_block_de_ref(taos: &Taos, _database: &str) -> Result<(), Error> {\n    use itertools::Itertools;\n    let mut rs = <Taos as Queryable>::query(taos, \"select * from log.logs limit 10000\")?;\n\n    for block in &mut rs {\n        let des = block\n            .deserialize::<(i64, i32, &str)>()\n            .take(1)\n            .collect_vec();\n        log::info!(\"first row in block: {:?}\", des);\n    }\n\n    let (blocks, records) = rs.summary();\n    println!(\"total blocks: {}, total rows: {}\", blocks, records);\n    Ok(())\n}\n\n#[test]\nfn two_cluster() -> Result<(), Error> {\n    return Ok(());\n    let t1 = TaosOptions::default().port(6030u16).build()?;\n    let d1: (i32, String) = t1.query_one(\"show dnodes\")?.unwrap();\n    let t2 = TaosOptions::default().port(16030u16).build()?;\n    let d2: (i32, String) = t2.query_one(\"show dnodes\")?.unwrap();\n    dbg!(&d1, &d2);\n    assert!(d1 != d2);\n    Ok(())\n}\n\npub(crate) mod asyncs;\n","traces":[{"line":37,"address":[3767856,3768105],"length":1,"stats":{"Line":0},"fn_name":"custom<alloc::string::String>"},{"line":41,"address":[3767955,3767884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3768144,3768630,3768370,3768400],"length":1,"stats":{"Line":0},"fn_name":"custom<core::fmt::Arguments>"},{"line":50,"address":[3768490,3768427,3768230,3768172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3472304,3472707,3472728],"length":1,"stats":{"Line":0},"fn_name":"from_ptr"},{"line":65,"address":[3472466,3472329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3472619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3472427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3472448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[3769117,3768672,3769138],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_with_code<i32>"},{"line":76,"address":[3768876,3768720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3769029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[3768837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[3768858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3472768],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":85,"address":[3472777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3472816,3472943],"length":1,"stats":{"Line":0},"fn_name":"from_raw_res"},{"line":90,"address":[3472830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[3472861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3472976,3473082],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":100,"address":[3472999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3473120],"length":1,"stats":{"Line":0},"fn_name":"independent"},{"line":105,"address":[3473123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[3473127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[3473152],"length":1,"stats":{"Line":0},"fn_name":"append_num_of_rows"},{"line":111,"address":[3473174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3473219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3473280],"length":1,"stats":{"Line":0},"fn_name":"tmq_table_name"},{"line":131,"address":[3473289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3473344],"length":1,"stats":{"Line":0},"fn_name":"tmq_db_name"},{"line":134,"address":[3473353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[3473408],"length":1,"stats":{"Line":0},"fn_name":"num_of_rows"},{"line":142,"address":[3473413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3473424],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":146,"address":[3473438,3473593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[3473486,3473583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[3473509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[3473600],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":154,"address":[3473605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[3473616],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":158,"address":[3473645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[3473712],"length":1,"stats":{"Line":0},"fn_name":"cell_unchecked"},{"line":162,"address":[3473775,3473842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[3473866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[3473904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[3473941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[3474018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3473963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[3770249,3769239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[3769414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[3769556,3769484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[3769577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[3769645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[3769678,3769740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[3769753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[3769838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[3769856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[3769401,3769950,3769331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3770057,3769961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[3770102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3770187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[3770205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[3473987,3474067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[3474126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[3474217,3476351,3474147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[3474300,3474230,3476309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3476264,3474313,3474387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[3474400,3474474,3476222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[3474561,3474487,3476177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[3475721,3475069,3474999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[3475676,3475082,3475156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[3475169,3475634,3475243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3475256,3475589,3475330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[3476129,3474574,3474648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[3476081,3474661,3474735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3474904,3475895,3474830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[3475922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[3475948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[3476019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[3474756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[3475771,3474925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[3475490,3475351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[3474113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[3475408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[3480169,3476400,3478323],"length":1,"stats":{"Line":0},"fn_name":"get_col_unchecked"},{"line":235,"address":[3476530,3476455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3476546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[3476584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[3476622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[3476750,3476816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[3476927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[3480051,3476943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[3479933,3477030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[3479815,3477117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[3477204,3479697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[3479579,3477291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[3477768,3478574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[3477849,3478462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[3477930,3478353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[3478011,3478214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[3479461,3477378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[3479343,3477465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[3477648,3478959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[3478975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[3477560,3479093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[3479169,3479101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3479129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[3770437,3770347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[3770482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[3770567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[3770585,3770688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[3770641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[3770678,3770619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[3479247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3477691,3478699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[3478775,3478707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[3478735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[3770827,3770737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[3770872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[3770957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[3770975,3771103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[3771031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3771013,3771068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[3771009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[3478853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[3480240],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":310,"address":[3480249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[3480304],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":314,"address":[3480313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[3480352],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":320,"address":[3480366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[3480411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[3480496],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":326,"address":[3480505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[3481595,3481650,3480544],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":334,"address":[3480582,3480647,3481590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3480886,3480966,3480705,3480804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[3480949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[3481134,3481160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[3481167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[3481140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[3481469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[3481268,3481335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[3481343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[3481383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3481461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[3480640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[3482036,3481680],"length":1,"stats":{"Line":0},"fn_name":"from_raw_with_ptr"},{"line":364,"address":[3481726,3481809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[3481835,3482034,3481852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3481857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[3481953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[3481926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[3481939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[3481951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[3481845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[3482112],"length":1,"stats":{"Line":0},"fn_name":"from_async_query"},{"line":386,"address":[3482138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[3780176,3782093,3781152,3781117],"length":1,"stats":{"Line":0},"fn_name":"query<&str>"},{"line":396,"address":[3780375,3780216,3781430,3781272,3781187,3780462,3780293,3781351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[3780690,3781405,3781784,3780830,3781644,3780433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[3780787,3782012,3781741,3781042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[3981035,3980705,3980320],"length":1,"stats":{"Line":0},"fn_name":"hygienize"},{"line":406,"address":[3980445,3980350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[3980526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[3980456,3981071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[3981488],"length":1,"stats":{"Line":0},"fn_name":"ping"},{"line":435,"address":[3981496],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":201},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","lib.rs"],"content":"use std::sync::Once;\n\npub use impls::Error;\npub use taos_error::{Code, Error as TaosError};\n\npub use taos_query as query;\nuse taos_sys::*;\n\nmacro_rules! err {\n    (custom $err:expr) => {\n        <crate::Error as ::serde::de::Error>::custom($err)\n    };\n    ('str $err:expr) => {\n        <crate::Error as ::serde::de::Error>::custom($err)\n    };\n}\n\n// pub mod timestamp;\n\nmod options;\n\npub use options::TaosOptions;\n\nmod util;\nuse util::*;\n\n// deprecated method.\nmod async_query;\n\npub mod helpers;\n\npub mod stream;\n\nmod result;\n\npub mod tmq;\n\nmod schemaless;\n\nmod impls;\n\npub type Result<T> = std::result::Result<T, crate::impls::Error>;\n\n#[derive(Debug)]\npub struct Taos(RawTaos);\n\nunsafe impl Send for Taos {}\nunsafe impl Sync for Taos {}\n\nimpl Taos {\n    fn new<'a>(\n        host: impl Into<NullableCStr<'a>>,\n        user: impl Into<NullableCStr<'a>>,\n        pass: impl Into<NullableCStr<'a>>,\n        db: impl Into<NullableCStr<'a>>,\n        port: u16,\n    ) -> Result<Self> {\n        Ok(Self(RawTaos::connect(\n            host.into().as_ptr(),\n            user.into().as_ptr(),\n            pass.into().as_ptr(),\n            db.into().as_ptr(),\n            port,\n        )?))\n    }\n\n    /// Asynchronously query with sql\n    // pub fn query<'a, 'query>(\n    //     &'query self,\n    //     sql: impl IntoCStr<'a>,\n    // ) -> impl Future<Output = Result<TaosResult<'query>>> {\n    //     async_query::QueryFuture::new(self, sql)\n    // }\n\n    /// Query without result.\n    // pub async fn exec<'a, 'query>(&'query self, sql: impl IntoCStr<'a>) -> Result<usize> {\n    //     let res = self.query(sql).await?;\n    //     Ok(res.affected_rows() as _)\n    // }\n\n    // pub fn exec_sync<'a, 'query>(&'query self, sql: impl IntoCStr<'a>) -> Result<usize> {\n    //     futures::executor::block_on(self.exec(sql))\n    // }\n\n    // pub fn query_sync<'query>(\n    //     &'query self,\n    //     sql: impl IntoCStr<'query>,\n    // ) -> Result<TaosResult<'query>> {\n    //     futures::executor::block_on(self.query(sql))\n    // }\n\n    // pub fn query_sync2<'query>(\n    //     &'query self,\n    //     sql: impl IntoCStr<'query>,\n    // ) -> Result<TaosResult<'query>> {\n    //     futures::executor::block_on(self.query2(sql))\n    // }\n    // pub fn query_sync3<'query>(\n    //     &'query self,\n    //     sql: impl IntoCStr<'query>,\n    // ) -> Result<TaosResult<'query>> {\n    //     futures::executor::block_on(self.query3(sql))\n    // }\n    // pub async fn query2<'a, 'q>(&'q self, sql: impl IntoCStr<'a>) -> Result<TaosResult<'q>> {\n    //     // use tokio::sync::oneshot;\n    //     use oneshot::channel;\n    //     use oneshot::Sender;\n    //     // use std::sync::mpsc::channel;\n    //     // use std::sync::mpsc::Sender;\n    //     let (sender, rx) = channel();\n\n    //     pub unsafe extern \"C\" fn async_query_callback(\n    //         param: *mut c_void,\n    //         res: *mut c_void,\n    //         code: c_int,\n    //     ) {\n    //         assert!(code == 0);\n    //         // let _ = RawRes::from_ptr(res);\n    //         let v = TaosResult::try_from_ptr(res);\n    //         // let param = param as *mut CallbackArg;\n    //         // let args = Box::from_raw(param);\n    //         // let CallbackArg { sender } = *args;\n    //         // sender.send(v).unwrap();\n    //         let sender = param as *mut Sender<_>;\n    //         let sender = Box::from_raw(sender);\n\n    //         sender.send(v).unwrap();\n    //     }\n    //     // let args = CallbackArg { sender };\n    //     // let args = Box::new(args);\n    //     // let ptr = Box::pin(tx);\n    //     self.0.query_a(\n    //         sql.into_c_str().as_ptr(),\n    //         async_query_callback as _,\n    //         Box::into_raw(Box::new(sender)) as *mut _,\n    //     );\n    //     rx.await.unwrap()\n    //     // rx.await.map_err(|e| Error::from_string(format!(\"{}\", e)))\n    // }\n    // pub async fn query3<'a, 'q>(&'q self, sql: impl IntoCStr<'a>) -> Result<TaosResult<'q>> {\n    //     // use tokio::sync::oneshot;\n    //     use tokio::sync::oneshot::channel;\n    //     use tokio::sync::oneshot::Sender;\n    //     // use std::sync::mpsc::channel;\n    //     // use std::sync::mpsc::Sender;\n    //     let (sender, rx) = channel();\n\n    //     pub unsafe extern \"C\" fn async_query_callback(\n    //         param: *mut c_void,\n    //         res: *mut c_void,\n    //         code: c_int,\n    //     ) {\n    //         assert!(code == 0);\n    //         // let _ = RawRes::from_ptr(res);\n    //         let v = TaosResult::try_from_ptr(res);\n    //         // let param = param as *mut CallbackArg;\n    //         // let args = Box::from_raw(param);\n    //         // let CallbackArg { sender } = *args;\n    //         // sender.send(v).unwrap();\n    //         let sender = param as *mut Sender<_>;\n    //         let sender = Box::from_raw(sender);\n\n    //         sender.send(v).unwrap();\n    //     }\n    //     // let args = CallbackArg { sender };\n    //     // let args = Box::new(args);\n    //     // let ptr = Box::pin(tx);\n    //     self.0.query_a(\n    //         sql.into_c_str().as_ptr(),\n    //         async_query_callback as _,\n    //         Box::into_raw(Box::new(sender)) as *mut _,\n    //     );\n    //     rx.await.unwrap()\n    //     // rx.await.map_err(|e| Error::from_string(format!(\"{}\", e)))\n    // }\n\n    // pub fn query_sync0<'query>(\n    //     &'query self,\n    //     sql: impl IntoCStr<'query>,\n    // ) -> Result<TaosResult<'query>> {\n    //     self.0\n    //         .query(sql.into_c_str().as_ptr())\n    //         .map(TaosResult::from_raw)\n    // }\n\n    pub(crate) fn as_raw(&self) -> *mut taos_sys::ffi::TAOS {\n        self.0.as_ptr()\n    }\n}\n\npub mod block;\n\npub fn client_info() -> &'static str {\n    static ONCE: Once = Once::new();\n    static mut VERSION: &str = \"\";\n    ONCE.call_once(|| unsafe {\n        VERSION = RawTaos::version()\n            .to_str()\n            .expect(\"get client info should always be ok\");\n    });\n    unsafe { VERSION }\n}\npub mod stmt;\n\n#[cfg(feature = \"r2d2\")]\npub mod r2d2;\n\npub mod prelude {\n    //! Preludes for async/await queries.\n    //!\n    //! ```rust\n    //! use taos::prelude::*;\n    //! use tokio;\n    //!\n    //! #[tokio::main]\n    //! async fn main() -> anyhow::Result<()> {\n    //!     let taos = TaosOptions::default().build()?;\n    //!     taos.exec(\"drop database if exists test_prelude\").await?;\n    //!     taos.exec(\"create database test_prelude precision 'us'\").await?;\n    //!     taos.exec(\"use test_prelude\").await?;\n    //!     taos.exec(\"create stable meters (ts timestamp, current float, voltage int, phase float) \\\n    //!                tags(gid int, location binary(16))\").await?;\n    //!     let count: u32 = taos.query_one(\"select count(*) from meters\").await?.unwrap_or(0);\n    //!     assert!(count == 0);\n    //!\n    //!     let results = taos.query(\"select * from meters\").await?;\n    //!     assert!(results.precision() == \"us\");\n    //!     assert_eq!(results.num_of_fields(), 6);\n    //!     Ok(())\n    //! }\n    //! ```\n    pub use crate::impls::Error;\n    pub use crate::impls::ResultSet;\n    pub use crate::impls::SyncBlock;\n    pub use crate::options::TaosOptions;\n    pub use crate::query::FromDsn;\n    pub use crate::schemaless::{SchemalessPrecision, SchemalessProtocol};\n    pub use crate::stmt::{TaosBind, TaosMultiBind};\n    pub use crate::Taos;\n    pub use taos_query::common::{Precision, Timestamp, Ty, Value};\n    pub use taos_query::{common, AsyncFetchable, AsyncQueryable, BlockCodec, BlockExt};\n\n    #[cfg(feature = \"r2d2\")]\n    pub use crate::r2d2::TaosPool;\n\n    pub type Manager = taos_query::Manager<Taos>;\n\n    #[cfg(feature = \"r2d2\")]\n    pub type Pool = taos_query::Pool<Taos>;\n\n    pub mod sync {\n\n        pub use crate::impls::Error;\n        pub use crate::impls::ResultSet;\n        pub use crate::impls::SyncBlock;\n        pub use crate::options::TaosOptions;\n        pub use crate::query::FromDsn;\n        pub use crate::schemaless::{SchemalessPrecision, SchemalessProtocol};\n        pub use crate::stmt::{TaosBind, TaosMultiBind};\n        pub use crate::Taos;\n        // pub use mdsn::{Dsn, IntoDsn};\n\n        pub use taos_query::common::{Precision, Timestamp, Ty, Value};\n        pub use taos_query::{common, BlockCodec, BlockExt, Fetchable, Queryable};\n\n        #[cfg(feature = \"r2d2\")]\n        pub use crate::r2d2::TaosPool;\n\n        pub type Manager = taos_query::Manager<Taos>;\n\n        #[cfg(feature = \"r2d2\")]\n        pub type Pool = taos_query::Pool<Taos>;\n    }\n}\n#[cfg(feature = \"test\")]\npub use taos_macros::test;\n\n// pub use taos_query::BlockExt;\n#[cfg(test)]\nmod tests {\n    use super::{client_info, Taos, TaosOptions};\n    use taos_macros::test;\n\n    use crate::prelude::*;\n    use anyhow::Result;\n\n    #[test]\n    fn test_invalid_database() {\n        let res = TaosOptions::default().database(\"invalid_database\").build();\n        assert!(res.is_err());\n\n        let err = res.unwrap_err();\n        dbg!(err);\n    }\n\n    #[test(log_level = \"trace\")]\n    async fn test_information_schema(taos: &Taos) -> Result<()> {\n        let info: Vec<Value> = taos\n            .query_one(\"select * from information_schema.user_databases where name like 'infor%'\")\n            .await?\n            .unwrap();\n        dbg!(info);\n        Ok(())\n    }\n    #[test]\n    async fn test_describe(taos: &Taos) -> Result<()> {\n        let desc = taos.describe(\"log.logs\").await?;\n        dbg!(desc);\n        Ok(())\n    }\n    #[tokio::test]\n    async fn test_databases() -> Result<()> {\n        let taos = TaosOptions::new().build()?;\n        let desc = taos.databases().await?;\n        println!(\"done\");\n        dbg!(desc);\n        Ok(())\n    }\n    #[test(crate)]\n    fn test_client_info() {\n        let version = client_info();\n        dbg!(format!(\"{version}\"));\n    }\n\n    #[test(crate)]\n    fn test_err() {\n        fn err_with_res() -> Result<()> {\n            let taos = Taos::new(\n                \"localhost\",\n                std::ptr::null() as *const i8,\n                \"taosdata\",\n                std::ptr::null() as *const i8,\n                0,\n            )?;\n            taos.query_sync(\"select * from log.logs\")?;\n            Ok(())\n        }\n        err_with_res().unwrap();\n    }\n    #[test(crate)]\n    fn query_async_await_future_test() {\n        tokio::runtime::Builder::new_multi_thread()\n            .enable_all()\n            .build()\n            .unwrap()\n            .block_on(async {\n                let taos = Taos::new(\"localhost\", \"root\", \"taosdata\", \"log\", 0).unwrap();\n                let mut res = taos\n                    .query(\"select * from log.logs limit 10000\")\n                    .await\n                    .unwrap();\n                let stream = res.block_stream();\n\n                use futures::stream::StreamExt;\n                let lengths = stream\n                    .enumerate()\n                    .map(|(bi, partial)| {\n                        partial\n                            .iter_rows()\n                            .enumerate()\n                            .map(|(ri, values)| {\n                                println!(\"block {bi}, row {ri}: {values:?}\");\n                                return 1;\n                            })\n                            .sum::<usize>()\n                    })\n                    .fold(0, |acc, n| futures::future::ready(acc + n))\n                    .await;\n                println!(\"lengths is {lengths}\");\n            });\n    }\n}\n","traces":[{"line":51,"address":[3782985,3782128,3783151],"length":1,"stats":{"Line":0},"fn_name":"new<&core::option::Option<alloc::string::String>, &core::option::Option<alloc::string::String>, &core::option::Option<alloc::string::String>, &core::option::Option<alloc::string::String>>"},{"line":58,"address":[3782913,3782698,3782209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3782257,3782317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3782387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3782484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3782581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[3981520],"length":1,"stats":{"Line":0},"fn_name":"as_raw"},{"line":187,"address":[3981529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[3981552],"length":1,"stats":{"Line":0},"fn_name":"client_info"},{"line":196,"address":[3783168],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":197,"address":[3783172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[3981573],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","options.rs"],"content":"use std::{\n    collections::BTreeMap,\n    ffi::{CStr, CString},\n    path::PathBuf,\n    sync::Once,\n};\n\nuse crate::{Result, Taos};\n\nuse taos_sys::*;\n\n#[derive(Debug, Default)]\npub struct TaosOptions {\n    pub(crate) host: Option<String>,\n    pub(crate) port: Option<u16>, // make it optional with concern for REST.\n    pub(crate) username: Option<String>,\n    pub(crate) password: Option<String>,\n    pub(crate) database: Option<String>,\n\n    locale: Option<String>,\n    charset: Option<String>,\n    timezone: Option<String>,\n    config_dir: Option<PathBuf>,\n    shell_activity_timer: Option<u16>,\n    pub(crate) params: BTreeMap<String, String>,\n}\n\nmacro_rules! _build_opt {\n    ($option:ident) => {\n        _build_opt!($option, String);\n    };\n    ($option:ident, $ty:ty) => {\n        pub fn $option<T: Into<$ty>>(mut self, $option: T) -> Self {\n            self.$option = Some($option.into());\n            self\n        }\n    };\n    ($option:ident, $setter:block) => {\n        pub fn $option<T: Into<String>>(mut self, $option: T) -> Self {\n            $setter;\n            self\n        }\n    };\n    ($option:ident, $ty:ty, $setter:block) => {\n        pub fn $option<T: Into<$ty>>(mut self, $option: T) -> Self {\n            let $option = $option.into();\n            $setter;\n            self.$option = Some($option);\n            self\n        }\n    };\n}\n\n#[test]\nfn test_options() {\n    let opts = TaosOptions::parse(\"taos+driver:///db\");\n    dbg!(opts);\n}\nimpl TaosOptions {\n    pub fn new() -> Self {\n        Self::default()\n    }\n    pub fn parse(dsn: &str) -> Result<Self> {\n        if dsn.is_empty() {\n            return Ok(Self::new());\n        }\n        let dsn = url::Url::parse(dsn).unwrap();\n        dbg!(dsn);\n        Ok(Self::default())\n    }\n    _build_opt!(host);\n    _build_opt!(username);\n    _build_opt!(password);\n    _build_opt!(database);\n    _build_opt!(port, u16);\n\n    _build_opt!(locale, String, {\n        let cstr = CString::new(locale.clone()).expect(\"invalid locale\");\n        unsafe { taos_options(TSDB_OPTION_LOCALE, cstr.as_c_str().as_ptr() as _) };\n    });\n    _build_opt!(charset, String, {\n        let cstr = CString::new(charset.clone()).expect(\"invalid charset\");\n        unsafe { taos_options(TSDB_OPTION_CHARSET, cstr.as_c_str().as_ptr() as _) };\n    });\n    _build_opt!(timezone, String, {\n        let cstr = CString::new(timezone.clone()).expect(\"invalid timezone\");\n        unsafe { taos_options(TSDB_OPTION_TIMEZONE, cstr.as_c_str().as_ptr() as _) };\n    });\n    _build_opt!(config_dir, PathBuf, {\n        let config_dir = config_dir\n            .canonicalize()\n            .expect(\"invalid path for config dir\");\n        let cstr = CString::new(config_dir.to_string_lossy().as_bytes()).expect(\"path to c string\");\n        unsafe { taos_options(TSDB_OPTION_CONFIGDIR, cstr.as_c_str().as_ptr() as _) };\n    });\n\n    _build_opt!(shell_activity_timer, u16, {\n        let cstr = CString::new(format!(\"{}\", shell_activity_timer))\n            .expect(\"invalid shell activity timer\");\n        unsafe {\n            taos_options(\n                TSDB_OPTION_SHELL_ACTIVITY_TIMER,\n                cstr.as_c_str().as_ptr() as _,\n            )\n        };\n    });\n\n    pub fn set_config_json(&self, json: &str) {\n        let c_str = CString::new(json).expect(\"json to c string\");\n        unsafe {\n            let res = taos_set_config(c_str.as_ptr());\n            if res.code != SET_CONF_RET_SUCC {\n                let msg = CStr::from_ptr(&res.msg as _);\n                panic!(\"set config failed: {}\", msg.to_string_lossy());\n            }\n        }\n    }\n\n    pub fn set_param(&mut self, key: impl Into<String>, value: impl Into<String>) -> &mut Self {\n        self.params.insert(key.into(), value.into());\n        self\n    }\n\n    pub fn build(&self) -> Result<Taos> {\n        static SET_CONFIG: Once = Once::new();\n        SET_CONFIG.call_once(|| {\n            // println!(\"initialize taos options\");\n            if !self.params.is_empty() {\n                let json = serde_json::to_string(&self.params).expect(\"params to json\");\n                self.set_config_json(&json);\n            }\n        });\n\n        Taos::new(\n            &self.host,\n            &self.username,\n            &self.password,\n            &self.database,\n            self.port.unwrap_or(0),\n        )\n    }\n}\n\n#[test]\nfn test_options_builder() {\n    let opts = TaosOptions::new();\n    let _taos = opts.build().unwrap();\n}\n\n#[test]\nfn test_options_builder_all() {\n    use crate::prelude::*;\n    let opts = TaosOptions::new()\n        .locale(\"en_US\")\n        .charset(\"UTF-8\")\n        .timezone(\"Asia/Chongqing\")\n        .config_dir(\"/etc/taos\")\n        .host(\"localhost\")\n        .port(6030u16)\n        .username(\"root\")\n        .password(\"taosdata\");\n    let taos = opts.build().unwrap();\n    let _res = futures::executor::block_on(taos.query(\"show databases\")).unwrap();\n}\n","traces":[{"line":60,"address":[3606992],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":61,"address":[3607000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3607024,3607925],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":64,"address":[3607101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[3607157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3607142,3607232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3607261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3607951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3608016,3608491],"length":1,"stats":{"Line":0},"fn_name":"set_config_json"},{"line":109,"address":[3608047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3608106,3608174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3608207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[3608260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[3608308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3608528],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":126,"address":[3608552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3962670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[3962707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3962837,3962774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[3608587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3608595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[3608607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3608619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3608631],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","r2d2.rs"],"content":"use super::{Error, Result, Taos, TaosOptions};\n\n/// Connection pool with r2d2.\npub type TaosPool = r2d2::Pool<TaosOptions>;\n\nimpl r2d2::ManageConnection for TaosOptions {\n    type Connection = Taos;\n    type Error = Error;\n\n    fn connect(&self) -> Result<Self::Connection> {\n        self.build()\n    }\n\n    fn is_valid(&self, _: &mut Self::Connection) -> Result<()> {\n        Ok(())\n    }\n\n    fn has_broken(&self, _: &mut Self::Connection) -> bool {\n        false\n    }\n}\n\n#[test]\nfn test_r2d2() {\n    use crate::prelude::*;\n    use std::sync::mpsc::channel;\n    use std::thread;\n\n    let opts = TaosOptions::new();\n    let pool = TaosPool::builder().build(opts).expect(\"\");\n    let (tx, rx) = channel();\n    for _ in 0..4 {\n        let tx = tx.clone();\n        let pool = pool.clone();\n        thread::spawn(move || {\n            let taos = pool.get().unwrap();\n            let _ = taos.query_sync(\"show connections\").unwrap().affected_rows();\n            tx.send(10).unwrap();\n        });\n    }\n    for _ in 0..4 {\n        let j = rx.recv().unwrap();\n        println!(\"res: {j}\");\n    }\n}\n","traces":[{"line":10,"address":[3608720],"length":1,"stats":{"Line":0},"fn_name":"connect"},{"line":11,"address":[3608737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[3608768],"length":1,"stats":{"Line":0},"fn_name":"is_valid"},{"line":15,"address":[3608784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3608800],"length":1,"stats":{"Line":0},"fn_name":"has_broken"}],"covered":0,"coverable":5},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","result.rs"],"content":"// // use block::Row;\n// use futures::Stream;\n// use serde::de::DeserializeOwned;\n\n// use taos_sys::{ffi::*, DroppableRawRes as RawRes, *};\n\n// use crate::*;\n\n// #[derive(Debug)]\n// pub enum TaosResult<'a> {\n//     WithFields(RawRes<'a>),\n//     WithoutFields(RawRes<'a>),\n// }\n\n// unsafe impl<'a> Send for TaosResult<'a> {}\n// unsafe impl<'a> Sync for TaosResult<'a> {}\n\n// impl<'a> TaosResult<'a> {\n//     pub(crate) const fn as_raw(&self) -> &RawRes {\n//         match self {\n//             TaosResult::WithFields(res) => res,\n//             TaosResult::WithoutFields(res) => res,\n//         }\n//     }\n//     pub(crate) fn from_raw(raw: RawRes<'a>) -> Self {\n//         match raw.num_fields() {\n//             0 => TaosResult::WithoutFields(raw),\n//             _ => TaosResult::WithFields(raw),\n//         }\n//     }\n\n//     pub(crate) fn new(result: *mut TAOS_RES, code: i32) -> Result<Self> {\n//         if code < 0 {\n//             let code: Code = (code & 0xffff).into();\n//             RawRes::from_ptr_with_code(result, code).map(Self::from_raw)\n//         } else {\n//             RawRes::from_ptr_with_code(result, Code::Success).map(Self::from_raw)\n//         }\n//     }\n\n//     pub fn num_of_fields(&self) -> usize {\n//         self.as_raw().fields().len()\n//     }\n\n//     pub fn precision(&self) -> Precision {\n//         self.as_raw().precision()\n//     }\n\n//     pub fn affected_rows(&self) -> usize {\n//         self.as_raw().affected_rows() as _\n//     }\n\n//     pub fn block_stream(&self) -> block::BlockStream {\n//         block::BlockStream::from_raw(self.as_raw().raw(), Default::default())\n//     }\n\n//     pub fn deserialize_stream<'b, T: 'a + 'b>(\n//         &self,\n//     ) -> impl Stream<Item = std::result::Result<T, serde::de::value::Error>> + '_\n//     where\n//         T: DeserializeOwned,\n//     {\n//         use futures::StreamExt;\n//         use taos_query::BlockExt;\n//         self.block_stream()\n//             .flat_map(|block| futures::stream::iter(block.deserialize_into_vec()))\n//     }\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","schemaless.rs"],"content":"use crate::{taos_schemaless_insert, IntoCStr, Taos};\nuse taos_error::*;\n\nuse itertools::Itertools;\n\npub use taos_sys::{SchemalessPrecision, SchemalessProtocol};\n\nimpl Taos {\n    /// Schemaless insert with different protocol and timestamp precision.\n    ///\n    /// - InfluxDB line protocol\n    ///\n    ///     ```ignore,rust\n    ///     let lines = [\"st,t1=abc,t2=def,t3=anything c1=3i64,c3=L\\\"pass\\\",c2=false,c4=4f64 1626006833639000000\"];\n    ///     taos.schemaless_insert(&lines, TSDB_SML_LINE_PROTOCOL, TSDB_SML_TIMESTAMP_NANOSECONDS)?;\n    ///     ```\n    ///\n    /// - OpenTSDB telnet protocol\n    ///\n    ///     ```ignore,rust\n    ///     let lines = [\"sys.if.bytes.out 1479496100 1.3E3 host=web01 interface=eth0\"];\n    ///     taos.schemaless_insert(&lines, TSDB_SML_LINE_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n    ///     ```\n    ///\n    /// - or OpenTSDB json protocol.\n    ///\n    ///     ```ignore,rust\n    ///     let lines = [r#\"\n    ///         {\n    ///             \"metric\":   \"st\",\n    ///             \"timestamp\":        1626006833,\n    ///             \"value\":    10,\n    ///             \"tags\":     {\n    ///                 \"t1\":   true,\n    ///                 \"t2\":   false,\n    ///                 \"t3\":   10,\n    ///                 \"t4\":   \"123_abc_.!@#$%^&*:;,./?|+-=()[]{}<>\"\n    ///             }\n    ///         }\"#];\n    ///     taos.schemaless_insert(&lines, TSDB_SML_LINE_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n    ///     ```\n    ///\n    pub fn schemaless_insert<'a, T: IntoCStr<'a>>(\n        &self,\n        lines: impl IntoIterator<Item = T>,\n        protocol: SchemalessProtocol,\n        precision: SchemalessPrecision,\n    ) -> Result<i32> {\n        let lines: Vec<_> = lines.into_iter().map(|line| line.into_c_str()).collect();\n        let mut lines = lines\n            .iter()\n            .map(|line| line.as_ptr() as *mut i8)\n            .collect_vec();\n        let lines = lines.as_mut_slice();\n        unsafe {\n            let res = taos_schemaless_insert(\n                self.as_raw(),\n                lines.as_mut_ptr() as *mut *mut i8,\n                lines.len() as _,\n                protocol,\n                precision,\n            );\n\n            taos_sys::RawRes::from_ptr(res).map(|res| res.affected_rows())\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::schemaless::*;\n\n    use crate::prelude::*;\n\n    use anyhow::Result;\n    use taos_sys::TSDB_SML_JSON_PROTOCOL;\n    use taos_sys::TSDB_SML_LINE_PROTOCOL;\n    use taos_sys::TSDB_SML_TELNET_PROTOCOL;\n    use taos_sys::TSDB_SML_TIMESTAMP_SECONDS;\n\n    #[crate::test]\n    /// Test schemaless insert with InfluxDB line protocol\n    async fn line_insert(taos: &Taos, _database: &str) -> Result<()> {\n        let lines = [\"st,t1=abc c1=3i64,c3=\\\"def\\\",c2=false 1626006833639000000\"];\n        // let lines = [\"st,t1=abc c1=3i64,c2=false,c3=L\\\"def\\\" 1626006833639000000\"];\n        let res = taos.schemaless_insert(\n            &lines,\n            TSDB_SML_LINE_PROTOCOL,\n            SchemalessPrecision::Nanoseconds,\n        )?;\n        assert_eq!(res, 1);\n\n        let res = taos.query(\"select * from st\").await?.to_records();\n        println!(\"{res:?}\");\n        Ok(())\n    }\n\n    #[crate::test]\n    /// Test schemaless insert with OpenTSDB telnet protocol\n    async fn telnet_insert(taos: &Taos, _database: &str) -> Result<()> {\n        let lines = [\n            \"sys.if.bytes.out 1479496100 1.3E3 host=web01 interface=eth0\",\n            \"sys.if.bytes.out 1479496200 1.4E3 host=web02 interface=eth1\",\n            \"sys.if.bytes.out 1479496300 2.1E3 host=web03 interface=eth2\",\n            \"sys.if.bytes.out 1479496400 3.5E3 host=web04 interface=eth3\",\n        ];\n\n        let res =\n            taos.schemaless_insert(&lines, TSDB_SML_TELNET_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n        assert_eq!(res, 4);\n\n        let res = taos.query(\"select * from `sys.if.bytes.out`\").await?;\n        println!(\"{res:?}\");\n        Ok(())\n    }\n\n    #[crate::test]\n    /// Test schemaless insert with OpenTSDB json protocol\n    async fn json_insert(taos: &Taos, _database: &str) -> Result<()> {\n        let lines = [r#\"\n        {\n            \"metric\":   \"st\",\n            \"timestamp\":        1626006833,\n            \"value\":    10,\n            \"tags\":     {\n                \"t1\":   true,\n                \"t2\":   false,\n                \"t3\":   10,\n                \"t4\":   \"123_abc_.!@#$%^&*:;,./?|+-=()[]{}<>\"\n            }\n        }\"#];\n        let _: serde_json::Value = serde_json::from_str(lines[0]).unwrap();\n\n        let res =\n            taos.schemaless_insert(&lines, TSDB_SML_JSON_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n        assert_eq!(res, 1);\n\n        let res = taos.query(\"select * from st\").await?;\n        println!(\"{res:?}\");\n\n        Ok(())\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stmt","bind.rs"],"content":"use crate::util::IntoCStr;\n\nuse taos_query::common::Ty;\nuse taos_sys::*;\n\nuse chrono::{DateTime, NaiveDateTime};\nuse paste::paste;\n\nuse std::os::raw::{c_int, c_void};\nuse std::ptr;\nuse std::time::SystemTime;\n\n#[repr(transparent)]\npub struct BindParam(TaosBindV2);\n\nunsafe impl std::marker::Send for BindParam {}\nunsafe impl std::marker::Sync for BindParam {}\n\npub trait IntoBindParam {\n    fn into_bind_param(self) -> BindParam;\n}\n\nimpl IntoBindParam for BindParam {\n    fn into_bind_param(self) -> BindParam {\n        self\n    }\n}\nimpl BindParam {\n    pub fn new(buffer_type: Ty) -> Self {\n        let buffer: *mut c_void = ptr::null_mut();\n        let length: *mut usize = ptr::null_mut();\n        let is_null: *mut c_int = ptr::null_mut();\n        let error: *mut c_int = ptr::null_mut();\n        Self(TaosBindV2 {\n            buffer_type: buffer_type as _,\n            buffer,\n            buffer_length: 0,\n            length,\n            is_null,\n            is_unsigned: 0,\n            error,\n            allocated: 0,\n            u: TaosBindUnionV2 { ts: 0 },\n        })\n    }\n    pub fn null() -> Self {\n        let mut null = Self::new(Ty::Null);\n        let v = Box::new(1i8);\n        null.0.is_null = Box::into_raw(v) as _;\n        null\n    }\n\n    unsafe fn free(&mut self) {\n        if !self.0.buffer.is_null() {\n            Vec::from_raw_parts(self.0.buffer as _, *self.0.length, *self.0.length);\n        }\n        if !self.0.length.is_null() {\n            Box::from_raw(self.0.length);\n        }\n        if !self.0.is_null.is_null() {\n            Box::from_raw(self.0.is_null);\n        }\n        if !self.0.error.is_null() {\n            Box::from_raw(self.0.error);\n        }\n    }\n}\n\nimpl Drop for BindParam {\n    fn drop(&mut self) {\n        unsafe { self.free() }\n    }\n}\n\nmacro_rules! _impl_primitive_into_bind_param {\n    ($ty:ty, $target:ident, $v:expr) => {\n        impl IntoBindParam for $ty {\n            fn into_bind_param(self) -> BindParam {\n                let mut param = BindParam::new(Ty::$target);\n                param.0.buffer_length = std::mem::size_of::<$ty>();\n                let v = Box::new(self);\n                param.0.buffer = Box::into_raw(v) as _;\n                let l = Box::new(param.0.buffer_length);\n                param.0.length = Box::into_raw(l) as _;\n                param\n            }\n        }\n        impl IntoBindParam for &$ty {\n            fn into_bind_param(self) -> BindParam {\n                (*self).into_bind_param()\n            }\n        }\n        impl IntoBindParam for &&$ty {\n            fn into_bind_param(self) -> BindParam {\n                (*self).into_bind_param()\n            }\n        }\n        paste! {\n            #[std::prelude::v1::test]\n            // #[proc_test_catalog::test_catalogue]\n            #[doc = \"Test bind param for type: \" $ty \" => \" $target]\n            fn [<test_ $ty:snake>]() {\n                let v: $ty = $v;\n                let p = v.into_bind_param();\n                let v2 = unsafe { *(p.0.buffer as *const $ty) };\n                assert!(v == v2);\n            }\n        }\n    };\n}\nmacro_rules! _impl_ref_into_bind_param {\n    ($ty:ty) => {\n        impl IntoBindParam for $ty {\n            fn into_bind_param(self) -> BindParam {\n                (&self).into_bind_param()\n            }\n        }\n        impl IntoBindParam for &&$ty {\n            fn into_bind_param(self) -> BindParam {\n                (*self).into_bind_param()\n            }\n        }\n    };\n}\n\nimpl<T: IntoBindParam> IntoBindParam for Option<T> {\n    fn into_bind_param(self) -> BindParam {\n        match self {\n            None => BindParam::null(),\n            Some(v) => v.into_bind_param(),\n        }\n    }\n}\n\nimpl<T: IntoBindParam, E: std::error::Error> IntoBindParam for std::result::Result<T, E> {\n    fn into_bind_param(self) -> BindParam {\n        match self {\n            Err(_) => BindParam::null(),\n            Ok(v) => v.into_bind_param(),\n        }\n    }\n}\n\nimpl IntoBindParam for bool {\n    fn into_bind_param(self) -> BindParam {\n        let v: i8 = if self { 1 } else { 0 };\n        let mut param = BindParam::new(Ty::Bool);\n        param.0.buffer_length = std::mem::size_of::<i8>();\n        let v = Box::new(v);\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\nimpl IntoBindParam for &bool {\n    fn into_bind_param(self) -> BindParam {\n        (*self).into_bind_param()\n    }\n}\nimpl IntoBindParam for &&bool {\n    fn into_bind_param(self) -> BindParam {\n        (*self).into_bind_param()\n    }\n}\n\n_impl_primitive_into_bind_param!(i8, TinyInt, 0);\n_impl_primitive_into_bind_param!(i16, SmallInt, 0);\n_impl_primitive_into_bind_param!(i32, Int, 0);\n_impl_primitive_into_bind_param!(i64, BigInt, 0);\n_impl_primitive_into_bind_param!(u8, UTinyInt, 0);\n_impl_primitive_into_bind_param!(u16, USmallInt, 0);\n_impl_primitive_into_bind_param!(u32, UInt, 0);\n_impl_primitive_into_bind_param!(u64, UBigInt, 0);\n_impl_primitive_into_bind_param!(f32, Float, 0.);\n_impl_primitive_into_bind_param!(f64, Double, 0.);\n\n// impl IntoBindParam for &BStr {\n//     fn into_bind_param(self) -> BindParam {\n//         let mut param = BindParam::new(Ty::Binary);\n//         param.0.buffer_length = self.len();\n\n//         let cstr = self.to_c_string();\n//         param.0.buffer = cstr.as_ptr() as _;\n//         std::mem::forget(cstr);\n\n//         let l = Box::new(param.0.buffer_length);\n//         param.0.length = Box::into_raw(l) as _;\n//         param\n//     }\n// }\n\n// impl IntoBindParam for &BString {\n//     fn into_bind_param(self) -> BindParam {\n//         let bstr: &BStr = self.as_ref();\n//         bstr.into_bind_param()\n//     }\n// }\n// _impl_ref_into_bind_param!(BString);\n\nimpl IntoBindParam for &str {\n    fn into_bind_param(self) -> BindParam {\n        let mut param = BindParam::new(Ty::NChar);\n        param.0.buffer_length = self.len();\n\n        let cstr = self.into_c_str();\n        param.0.buffer = cstr.as_ptr() as _;\n        std::mem::forget(cstr);\n\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\nimpl IntoBindParam for &String {\n    fn into_bind_param(self) -> BindParam {\n        self.as_str().into_bind_param()\n    }\n}\n_impl_ref_into_bind_param!(String);\n\nimpl IntoBindParam for &SystemTime {\n    fn into_bind_param(self) -> BindParam {\n        let mut param = BindParam::new(Ty::Timestamp);\n        param.0.buffer_length = std::mem::size_of::<i64>();\n        let duration = self\n            .duration_since(std::time::UNIX_EPOCH)\n            .expect(\"systemtime before unix epoch is not invalid\");\n        // FIXME(@huolinhe): an global flag for precision should be setted.\n        let v = Box::new(duration.as_millis());\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\n_impl_ref_into_bind_param!(SystemTime);\n\nimpl IntoBindParam for &NaiveDateTime {\n    fn into_bind_param(self) -> BindParam {\n        let mut param = BindParam::new(Ty::Timestamp);\n        param.0.buffer_length = std::mem::size_of::<i64>();\n        let timestamp = self.timestamp_millis();\n        // FIXME(@huolinhe): an global flag for precision should be setted.\n        let v = Box::new(timestamp);\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\n_impl_ref_into_bind_param!(NaiveDateTime);\n\nimpl<Tz: chrono::TimeZone> IntoBindParam for &DateTime<Tz> {\n    fn into_bind_param(self) -> BindParam {\n        let mut param = BindParam::new(Ty::Timestamp);\n        param.0.buffer_length = std::mem::size_of::<i64>();\n        let timestamp = self.timestamp_millis();\n        // FIXME(@huolinhe): an global flag for precision should be setted.\n        let v = Box::new(timestamp);\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\n\n// impl IntoBindParam for &Timestamp {\n//     fn into_bind_param(self) -> BindParam {\n//         let mut param = BindParam::new(Ty::Timestamp);\n//         param.0.buffer_length = std::mem::size_of::<i64>();\n//         let v = Box::new(self.timestamp);\n//         param.0.buffer = Box::into_raw(v) as _;\n//         let l = Box::new(param.0.buffer_length);\n//         param.0.length = Box::into_raw(l) as _;\n//         param\n//     }\n// }\n// _impl_ref_into_bind_param!(Timestamp);\n\n// impl IntoBindParam for &serde_json::Value {\n//     fn into_bind_param(self) -> BindParam {\n//         let mut param = BindParam::new(Ty::Json);\n\n//         let data = serde_json::to_vec(self).expect(\"json to u8 vector\");\n//         param.0.buffer_length = data.len();\n\n//         param.0.buffer = data.as_ptr() as _;\n//         std::mem::forget(data);\n\n//         let l = Box::new(param.0.buffer_length);\n//         param.0.length = Box::into_raw(l) as _;\n//         param\n//     }\n// }\n// _impl_ref_into_bind_param!(serde_json::Value);\n\n// impl IntoBindParam for &Field {\n//     fn into_bind_param(self) -> BindParam {\n//         match self {\n//             Field::Null => BindParam::null(),\n//             Field::Timestamp(v) => v.into_bind_param(),\n//             Field::Bool(v) => v.into_bind_param(),\n//             Field::TinyInt(v) => v.into_bind_param(),\n//             Field::SmallInt(v) => v.into_bind_param(),\n//             Field::Int(v) => v.into_bind_param(),\n//             Field::BigInt(v) => v.into_bind_param(),\n//             Field::UTinyInt(v) => v.into_bind_param(),\n//             Field::USmallInt(v) => v.into_bind_param(),\n//             Field::UInt(v) => v.into_bind_param(),\n//             Field::UBigInt(v) => v.into_bind_param(),\n//             Field::Float(v) => v.into_bind_param(),\n//             Field::Double(v) => v.into_bind_param(),\n//             Field::Binary(v) => v.into_bind_param(),\n//             Field::NChar(v) => v.into_bind_param(),\n//             Field::Json(v) => v.into_bind_param(),\n//             _ => unreachable!(),\n//         }\n//     }\n// }\n// _impl_ref_into_bind_param!(Field);\n","traces":[{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stmt","mod.rs"],"content":"use crate::{impls::ResultSet, Taos};\nuse taos_sys::stmt::RawStmt;\n\nuse std::marker::PhantomData;\n\npub use taos_sys::{TaosBind, TaosMultiBind};\n\ntype Result<T> = std::result::Result<T, taos_error::Error>;\n/// Stmt handler.\npub struct Stmt<'stmt>(RawStmt, PhantomData<&'stmt Taos>);\n\nimpl<'stmt> Stmt<'stmt> {\n    pub fn execute(&self) -> Result<()> {\n        self.0.execute()\n    }\n\n    pub fn result(&mut self) -> ResultSet {\n        ResultSet::from_raw_res(self.0.use_result())\n    }\n\n    pub fn multi_bind(&mut self, params: &[TaosMultiBind]) -> Result<()> {\n        self.0.bind_param_batch(params)?;\n        self.0.add_batch()?;\n        Ok(())\n    }\n\n    pub fn multi_bind_at(&mut self, bind: &TaosMultiBind, col: usize) -> Result<()> {\n        self.0.bind_single_param_batch(bind, col as i32)\n    }\n\n    pub fn num_params(&self) -> Result<usize> {\n        Ok(self.0.num_params()? as _)\n    }\n\n    pub fn set_tbname_tags(&mut self, name: impl AsRef<str>, tags: &[TaosBind]) -> Result<()> {\n        self.0.set_tbname_tags_v3(name.as_ref(), tags)\n    }\n    pub fn set_tbname(&mut self, name: impl AsRef<str>) -> Result<()> {\n        self.0.set_tbname(name.as_ref())\n    }\n    pub fn set_sub_tbname(&mut self, name: impl AsRef<str>) -> Result<()> {\n        self.0.set_sub_tbname(name.as_ref())\n    }\n\n    pub fn is_insert(&self) -> bool {\n        self.0.is_insert().unwrap_or(false)\n    }\n\n    pub fn affected_rows(&self) -> usize {\n        self.0.affected_rows() as _\n    }\n}\n\n// impl<'c> From<&'c Column> for MultiBind<'c> {\n//     fn from(col: &'c Column) -> Self {\n//         match col {\n//             Column::Null(n) => MultiBind::nulls(*n),\n//             Column::Bool(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::TinyInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::SmallInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::Int(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::BigInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::UTinyInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::USmallInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::UInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::UBigInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::Float(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::Double(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             Column::Timestamp(nulls, values) => MultiBind::from_raw_timestamps(nulls, values),\n//             Column::Binary(values) => MultiBind::from_binary_vec(values),\n//             Column::NChar(values) => MultiBind::from_string_vec(values),\n//             _ => unreachable!(),\n//         }\n//     }\n// }\n\n// impl<'b> From<BorrowedColumn<'b>> for MultiBind<'b> {\n//     fn from(col: BorrowedColumn<'b>) -> Self {\n//         match col {\n//             BorrowedColumn::Null(n) => MultiBind::nulls(n),\n//             BorrowedColumn::Bool(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::TinyInt(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::SmallInt(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::Int(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::BigInt(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::UTinyInt(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::USmallInt(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::UInt(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::UBigInt(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::Float(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::Double(nulls, values) => MultiBind::from_primitives(&nulls, values),\n//             BorrowedColumn::Timestamp(nulls, values) => {\n//                 MultiBind::from_raw_timestamps(&nulls, values)\n//             }\n//             BorrowedColumn::Binary(values) => MultiBind::from_binary_vec(&values),\n//             BorrowedColumn::NChar(values) => MultiBind::from_string_vec(&values),\n//             _ => unreachable!(),\n//         }\n//     }\n// }\n\n// impl<'b, 'c> From<&'c BorrowedColumn<'b>> for MultiBind<'c> {\n//     fn from(col: &'c BorrowedColumn<'b>) -> Self {\n//         match col {\n//             BorrowedColumn::Null(n) => MultiBind::nulls(*n),\n//             BorrowedColumn::Bool(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::TinyInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::SmallInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Int(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::BigInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UTinyInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::USmallInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UBigInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Float(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Double(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Timestamp(nulls, values) => {\n//                 MultiBind::from_raw_timestamps(nulls, values)\n//             }\n//             BorrowedColumn::Binary(values) => MultiBind::from_binary_vec(values),\n//             BorrowedColumn::NChar(values) => MultiBind::from_string_vec(values),\n//             _ => unreachable!(),\n//         }\n//     }\n// }\n\nimpl Taos {\n    /// Create stmt with sql\n    pub fn stmt<'a, 'stmt>(&'stmt self, sql: impl AsRef<str>) -> Result<Stmt<'stmt>> {\n        let mut stmt = RawStmt::from_raw_taos(&self.0);\n        let sql = sql.as_ref();\n        log::trace!(\"stmt: {sql}\");\n        stmt.prepare(sql)?;\n        Ok(Stmt(stmt, PhantomData))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use bitvec_simd::BitVec;\n    use itertools::Itertools;\n    use taos_query::common::itypes::ITimestamp;\n    use taos_sys::TaosBind;\n    use taos_sys::TaosMultiBind;\n\n    use crate::prelude::common::*;\n    use crate::prelude::sync::*;\n    use crate::test;\n    use anyhow::Result;\n\n    // todo: stmt query support.\n    // #[test]\n    // fn test_stmt(taos: &Taos) -> Result<()> {\n    //     let mut stmt = taos.stmt(\"show databases\")?;\n    //     stmt.execute()?;\n    //     let mut rs = stmt.result();\n    //     for block in rs {\n    //         println!(\"{block:?}\");\n    //     }\n    //     Ok(())\n    // }\n\n    #[test]\n    fn test_multi_bind(taos: &Taos, _database: &str) -> Result<()> {\n        taos.exec(concat!(\n            \"create table if not exists tb (ts timestamp,\",\n            \"c1 bool, c2 tinyint, c3 smallint, c4 int,\",\n            \"c5 bigint,\",\n            \"c6 tinyint unsigned,\",\n            \"c7 smallint unsigned,\",\n            \"c8 int unsigned,\",\n            \"c9 bigint unsigned,\",\n            \"c10 float,\",\n            \"c11 double,\",\n            \"c12 timestamp,\",\n            \"c13 binary(100),\",\n            \"c14 nchar(100))\",\n        ))?;\n\n        const N: usize = 100;\n        let nulls = BitVec::zeros(N);\n\n        let ts = Column::Timestamp(\n            nulls.clone(),\n            (0..N).map(|ts| ts as i64 + 1_500_000_000_000).collect(),\n        );\n\n        macro_rules! col {\n            ($ty:ident) => {\n                dbg!(Column::$ty(\n                    nulls.clone(),\n                    (0..N).map(|_| rand::random()).collect()\n                ))\n            };\n        }\n        let c1 = col!(Bool);\n        let c2 = col!(TinyInt);\n        let c3 = col!(SmallInt);\n        let c4 = col!(Int);\n        let c5 = col!(BigInt);\n        let c6 = col!(UTinyInt);\n        let c7 = col!(USmallInt);\n        let c8 = col!(UInt);\n        let c9 = col!(UBigInt);\n        let c10 = col!(Float);\n        let c11 = col!(Double);\n        let c12 = col!(Timestamp);\n        let c13 = Column::Binary(\n            (0..N)\n                .map(|_| Some(String::from(\"abc\").into_bytes()))\n                .collect(),\n        );\n        let c14 = Column::NChar((0..N).map(|_| None).collect());\n\n        let block = vec![\n            ts, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n        ];\n        let binds: Vec<TaosMultiBind> = block.iter().map(|c| dbg!(c.into())).collect();\n        let marks: String = std::iter::repeat(\"?\").take(15).join(\",\");\n        let mut stmt = taos\n            .stmt(format!(\"insert into tb values({marks})\"))\n            .unwrap();\n        stmt.multi_bind(&binds).unwrap();\n\n        stmt.execute().unwrap();\n\n        let rows = stmt.affected_rows();\n        assert_eq!(N, rows as usize);\n\n        let mut rs = taos.query(\"select * from tb\")?;\n        for row in rs.rows_iter() {\n            for col in &row {\n                println!(\"{:?}\", col);\n            }\n        }\n\n        Ok(())\n    }\n    #[crate::test(naming = \"abc\", dropping = \"none\")]\n    fn test_multi_bind_tags(taos: &Taos, _database: &str) -> Result<()> {\n        taos.exec(concat!(\n            \"create table if not exists tb (ts timestamp, v binary(100)) tags(\",\n            \"c1 bool,\",\n            \"c2 tinyint,\",\n            \"c3 smallint,\",\n            \"c4 int,\",\n            \"c5 bigint,\",\n            \"c6 tinyint unsigned,\",\n            \"c7 smallint unsigned,\",\n            \"c8 int unsigned,\",\n            \"c9 bigint unsigned,\",\n            \"c10 float,\",\n            \"c11 double,\",\n            \"c12 timestamp)\",\n        ))?;\n        const N: usize = 5;\n        let nulls = BitVec::zeros(N);\n        let v: Vec<Option<String>> = (0..N).map(|_| Some(\"hello\".to_string())).collect();\n        let _ints = Column::NChar(v);\n        let v: Vec<Option<Vec<u8>>> = (0..N)\n            .map(|_| Some(\"hello\".to_string().into_bytes()))\n            .collect();\n        let v = Column::Binary(v);\n\n        let ts = Column::Timestamp(\n            nulls.clone(),\n            (0..N).map(|ts| ts as i64 + 1500000000000).collect(),\n        );\n\n        macro_rules! tag {\n            ($v:expr) => {\n                dbg!(TaosBind::from(&$v))\n            };\n        }\n        let c1 = tag!(true);\n        let c2 = tag!(1i8);\n        let c3 = tag!(1i16);\n        let c4 = tag!(1i32);\n        let c5 = tag!(1i64);\n        let c6 = tag!(1u8);\n        let c7 = tag!(1u16);\n        let c8 = tag!(1u32);\n        let c9 = tag!(1u64);\n        let c10 = tag!(0.0f32);\n        let c11 = tag!(0.0f64);\n        let c12 = tag!(ITimestamp(1500000000000));\n        // let c13 = tag!();\n        // let c14 = Column::NChar((0..N).map(|_| None).collect());\n\n        let tags = vec![c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12];\n        let marks: String = std::iter::repeat(\"?\").take(12).join(\",\");\n\n        let block = vec![ts, v];\n        let values: Vec<TaosMultiBind> = block.iter().map(|c| dbg!(c.into())).collect();\n\n        let mut stmt = taos\n            .stmt(format!(\"insert into ? using tb tags({marks}) values(?, ?)\"))\n            .unwrap();\n        stmt.set_tbname_tags(\"tb1\", &tags)?;\n        println!(\"bind parmas: {values:#?}\");\n        stmt.multi_bind(&values).unwrap();\n        stmt.execute().unwrap();\n\n        let rows = stmt.affected_rows();\n        assert_eq!(N, rows as usize);\n\n        let mut res = taos.query(\"select * from tb\").unwrap();\n\n        #[derive(Debug, PartialEq, serde::Deserialize)]\n        struct Row {\n            ts: i64,\n            v: String,\n            c1: bool,\n            c2: i8,\n            c3: i16,\n            c4: i32,\n            c5: i64,\n            c6: u8,\n            c7: u16,\n            c8: u32,\n            c9: u64,\n            c10: f32,\n            c11: f64,\n            c12: i64,\n        }\n        let data: Row = res\n            .deserialize()\n            .next()\n            .expect(\"there's no database\")\n            .expect(\"\");\n        dbg!(&data);\n        assert!(\n            data == Row {\n                ts: 1500000000000,\n                v: \"hello\".to_string(),\n                c1: true,\n                c2: 1,\n                c3: 1,\n                c4: 1,\n                c5: 1,\n                c6: 1,\n                c7: 1,\n                c8: 1,\n                c9: 1,\n                c10: 0.0,\n                c11: 0.0,\n                c12: 1500000000000\n            }\n        );\n        Ok(())\n    }\n}\n\n// #[cfg(test)]\n// mod test {\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(format!(\n//         .await?;\n//         let mut stmt = taos.stmt(\"insert into ? values(?,?)\")?;\n//         stmt.set_tbname(\"tb0\")?;\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         stmt.bind(vec![ts, value.clone()].iter())?;\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select n from tb0\").await?;\n//         assert_eq!(value, res.rows[0][0]);\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n\n//     macro_rules! _test_column_null {\n//         ($ty:ty, $v:expr) => {\n//             paste::paste! {\n//                 #[tokio::test]\n//                 #[test_catalogue()]\n//                 #[doc = \"Test bind null to type \" $ty]\n//                 async fn [<null_ $ty:snake>]() -> Result<(), Error> {\n//                     let db = stdext::function_name!()\n//                         .replace(\"::{{closure}}\", \"\")\n//                         .replace(\"::\", \"_\");\n//                     stmt_test(&db, $v, Field::Null).await\n//                 }\n//             }\n//         };\n//     }\n//     _test_column_null!(bool, \"bool\");\n//     _test_column_null!(tinyint, \"tinyint\");\n//     _test_column_null!(smallint, \"smallint\");\n//     _test_column_null!(int, \"int\");\n//     _test_column_null!(bigint, \"bigint\");\n//     _test_column_null!(utinyint, \"tinyint unsigned\");\n//     _test_column_null!(usmallint, \"smallint unsigned\");\n//     _test_column_null!(uint, \"int unsigned\");\n//     _test_column_null!(ubigint, \"bigint unsigned\");\n//     _test_column_null!(timestamp, \"timestamp\");\n//     _test_column_null!(float, \"float\");\n//     _test_column_null!(double, \"double\");\n//     _test_column_null!(binary, \"binary(10)\");\n//     _test_column_null!(nchar, \"nchar(10)\");\n//     #[should_panic]\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test bind null to json tag, should panic because json is not supported in cols\n//     async fn null_json() -> () {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"json\", Field::Null).await.unwrap()\n//     }\n\n//     async fn stmt_tag(db: &str, ty: &str, tag: Field) -> Result<(), Error> {\n//         let taos = taos()?;\n//         println!(\"test {} using {}\", ty, db);\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(format!(\n//             \"create table if not exists stb0 (ts timestamp, v int) tags (n {})\",\n//             ty\n//         ))\n//         .await?;\n//         println!(\"start stmt\");\n//         let mut stmt = taos.stmt(\"insert into ? using stb0 tags(?) values(?,?)\")?;\n//         println!(\"set tags\");\n//         stmt.set_tbname_tags(\"tb0\", [&tag])?;\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         println!(\"bind stmt\");\n//         stmt.bind(vec![ts, Field::Null].iter())?;\n//         println!(\"execute\");\n//         stmt.execute()?;\n//         println!(\"execute stmt done\");\n//         let res = taos.query(\"select n from tb0\").await?;\n//         assert_eq!(tag, res.rows[0][0]);\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n//     macro_rules! _test_tag_null {\n//         ($ty:ty, $v:expr) => {\n//             paste::paste! {\n//                 #[tokio::test]\n//                 #[test_catalogue()]\n//                 #[doc = \"Test bind null to type \" $ty]\n//                 async fn [<null_tag_ $ty:snake>]() -> Result<(), Error> {\n//                     let db = stdext::function_name!()\n//                         .replace(\"::{{closure}}\", \"\")\n//                         .replace(\"::\", \"_\")\n//                         .replace(\"libtaos_\", \"\");\n//                     stmt_tag(&db, $v, Field::Null).await\n//                 }\n//             }\n//         };\n//     }\n//     _test_tag_null!(bool, \"bool\");\n//     _test_tag_null!(tinyint, \"tinyint\");\n//     _test_tag_null!(smallint, \"smallint\");\n//     _test_tag_null!(int, \"int\");\n//     _test_tag_null!(bigint, \"bigint\");\n//     _test_tag_null!(utinyint, \"tinyint unsigned\");\n//     _test_tag_null!(usmallint, \"smallint unsigned\");\n//     _test_tag_null!(uint, \"int unsigned\");\n//     _test_tag_null!(ubigint, \"bigint unsigned\");\n//     _test_tag_null!(timestamp, \"timestamp\");\n//     _test_tag_null!(float, \"float\");\n//     _test_tag_null!(double, \"double\");\n//     _test_tag_null!(binary, \"binary(10)\");\n//     _test_tag_null!(nchar, \"nchar(10)\");\n//     // set null in json tag is currently abort taosd. see TD-12452.\n//     // TD-12452 is fixed by https://github.com/taosdata/TDengine/pull/9317\n//     _test_tag_null!(json, \"json\");\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with bool values.\n//     async fn bool() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"bool\", Field::Bool(true)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with tiny int values.\n//     async fn tinyint() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"tinyint\", Field::TinyInt(-0x7f)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with small int values.\n//     async fn smallint() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"smallint\", Field::SmallInt(0x7fff)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with int values.\n//     async fn int() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"int\", Field::Int(0x7fffffff)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with bigint values.\n//     async fn bigint() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"bigint\", Field::BigInt(0x7fffffff_ffffffff)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned tinyint values.\n//     async fn utinyint() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"tinyint unsigned\", Field::UTinyInt(0)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned smallint values.\n//     async fn usmallint() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"smallint unsigned\", Field::USmallInt(1)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned int values.\n//     async fn uint() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"int unsigned\", Field::UInt(1)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned bigint values.\n//     async fn ubigint() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"bigint unsigned\", Field::UBigInt(1)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with float values.\n//     async fn float() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"float\", Field::Float(1.0)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with double values.\n//     async fn double() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(&db, \"double\", Field::Double(1.0)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with binary values.\n//     async fn binary() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         let v = Field::Binary(\"0123456789\".into());\n//         stmt_test(&db, \"binary(10)\", v).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with nchar(unicode) values.\n//     async fn nchar() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         let v = Field::NChar(\"一二三四五六七八九十\".into());\n//         stmt_test(&db, \"nchar(10)\", v).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with json values.\n//     async fn json() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         let v = Field::Json(serde_json::from_str(\"{\\\"tag1\\\":\\\"一二三四五六七八九十\\\"}\").unwrap());\n\n//         let taos = taos()?;\n//         println!(\"test json using {}\", db);\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(\"create stable if not exists stb0 (ts timestamp, n int) tags(j json)\")\n//             .await?;\n//         let mut stmt = taos.stmt(\"insert into ? using stb0 tags(?) values(?,?)\")?;\n//         println!(\"set tbname with tags\");\n//         stmt.set_tbname_tags(\"tb0\", [&v])?;\n//         println!(\"bind values\");\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         stmt.bind(vec![ts, Field::Int(3)].iter())?;\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select j from stb0\").await?;\n//         let row = res.rows.iter().next().unwrap();\n//         assert_eq!(&v, row.iter().next().unwrap());\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with all types of values.\n//     async fn all_types() -> Result<(), Error> {\n//         let taos = taos()?;\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         println!(\"{}\", db);\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(\n//             \"create table if not exists tb0 (ts timestamp,\n//              c1 tinyint, c2 smallint, c3 int, c4 bigint,\n//              c5 tinyint unsigned, c6 smallint unsigned, c7 int unsigned, c8 bigint unsigned,\n//              c9 float, c10 double, c11 binary(10), c12 nchar(10))\",\n//         )\n//         .await?;\n//         let mut stmt = taos.stmt(\"insert into ? values(?,?,?,?,?,?,?,?,?,?,?,?,?)\")?;\n//         stmt.set_tbname(\"tb0\")?;\n//         assert!(stmt.is_insert());\n\n//         assert_eq!(stmt.num_params(), 13);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         let c1 = Field::TinyInt(1);\n//         let c2 = Field::SmallInt(2);\n//         let c3 = Field::Int(3);\n//         let c4 = Field::BigInt(4);\n//         let c5 = Field::UTinyInt(5);\n//         let c6 = Field::USmallInt(6);\n//         let c7 = Field::UInt(7);\n//         let c8 = Field::UBigInt(8);\n//         let c9 = Field::Float(9.0);\n//         let c10 = Field::Double(9.0);\n//         let c11 = Field::Binary(\"binary\".into());\n//         let c12 = Field::NChar(\"nchar\".into());\n//         stmt.bind(vec![ts, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12].iter())?;\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select count(*) as count from tb0\").await?;\n//         println!(\"{:?}\", res);\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT set tbname with upper-case stable, see jira TD-12977\n//     async fn test_uppercase_tbname() -> Result<(), Error> {\n//         let db = \"uppercase_test\";\n//         let taos = taos()?;\n//         taos.exec(format!(\"drop database if exists {db}\")).await?;\n//         taos.exec(format!(\"create database {db}\")).await?;\n//         taos.exec(format!(\"use {db}\")).await?;\n//         taos.exec(format!(\"create stable STB(ts timestamp, n int) tags(b int)\")).await?;\n//         let mut stmt = taos.stmt(\"insert into ? using STB tags(?) values(?, ?)\")?;\n\n//         stmt.set_tbname_tags(\"tb0\", [0i32])?;\n//         // stmt.bind(&[0i32])?;\n//         let values = vec![Field::Timestamp(Timestamp::now()), Field::Int(10)];\n//         stmt.bind(&values)?;\n\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n\n//         let _ = stmt.execute()?;\n//         const LIMIT: i64 = 100;\n\n//         for i in 1..LIMIT {\n//             stmt.set_tbname_tags(format!(\"tb{}\", i), &[2i32])?;\n//             stmt.bind(&values)?;\n//         }\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select count(*) as count from stb\").await?;\n//         assert_eq!(res.rows[0][0], Field::BigInt(LIMIT));\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n\n//         Ok(())\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT API insertion with tags\n//     async fn test_stmt_tags() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         println!(\"{:?}\", db);\n//         let taos = taos()?;\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(\"create table if not exists stb (ts timestamp, n int) tags(b int)\")\n//             .await?;\n\n//         let mut stmt = taos.stmt(\"insert into ? using stb tags(?) values(?, ?)\")?;\n\n//         stmt.set_tbname_tags(\"tb0\", [0i32])?;\n//         // stmt.bind(&[0i32])?;\n//         let values = vec![Field::Timestamp(Timestamp::now()), Field::Int(10)];\n//         stmt.bind(&values)?;\n\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n\n//         let _ = stmt.execute()?;\n//         const LIMIT: i64 = 100;\n\n//         for i in 1..LIMIT {\n//             stmt.set_tbname_tags(format!(\"tb{}\", i), &[2i32])?;\n//             stmt.bind(&values)?;\n//         }\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select count(*) as count from stb\").await?;\n//         assert_eq!(res.rows[0][0], Field::BigInt(LIMIT));\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n// }\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stmt","multi_bind.rs"],"content":"use std::{marker::PhantomData, mem::ManuallyDrop};\n\nuse bitvec_simd::BitVec;\n\nuse taos_query::common::Ty;\nuse taos_sys::TaosMultiBind;\n\n#[derive(Debug)]\npub struct MultiBind<'a>(TaosMultiBind, PhantomData<&'a u8>);\n\nunsafe impl<'a> Send for MultiBind<'a> {}\nunsafe impl<'a> Sync for MultiBind<'a> {}\n\npub(crate) trait TaosTypeOf {\n    fn taos_type_of() -> Ty;\n}\n\nmacro_rules! impl_taos_type_of {\n    ($f:ty, $t:ident) => {\n        impl TaosTypeOf for $f {\n            #[inline]\n            fn taos_type_of() -> Ty {\n                Ty::$t\n            }\n        }\n    };\n}\n\nimpl_taos_type_of!(bool, Bool);\nimpl_taos_type_of!(i8, TinyInt);\nimpl_taos_type_of!(i16, SmallInt);\nimpl_taos_type_of!(i32, Int);\nimpl_taos_type_of!(i64, BigInt);\nimpl_taos_type_of!(u8, UTinyInt);\nimpl_taos_type_of!(u16, USmallInt);\nimpl_taos_type_of!(u32, UInt);\nimpl_taos_type_of!(u64, UBigInt);\nimpl_taos_type_of!(f32, Float);\nimpl_taos_type_of!(f64, Double);\n\nimpl<'a> MultiBind<'a> {\n    pub(crate) fn nulls(n: usize) -> Self {\n        Self(\n            TaosMultiBind {\n                buffer_type: Ty::Null as _,\n                buffer: std::ptr::null_mut(),\n                buffer_length: 0,\n                length: n as _,\n                is_null: std::ptr::null_mut(),\n                num: n as _,\n            },\n            PhantomData,\n        )\n    }\n    pub(crate) fn from_primitives<T: TaosTypeOf>(nulls: &BitVec, values: &[T]) -> Self {\n        Self(\n            TaosMultiBind {\n                buffer_type: T::taos_type_of() as _,\n                buffer: values.as_ptr() as _,\n                buffer_length: std::mem::size_of::<T>(),\n                length: values.len() as _,\n                is_null: ManuallyDrop::new(nulls.clone().into_bools()).as_ptr() as _,\n                num: values.len() as _,\n            },\n            PhantomData,\n        )\n    }\n    pub(crate) fn from_raw_timestamps(nulls: &BitVec, values: &[i64]) -> Self {\n        Self(\n            TaosMultiBind {\n                buffer_type: Ty::Timestamp as _,\n                buffer: values.as_ptr() as _,\n                buffer_length: std::mem::size_of::<i64>(),\n                length: values.len() as _,\n                is_null: ManuallyDrop::new(nulls.clone().into_bools()).as_ptr() as _,\n                num: values.len() as _,\n            },\n            PhantomData,\n        )\n    }\n\n    pub(crate) fn from_binary_vec(values: &[Option<impl AsRef<[u8]>>]) -> Self {\n        let mut buffer_length = 0;\n        let num = values.len();\n        let mut nulls = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { nulls.set_len(num) };\n        nulls.fill(false);\n        let mut length: ManuallyDrop<Vec<i32>> = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { length.set_len(num) };\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                length[i] = v.len() as _;\n                if v.len() > buffer_length {\n                    buffer_length = v.len();\n                }\n            } else {\n                nulls[i] = true;\n            }\n        }\n        let buffer_size = buffer_length * values.len();\n        let mut buffer: ManuallyDrop<Vec<u8>> = ManuallyDrop::new(Vec::with_capacity(buffer_size));\n        unsafe { buffer.set_len(buffer_size) };\n        buffer.fill(0);\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                unsafe {\n                    let dst = buffer.as_mut_ptr().add(buffer_length * i);\n                    std::intrinsics::copy_nonoverlapping(v.as_ptr(), dst, v.len());\n                }\n            }\n        }\n        Self(\n            TaosMultiBind {\n                buffer_type: Ty::VarChar as _,\n                buffer: buffer.as_ptr() as _,\n                buffer_length,\n                length: length.as_ptr() as _,\n                is_null: nulls.as_ptr() as _,\n                num: num as _,\n            },\n            PhantomData,\n        )\n    }\n    pub(crate) fn from_string_vec(values: &[Option<impl AsRef<str>>]) -> Self {\n        let values: Vec<_> = values\n            .iter()\n            .map(|f| {\n                f.as_ref()\n                    .map(|s| dbg!(s.as_ref().to_string()).into_bytes())\n            })\n            .collect();\n        let mut s = Self::from_binary_vec(&values);\n        s.0.buffer_type = Ty::NChar as _;\n        s\n    }\n}\n\nimpl<'a> Drop for MultiBind<'a> {\n    fn drop(&mut self) {\n        let ty = Ty::from(self.0.buffer_type as u8);\n        if ty == Ty::VarChar || ty == Ty::NChar {\n            let len = self.0.buffer_length * self.0.num as usize;\n            unsafe { Vec::from_raw_parts(self.0.buffer as *mut u8, len, len as _) };\n            unsafe {\n                Vec::from_raw_parts(self.0.length as *mut i32, self.0.num as _, self.0.num as _)\n            };\n        }\n        unsafe { Vec::from_raw_parts(self.0.is_null as *mut i8, self.0.num as _, self.0.num as _) };\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":74},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stream","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","timestamp.rs"],"content":"use serde::{Deserialize, Serialize};\nuse taos_sys::Precision;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]\npub enum TimestampValue {\n    Milliseconds(i64),\n    Microseconds(i64),\n    Nanoseconds(i64),\n}\n\nimpl TimestampValue {\n    pub fn new(raw: i64, precision: Precision) -> Self {\n        match precision {\n            Precision::Millisecond => TimestampValue::Milliseconds(raw),\n            Precision::Microsecond => TimestampValue::Microseconds(raw),\n            Precision::Nanosecond => TimestampValue::Nanoseconds(raw),\n        }\n    }\n    pub fn as_raw_i64(&self) -> &i64 {\n        match self {\n            TimestampValue::Milliseconds(raw)\n            | TimestampValue::Microseconds(raw)\n            | TimestampValue::Nanoseconds(raw) => raw,\n        }\n    }\n    pub fn to_naive_datetime(&self) -> chrono::NaiveDateTime {\n        let duration = match self {\n            TimestampValue::Milliseconds(raw) => chrono::Duration::milliseconds(*raw),\n            TimestampValue::Microseconds(raw) => chrono::Duration::microseconds(*raw),\n            TimestampValue::Nanoseconds(raw) => chrono::Duration::nanoseconds(*raw),\n        };\n        chrono::NaiveDateTime::from_timestamp(0, 0)\n            .checked_add_signed(duration)\n            .unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","tmq","conf.rs"],"content":"use crate::{IntoCStr, TaosOptions};\nuse taos_error::*;\n\nuse std::{ffi::c_void, iter::Iterator};\nuse taos_query::Dsn;\nuse taos_sys::*;\n\nuse super::Consumer;\n/* tmq conf */\npub struct TmqConf(*mut tmq_conf_t);\n\nimpl TmqConf {\n    pub(crate) fn as_ptr(&self) -> *mut tmq_conf_t {\n        self.0\n    }\n    pub(crate) fn new() -> Self {\n        Self(unsafe { tmq_conf_new() })\n    }\n\n    pub(crate) fn from_dsn(dsn: &Dsn) -> Result<Self> {\n        let mut conf = Self::new();\n        macro_rules! _set_opt {\n            ($f:ident, $c:literal) => {\n                if let Some($f) = &dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", $c), format!(\"{}\", $f))?;\n                }\n            };\n            ($f:ident) => {\n                if let Some($f) = &dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", stringify!($c)), format!(\"{}\", $f))?;\n                }\n            };\n        }\n\n        // todo: host port?\n        _set_opt!(username, \"user\");\n        _set_opt!(password, \"pass\");\n        _set_opt!(database, \"db\");\n        conf.with(dsn.params.iter().filter(|(k, _)| k.contains(\".\")))\n    }\n\n    pub fn from_opts(opts: &TaosOptions) -> Result<Self> {\n        let mut conf = Self::new();\n\n        macro_rules! _set_opt {\n            ($f:ident, $c:literal) => {\n                if let Some($f) = &opts.$f {\n                    conf.set(format!(\"td.connect.{}\", $c), format!(\"{}\", $f))?;\n                }\n            };\n            ($f:ident) => {\n                if let Some($f) = &opts.$f {\n                    conf.set(format!(\"td.connect.{}\", stringify!($c)), format!(\"{}\", $f))?;\n                }\n            };\n        }\n\n        _set_opt!(host, \"ip\");\n        _set_opt!(username, \"user\");\n        _set_opt!(password, \"pass\");\n        _set_opt!(port, \"port\");\n        _set_opt!(database, \"db\");\n\n        conf.with(opts.params.iter().filter(|(k, _)| k.contains(\".\")))\n    }\n\n    pub fn group_id(mut self, id: &str) -> Self {\n        self.set(\"group.id\", id)\n            .expect(\"set group.id should always be ok\");\n        self\n    }\n    pub fn client_id(mut self, id: &str) -> Self {\n        self.set(\"client.id\", id)\n            .expect(\"set group.id should always be ok\");\n        self\n    }\n\n    pub fn enable_auto_commit(mut self, enabled: bool) -> Self {\n        self.set(\"enable.auto.commit\", if enabled { \"true\" } else { \"false\" })\n            .expect(\"set group.id should always be ok\");\n        self\n    }\n\n    pub fn with<K: AsRef<str>, V: AsRef<str>>(\n        mut self,\n        iter: impl Iterator<Item = (K, V)>,\n    ) -> Result<Self> {\n        for (k, v) in iter {\n            self.set(k, v)?;\n        }\n        Ok(self)\n    }\n\n    pub fn set<K: AsRef<str>, V: AsRef<str>>(&mut self, key: K, value: V) -> Result<&mut Self> {\n        let ret = unsafe {\n            tmq_conf_set(\n                self.0,\n                key.as_ref().into_c_str().as_ptr(),\n                value.as_ref().into_c_str().as_ptr(),\n            )\n        };\n        match ret {\n            tmq_conf_res_t::Ok => Ok(self),\n            tmq_conf_res_t::Invalid => Err(Error::from_string(\"invalid key value set for tmq\")),\n            tmq_conf_res_t::Unknown => Err(Error::from_string(\"unknown key for tmq conf\")),\n        }\n    }\n\n    pub fn set_auto_commit_cb(&mut self, cb: tmq_commit_cb, param: *mut c_void) -> () {\n        unsafe {\n            tmq_conf_set_auto_commit_cb(self.0, cb, param);\n        }\n    }\n\n    pub fn consumer(&self) -> Result<Consumer> {\n        unsafe {\n            let mut err = [0; 256];\n            let tmq = tmq_consumer_new(self.0, err.as_mut_ptr() as _, 255);\n            if err[0] != 0 {\n                Err(Error::from_string(\n                    String::from_utf8_lossy(&err).to_string(),\n                ))\n            } else {\n                Ok(Consumer::new(tmq, 0))\n            }\n        }\n    }\n}\n\nimpl Drop for TmqConf {\n    fn drop(&mut self) {\n        log::trace!(\"tmq config destroy\");\n        unsafe { tmq_conf_destroy(self.0) };\n        log::trace!(\"tmq config destroyed safely\");\n    }\n}\n","traces":[{"line":13,"address":[3962992],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":14,"address":[3962997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[3963008],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":17,"address":[3963012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3963749,3963056,3965607],"length":1,"stats":{"Line":0},"fn_name":"from_dsn"},{"line":21,"address":[3963092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3963159,3963760,3963333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3963239,3963983,3964082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[3964705,3964024,3964817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[3965585,3964746,3965457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3965648,3966394,3969712],"length":1,"stats":{"Line":0},"fn_name":"from_opts"},{"line":43,"address":[3965687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3966405,3965773,3965966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3966743,3966631,3965863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3967460,3966681,3967369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3967413,3968184,3968083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3968922,3968807,3968131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3944944,3944958],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":67,"address":[3969889,3969760],"length":1,"stats":{"Line":0},"fn_name":"group_id"},{"line":68,"address":[3969784,3969845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[3969880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[3969920,3970049],"length":1,"stats":{"Line":0},"fn_name":"client_id"},{"line":73,"address":[3969944,3970005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[3970040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[3970080,3970269],"length":1,"stats":{"Line":0},"fn_name":"enable_auto_commit"},{"line":79,"address":[3970101,3970224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[3970259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3946319,3945040,3945696,3945663],"length":1,"stats":{"Line":0},"fn_name":"with<&alloc::string::String, &alloc::string::String, core::iter::adapters::filter::Filter<alloc::collections::btree::map::Iter<alloc::string::String, alloc::string::String>, taos::tmq::conf::{impl#0}::from_dsn::{closure_env#0}>>"},{"line":88,"address":[3945062,3945718,3946270,3946022,3945836,3945614,3945180,3945455,3946111,3945366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[3945465,3945342,3945393,3945998,3946121,3946049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3945645,3946301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[3948267,3947057,3947088,3947777,3947538,3946352,3946818,3948567,3947808],"length":1,"stats":{"Line":0},"fn_name":"set<&str, &str>"},{"line":97,"address":[3947856,3947134,3946414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3947313,3946593,3947214,3946494,3946422,3947947,3948046,3947142,3947867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[3946605,3948063,3946746,3947325,3947466,3948192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3947568,3948297,3946848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[3946958,3947678,3948407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3946976,3947637,3947696,3948366,3948439,3946917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[3948335,3946886,3947017,3947606,3948480,3947737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[3970304],"length":1,"stats":{"Line":0},"fn_name":"set_auto_commit_cb"},{"line":111,"address":[3970322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3970658,3970336],"length":1,"stats":{"Line":0},"fn_name":"consumer"},{"line":117,"address":[3970366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[3970388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3970451,3970727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3970576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3970488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3970712,3970463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[3723584],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":132,"address":[3723604,3723695,3723752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3723741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[3723924,3723830,3723985],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":52},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","tmq","consumer.rs"],"content":"use std::{intrinsics::transmute, task::Poll};\n\nuse crate::prelude::ResultSet;\nuse futures::{FutureExt, Stream};\nuse taos_error::*;\nuse taos_sys::*;\n\nuse super::TmqList;\n\n#[derive(Debug)]\npub struct ConsumerRef(*mut tmq_t);\n\nimpl ConsumerRef {\n    pub(crate) fn from_ptr(ptr: *mut tmq_t) -> Self {\n        ConsumerRef(ptr)\n    }\n    pub fn commit(&self, offsets: &ResultSet) -> Result<()> {\n        unsafe { tmq_commit_sync(self.0, offsets.as_ptr()) }.ok_or(\"commit failed\")\n    }\n}\n\n#[derive(Debug)]\npub struct Consumer {\n    ptr: *mut tmq_t,\n    wait: i64,\n}\n\nimpl Unpin for Consumer {}\n\nunsafe impl Send for Consumer {}\nunsafe impl Sync for Consumer {}\n\nimpl Consumer {\n    pub(crate) fn as_raw(&self) -> *mut tmq_t {\n        self.ptr\n    }\n    pub(crate) fn new(ptr: *mut tmq_t, wait: i64) -> Self {\n        Self { ptr, wait }\n    }\n\n    pub(crate) fn subscribe(&mut self, topic_list: &TmqList) -> Result<()> {\n        unsafe { tmq_subscribe(self.as_raw(), topic_list.0) }.ok_or(\"subscribe failed\")\n    }\n\n    pub fn subscription(&self) -> Result<Vec<String>> {\n        let tl = TmqList::new();\n\n        unsafe { tmq_subscription(self.as_raw(), &mut tl.as_ptr()) }\n            .ok_or(\"get topic list failed\")\n            .map(|_| {\n                tl.to_str_vec()\n                    .into_iter()\n                    .map(ToString::to_string)\n                    .collect()\n            })\n    }\n\n    pub fn commit_sync(&mut self, msg: &ResultSet) -> Result<()> {\n        unsafe { tmq_commit_sync(self.as_raw(), msg.as_ptr() as _) }.ok_or(\"commit failed\")\n    }\n\n    pub fn commit_non_blocking(&mut self, msg: &ResultSet, callback: fn(ConsumerRef, Result<()>)) {\n        unsafe {\n            tmq_commit_async(\n                self.as_raw(),\n                msg.as_ptr(),\n                super::tmq_commit_callback,\n                Box::into_raw(Box::new(callback)) as _,\n            )\n        }\n    }\n\n    pub async fn commit(&mut self, msg: &ResultSet) -> Result<()> {\n        use tokio::sync::oneshot::{channel, Sender};\n        let (sender, rx) = channel::<Result<()>>();\n        unsafe extern \"C\" fn tmq_commit_async_cb(\n            _tmq: *mut tmq_t,\n            resp: tmq_resp_err_t,\n            param: *mut std::os::raw::c_void,\n        ) {\n            let offsets = resp.ok_or(\"commit failed\").map(|_| ());\n            let sender = param as *mut Sender<_>;\n            let sender = Box::from_raw(sender);\n            sender.send(offsets).unwrap();\n        }\n\n        unsafe {\n            tmq_commit_async(\n                self.as_raw(),\n                msg.as_ptr(),\n                tmq_commit_async_cb,\n                Box::into_raw(Box::new(sender)) as *mut _,\n            )\n        }\n        Ok(rx.await.unwrap()?)\n    }\n\n    pub fn poll(&mut self) -> Option<crate::Result<ResultSet>> {\n        let res = unsafe { tmq_consumer_poll(self.as_raw(), self.wait) };\n        if res.is_null() {\n            None\n        } else {\n            Some(\n                ResultSet::from_ptr(res)\n                    .map(|rs| rs.independent())\n                    .map_err(Into::into),\n            )\n        }\n    }\n\n    pub fn async_poll(\n        &mut self,\n        cx: &mut std::task::Context<'_>,\n    ) -> Poll<Option<crate::Result<ResultSet>>> {\n        struct TmqRef(*mut tmq_t);\n        unsafe impl Send for TmqRef {}\n        unsafe impl Sync for TmqRef {}\n        let wait = self.wait;\n        let ptr = TmqRef(self.as_raw());\n        tokio::task::spawn_blocking(move || {\n            let ptr = unsafe { transmute(ptr) };\n            let res = unsafe { tmq_consumer_poll(ptr, wait) };\n            if res.is_null() {\n                None\n            } else {\n                Some(\n                    ResultSet::from_ptr(res)\n                        .map(|rs| rs.independent())\n                        .map_err(Into::into),\n                )\n            }\n        })\n        .poll_unpin(cx)\n        .map(|res| res.unwrap())\n    }\n\n    pub async fn async_poll2(&mut self) -> Option<crate::Result<ResultSet>> {\n        struct TmqRef(*mut tmq_t);\n        unsafe impl Send for TmqRef {}\n        unsafe impl Sync for TmqRef {}\n        let wait = self.wait;\n        let ptr = TmqRef(self.as_raw());\n        tokio::task::spawn_blocking(move || {\n            let ptr = unsafe { transmute(ptr) };\n            let res = unsafe { tmq_consumer_poll(ptr, wait) };\n            if res.is_null() {\n                None\n            } else {\n                Some(\n                    ResultSet::from_ptr(res)\n                        .map(|rs| rs.independent())\n                        .map_err(Into::into),\n                )\n            }\n        })\n        .await\n        .unwrap_or(None)\n    }\n\n    pub fn poll_wait(&mut self, wait_time: i64) -> Option<crate::Result<ResultSet>> {\n        let res = unsafe { tmq_consumer_poll(self.as_raw(), wait_time) };\n        if res.is_null() {\n            None\n        } else {\n            Some(ResultSet::from_ptr(res).map_err(Into::into))\n        }\n    }\n\n    pub fn unsubscribe(&mut self) {\n        unsafe {\n            log::trace!(\"close consumer\");\n            tmq_consumer_close(self.as_raw());\n            log::trace!(\"consumer closed safely\");\n        }\n    }\n}\n\nimpl Iterator for Consumer {\n    type Item = Result<ResultSet>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        todo!()\n    }\n}\n\nimpl Drop for Consumer {\n    fn drop(&mut self) {\n        unsafe {\n            log::trace!(\"close consumer\");\n            tmq_consumer_close(self.as_raw());\n            log::trace!(\"consumer closed safely\");\n        }\n    }\n}\n\nimpl Stream for Consumer {\n    type Item = crate::Result<ResultSet>;\n\n    fn poll_next(\n        mut self: std::pin::Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> std::task::Poll<Option<Self::Item>> {\n        // self.async_poll2().boxed().poll_unpin(cx)\n        Poll::Ready(self.poll())\n    }\n}\n","traces":[{"line":14,"address":[3890976],"length":1,"stats":{"Line":0},"fn_name":"from_ptr"},{"line":15,"address":[3890985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[3891008],"length":1,"stats":{"Line":0},"fn_name":"commit"},{"line":18,"address":[3891045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3891136],"length":1,"stats":{"Line":0},"fn_name":"as_raw"},{"line":35,"address":[3891141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3891152],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":41,"address":[3891200],"length":1,"stats":{"Line":0},"fn_name":"subscribe"},{"line":42,"address":[3891242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3891558,3891328],"length":1,"stats":{"Line":0},"fn_name":"subscription"},{"line":46,"address":[3891355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[3891430,3891371,3891524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[3891519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[3423314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3891600],"length":1,"stats":{"Line":0},"fn_name":"commit_sync"},{"line":59,"address":[3891642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3891728],"length":1,"stats":{"Line":0},"fn_name":"commit_non_blocking"},{"line":65,"address":[3891757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3891773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3891866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[3891920,3891941],"length":1,"stats":{"Line":0},"fn_name":"commit"},{"line":76,"address":[3892308,3891984],"length":1,"stats":{"Line":0},"fn_name":"tmq_commit_async_cb"},{"line":81,"address":[3423392],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":82,"address":[3892079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3892087,3892149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3892157,3892272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3892368],"length":1,"stats":{"Line":0},"fn_name":"poll"},{"line":99,"address":[3892406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[3892455,3892582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[3892501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3892521,3892480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[3423419,3423408],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":111,"address":[3892592,3892849],"length":1,"stats":{"Line":0},"fn_name":"async_poll"},{"line":118,"address":[3892642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3892659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3423472],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":121,"address":[3423510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[3423549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[3423700,3423573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3423619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3423685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[3423639,3423598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3423712,3423723],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":134,"address":[3423776,3423792],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":137,"address":[3892912,3892896],"length":1,"stats":{"Line":0},"fn_name":"async_poll2"},{"line":160,"address":[3892944],"length":1,"stats":{"Line":0},"fn_name":"poll_wait"},{"line":161,"address":[3892995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3893145,3893040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[3893086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[3893106,3893065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[3893152],"length":1,"stats":{"Line":0},"fn_name":"unsubscribe"},{"line":171,"address":[3893322,3893172,3893263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[3893309,3893408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3893514,3893578,3893414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3893680],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":187,"address":[3724080],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":189,"address":[3724191,3724100,3724250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[3724336,3724237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[3724342,3724506,3724442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[3893728],"length":1,"stats":{"Line":0},"fn_name":"poll_next"},{"line":204,"address":[3893758],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":61},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","tmq","mod.rs"],"content":"use std::{\n    ffi::{c_void, CStr},\n    fmt::Debug,\n    mem::ManuallyDrop,\n    slice,\n    sync::{Arc, Weak},\n};\n\nuse taos_error::*;\n\nuse crate::{IntoCStr, Taos};\nuse mdsn::IntoDsn;\nuse taos_query::Dsn;\nuse taos_sys::*;\n\nunsafe extern \"C\" fn tmq_commit_callback(\n    _tmq: *mut tmq_t,\n    resp: tmq_resp_err_t,\n    param: *mut c_void,\n) {\n    log::info!(\"commit {resp:?}\");\n    let cons = ConsumerRef::from_ptr(_tmq);\n    let cb: &Weak<fn(ConsumerRef, Result<()>)> = std::mem::transmute(param);\n    (*cb.as_ptr())(cons, resp.ok_or(\"commit failed\"));\n}\n\n#[derive(Debug)]\npub struct TmqList(*mut tmq_list_t);\n\nimpl TmqList {\n    fn new() -> Self {\n        Self(unsafe { tmq_list_new() })\n    }\n    fn as_ptr(&self) -> *mut tmq_list_t {\n        self.0\n    }\n    fn append<'a>(&mut self, c_str: impl IntoCStr<'a>) -> Result<()> {\n        let ret = unsafe { tmq_list_append(self.0, c_str.into_c_str().as_ptr()) };\n        if ret == 0 {\n            Ok(())\n        } else {\n            Err(Error::new(Code::Failed, \"append tmq list error\"))\n        }\n    }\n\n    fn from_topics<'a, T: IntoCStr<'a>>(topics: impl IntoIterator<Item = T>) -> Result<Self> {\n        let mut list = Self::new();\n        for topic in topics {\n            list.append(topic)?;\n        }\n        Ok(list)\n    }\n\n    pub fn iter(&self) -> std::vec::IntoIter<&str> {\n        self.to_str_vec().into_iter()\n    }\n\n    pub fn to_str_vec(&self) -> Vec<&str> {\n        unsafe {\n            let ptr = self.as_ptr();\n            let len = tmq_list_get_size(ptr);\n            if len == 0 {\n                return vec![];\n            }\n            let arr = tmq_list_to_c_array(ptr);\n            slice::from_raw_parts(arr, len as usize)\n                .into_iter()\n                .map(|ptr| {\n                    CStr::from_ptr(*ptr)\n                        .to_str()\n                        .expect(\"topic should always be utf-8 valid\")\n                })\n                .collect()\n        }\n    }\n}\n\nimpl<'a> IntoIterator for &'a TmqList {\n    type Item = &'a str;\n\n    type IntoIter = std::vec::IntoIter<&'a str>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n\n// todo: tmq_list_destroy cause double free error.\nimpl Drop for TmqList {\n    fn drop(&mut self) {\n        unsafe {\n            log::trace!(\"list destroy\");\n            tmq_list_destroy(self.0);\n            log::trace!(\"list destroy destroyed\");\n        }\n    }\n}\n\nmod conf;\npub use conf::*;\n\nmod consumer;\npub use consumer::Consumer;\n\nuse self::consumer::ConsumerRef;\n\npub struct TmqBuilder {\n    conf: TmqConf,\n    wait: i64,\n    topics: TmqList,\n    on_commit: Option<Arc<fn(ConsumerRef, Result<()>)>>,\n}\n\nimpl TmqBuilder {\n    pub fn from_dsn<T: IntoDsn>(dsn: T) -> crate::Result<Self> {\n        let dsn = dsn.into_dsn().unwrap();\n        log::debug!(\"build from {dsn}\");\n        let mut conf = TmqConf::new();\n        macro_rules! _set_opt {\n            ($f:ident, $c:literal) => {\n                if let Some($f) = &dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", $c), format!(\"{}\", $f))?;\n                }\n            };\n            ($f:ident) => {\n                if let Some($f) = &dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", stringify!($c)), format!(\"{}\", $f))?;\n                }\n            };\n        }\n\n        // todo: host port?\n        _set_opt!(username, \"user\");\n        _set_opt!(password, \"pass\");\n        _set_opt!(database, \"db\");\n\n        if let Some(addr) = dsn.addresses.first() {\n            if let Some(host) = addr.host.as_ref() {\n                conf.set(\"td.connect.ip\", host)?;\n            }\n            if let Some(port) = addr.port.as_ref() {\n                conf.set(\"td.connect.port\", format!(\"{}\", port))?;\n            }\n        }\n        conf.set(\"msg.with.table.name\", \"true\")?;\n\n        // let tmq_params = dsn.params.iter_mut().filter(|(k, _)| k.contains(\".\")).collect();\n        let mut conf = conf.with(dsn.params.iter().filter(|(k, _)| k.contains(\".\")))?;\n        // conf.set(\"msg.with.table.name\".to_string(), \"true\".to_string()).unwrap();\n\n        let wait = dsn\n            .params\n            .get(\"wait\")\n            .and_then(|s| s.parse().ok())\n            .unwrap_or(100);\n        log::debug!(\"with wait time {wait}ms\");\n        let mut topics = TmqList::new();\n        if let Some(t) = dsn.params.get(\"topics\") {\n            for s in t.split(\",\") {\n                topics.append(s)?;\n            }\n        }\n        Ok(Self {\n            conf,\n            wait,\n            topics,\n            on_commit: None,\n        })\n    }\n\n    pub fn on_auto_commit(&mut self, callback: fn(ConsumerRef, Result<()>)) -> &mut Self {\n        let on_commit = Arc::new(callback);\n        let cb = Arc::downgrade(&on_commit);\n        self.on_commit = Some(on_commit);\n        // todo: callback pointer should be freed in Drop.\n        self.conf\n            .set_auto_commit_cb(tmq_commit_callback, Box::into_raw(Box::new(cb)) as _);\n        self\n    }\n\n    pub fn build(&self) -> crate::Result<Consumer> {\n        unsafe {\n            let mut err = [0; 256];\n            let tmq = tmq_consumer_new(self.conf.as_ptr(), err.as_mut_ptr() as _, 255);\n            if err[0] != 0 {\n                return Err(crate::Error::custom(\n                    String::from_utf8_lossy(&err).to_string(),\n                ));\n            } else {\n                let mut cons = Consumer::new(tmq, self.wait);\n                cons.subscribe(&self.topics)?;\n                Ok(cons)\n            }\n        }\n    }\n\n    pub fn subscribe<'a, T: IntoCStr<'a>>(\n        &self,\n        topics: impl IntoIterator<Item = T>,\n    ) -> crate::Result<Consumer> {\n        unsafe {\n            let mut err = [0; 256];\n            let tmq = tmq_consumer_new(self.conf.as_ptr(), err.as_mut_ptr() as _, 255);\n            if err[0] != 0 {\n                return Err(crate::Error::custom(\n                    String::from_utf8_lossy(&err).to_string(),\n                ));\n            } else {\n                let mut cons = Consumer::new(tmq, self.wait);\n                let topics = TmqList::from_topics(topics)?;\n                cons.subscribe(&topics)?;\n                Ok(cons)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use std::sync::atomic;\n    use std::sync::Arc;\n    use std::thread;\n    use std::time::Duration;\n\n    use crate::prelude::sync::*;\n    use crate::tmq::*;\n\n    use anyhow::Result;\n\n    #[crate::test(log_level = \"debug\")]\n    fn independent_blocks(taos: &Taos, database: &str) -> Result<()> {\n        taos.exec(\"create table tb1 (ts timestamp, v1 int)\")?;\n        taos.exec(\"create table tb2 (ts timestamp, v2 int)\")?;\n        taos.exec(\"create table tb3 (ts timestamp, v3 int)\")?;\n        taos.exec(\"create table tb4 (ts timestamp, v4 int)\")?;\n        taos.exec(\"create table tb5 (ts timestamp, v5 int)\")?;\n        taos.exec(concat!(\n            \"insert into tb1 values(now, 1) \",\n            \"tb2 values(now, 2) \",\n            \"tb3 values(now, 3)\",\n            \"tb4 values(now, 4)\",\n            \"tb5 values(now, 5)\",\n        ))?;\n        taos.exec(format!(\"create topic {database} as {database}\"))?;\n\n        let builder = TmqBuilder::from_dsn(format!(\n            \"taos:///{database}?topics={database}&group.id={database}&wait=1000\"\n        ))?;\n        let mut tmq = builder.build()?;\n        while let Some(Ok(mut rs)) = tmq.poll() {\n            for block in rs.blocks_iter() {\n                let fields = block.fields();\n                let tbname = block.tmq_table_name().unwrap();\n                log::info!(\"block table name: {tbname}\");\n                assert!(fields.len() == 2);\n                dbg!(fields);\n                for row in block.deserialize::<(String, i32)>() {\n                    let row = row?;\n                    dbg!(row);\n                }\n            }\n            let (blocks, records) = rs.summary();\n            log::info!(\"fetch {blocks} blocks, with {records} records\");\n        }\n        Ok(())\n    }\n\n    fn drop_topic(taos: &Taos, topic: &str) -> Result<()> {\n        taos.exec(format!(\"drop topic if exists {topic}\"))?;\n        Ok(())\n    }\n\n    fn _build_consumer(taos: &Taos) -> Result<Consumer> {\n        println!(\"consumer config\");\n        let mut conf = TmqConf::new();\n        conf.set(\"group.id\", \"tg2\")?;\n        unsafe extern \"C\" fn tmq_commit_callback(\n            _tmq: *mut tmq_t,\n            resp: tmq_resp_err_t,\n            param: *mut c_void,\n        ) {\n            log::info!(\"commit {resp:?}\");\n        }\n        conf.set_auto_commit_cb(tmq_commit_callback, std::ptr::null_mut());\n        println!(\"build consumer\");\n        Ok(conf.consumer()?)\n    }\n\n    fn process_message(msg: &mut ResultSet) {\n        let rows = msg.to_rows_vec();\n\n        for row in rows {\n            println!(\"{row:?}\");\n        }\n    }\n\n    fn insert(database: &str, max_inserts: usize) -> Result<()> {\n        println!(\"connect taos in a spawned thread\");\n        let taos = Taos::new((), \"root\", \"taosdata\", database, 0)?;\n        println!(\"start to insert 10 rows\");\n        for i in 0..max_inserts {\n            use crate::prelude::sync::*;\n            taos.exec(&format!(\"insert into tu1 values (now, {i})\"))?;\n            println!(\"- {i} rows inserted\");\n        }\n        drop(taos);\n        println!(\"write data thread finish\");\n        Ok(())\n    }\n    fn sync_consume_loop(database: &str, consumer: &mut Consumer) -> Result<()> {\n        println!(\"consume loop\");\n        let running = Arc::new(atomic::AtomicBool::new(true));\n        let msg_count = atomic::AtomicUsize::new(0);\n        let running2 = running.clone();\n\n        let database = database.to_string();\n        thread::spawn(move || match insert(&database, 10) {\n            Ok(_) => {\n                running2.store(false, atomic::Ordering::SeqCst);\n            }\n            Err(err) => {\n                running2.store(false, atomic::Ordering::SeqCst);\n                eprintln!(\"{}\", err.to_string());\n            }\n        });\n\n        println!(\"inserting thread spawned.\");\n        while running.load(atomic::Ordering::SeqCst)\n            || msg_count.load(atomic::Ordering::SeqCst) < 10\n        {\n            println!(\"looping...\");\n            if let Some(Ok(mut msg)) = consumer.poll_wait(1000) {\n                println!(\"msg: {}\", msg_count.load(atomic::Ordering::SeqCst));\n                process_message(&mut msg);\n                msg_count.fetch_add(1, atomic::Ordering::SeqCst);\n\n                consumer.commit_sync(&msg)?;\n                println!(\"msg summary: {:?}\", msg.summary());\n            }\n        }\n        println!(\"loop done\");\n        Ok(())\n    }\n\n    // todo: drop after consume will cause segmentation fault, use specific db name and no dropping.\n    // #[crate::test(log_level = \"trace\", naming = \"tmq_consume_test\", dropping = \"none\")]\n    #[crate::test(log_level = \"trace\")]\n    fn tmq_consume(taos: &Taos, database: &str) -> Result<()> {\n        let version = crate::client_info();\n        println!(\"version: {}\", version);\n        if !version.starts_with(\"3\") {\n            return Ok(());\n        }\n        println!(\"connected\");\n        taos.exec_many([\n            \"create stable if not exists st1 (ts timestamp, k int) tags(a int)\",\n            \"create table if not exists tu1 using st1 tags(1)\",\n            \"create table if not exists tu2 using st1 tags(2)\",\n        ])?;\n        taos.create_topic_as_database(database, database)?;\n\n        let topic = database;\n        let gid = database;\n\n        let dsn = format!(\"taos:///{database}?topics={topic}&group.id={gid}&wait=1000\");\n        log::info!(\"subscribe with dsn: {dsn}\");\n        let mut consumer = TmqBuilder::from_dsn(&dsn)?\n            .on_auto_commit(\n                |_: ConsumerRef, _: std::result::Result<(), taos_error::Error>| {\n                    log::info!(\"rust callback\");\n                },\n            )\n            .build()?;\n        println!(\"topics created\");\n        sync_consume_loop(database, &mut consumer)?;\n        dbg!(consumer.subscription()?);\n        std::mem::drop(consumer);\n        drop_topic(&taos, &topic)?;\n        println!(\"finished\");\n        Ok(())\n    }\n\n    /// Consume from one database and write to another.\n    // #[crate::test(log_level = \"trace\")]\n    #[crate::test(log_level = \"trace\", naming = \"tmq1\")]\n    async fn tmq_stream(taos: &Taos, database: &str) -> Result<()> {\n        let version = crate::client_info();\n        println!(\"version: {}\", version);\n        if !version.starts_with(\"3\") {\n            return Ok(());\n        }\n        println!(\"connected\");\n        taos.exec_many([\n            \"create stable if not exists st1 (ts timestamp, k int) tags(a int)\",\n            \"create table if not exists tu1 using st1 tags(1)\",\n            \"create table if not exists tu2 using st1 tags(2)\",\n        ])?;\n        taos.create_topic_as_database(database, database)?;\n\n        let topic = database;\n        let gid = database;\n\n        let dsn = format!(\n            \"taos:///{database}?topics={topic}&group.id={gid}&wait=2000&msg.with.table.name=true\"\n        );\n        log::info!(\"subscribe with dsn: {dsn}\");\n        let consumer = TmqBuilder::from_dsn(&dsn)?\n            .on_auto_commit(\n                |_: ConsumerRef, _: std::result::Result<(), taos_error::Error>| {\n                    log::info!(\"rust callback\");\n                },\n            )\n            .build()?;\n        println!(\"topics created\");\n\n        const MAX_INSERTS: usize = 10;\n        let database = database.to_string();\n        thread::spawn(move || insert(&database, MAX_INSERTS));\n\n        taos.exec_many([\n            \"create database if not exists db2\",\n            \"create stable if not exists db2.st1 (ts timestamp, k int) tags(a int)\",\n            \"create table if not exists db2.tu1 using db2.st1 tags(1)\",\n            \"create table if not exists db2.tu2 using db2.st1 tags(2)\",\n        ])?;\n        let unfold = futures::sink::unfold(0, |mut sum, mut rs: ResultSet| async move {\n            for block in rs.blocks_iter() {\n                let bind: Vec<TaosMultiBind> = block.columns_iter().map(|col| col.into()).collect();\n                let table = block.tmq_table_name().unwrap();\n                let mut stmt = taos.stmt(format!(\"insert into db2.{table} values(?,?)\"))?;\n                stmt.multi_bind(&bind)?;\n                stmt.execute()?;\n                let inserted = stmt.affected_rows();\n                log::info!(\"inserted {inserted} rows\");\n            }\n            let (blocks, rows) = rs.summary();\n            assert!(blocks == 1, \"tmq response blocks always should be 1\");\n            sum += rows;\n            eprintln!(\"sum: {sum}, rows in block = {rows}\");\n            Ok::<_, crate::Error>(sum)\n        });\n        futures::pin_mut!(unfold);\n        use futures::prelude::*;\n        consumer.forward(unfold).await?;\n\n        let db2_rows: usize = taos.query_one(\"select count(*) from db2.tu1\")?.unwrap_or(0);\n        drop_topic(&taos, &topic)?;\n        taos.exec(\"drop database db2\")?;\n        if db2_rows != MAX_INSERTS {\n            anyhow::bail!(\"inserted rows not match\");\n        }\n        println!(\"finished\");\n        Ok(())\n    }\n}\n","traces":[{"line":16,"address":[3683488],"length":1,"stats":{"Line":0},"fn_name":"tmq_commit_callback"},{"line":21,"address":[3683616,3683525,3683685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[3683662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[3683827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[3683861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3683952],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":32,"address":[3683956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3684000],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":35,"address":[3684005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3684016],"length":1,"stats":{"Line":0},"fn_name":"iter"},{"line":55,"address":[3684035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3684080],"length":1,"stats":{"Line":0},"fn_name":"to_str_vec"},{"line":60,"address":[3684115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3684135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3684153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3684163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[3684176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3684204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3602736],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":69,"address":[3602750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3684320],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":84,"address":[3684337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[3723088],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":92,"address":[3723108,3723199,3723256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[3723245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[3723489,3723428,3723334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[3684883,3684368],"length":1,"stats":{"Line":0},"fn_name":"on_auto_commit"},{"line":172,"address":[3684413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3684429,3684498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[3684508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[3684823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[3684598,3684797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[3684403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3685267,3684928],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":183,"address":[3684958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[3684980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[3685046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[3685185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[3685097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[3685063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[3685311,3685482,3685383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[3685441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":95},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","util","mod.rs"],"content":"pub use taos_sys::into_c_str::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","tests","de.rs"],"content":"#![allow(dead_code)]\nuse chrono::NaiveDateTime;\nuse futures::StreamExt;\nuse futures::TryStreamExt;\nuse std::ffi::CString;\n\nuse taos::helpers::ShowDatabase;\n\nuse taos::prelude::*;\n\npub use taos::helpers;\n#[derive(serde::Deserialize, Debug)]\nstruct JsonTag {\n    name: String,\n}\n\n#[derive(serde::Deserialize, Debug)]\nstruct Record {\n    ts: NaiveDateTime,\n    i8: i8,\n    i16: i16,\n    i32: i32,\n    i64: i64,\n    u8: u8,\n    u16: u16,\n    u32: u32,\n    u64: u64,\n    raw_ts: i64,\n    c_str: CString,\n    str: String,\n    json_tag: serde_json::Value,\n}\n#[derive(serde::Deserialize, Debug)]\nstruct RecordOption {\n    ts: Option<NaiveDateTime>,\n    i8: Option<i8>,\n    i16: Option<i16>,\n    i32: Option<i32>,\n    i64: Option<i64>,\n    u8: Option<u8>,\n    u16: Option<u16>,\n    u32: Option<u32>,\n    u64: Option<u64>,\n    raw_ts: Option<i64>,\n    c_str: Option<CString>,\n    str: Option<String>,\n    json_tag: Option<serde_json::Value>,\n}\n#[derive(serde::Deserialize, Debug)]\nstruct RecordOptionWithJsonTag {\n    ts: Option<NaiveDateTime>,\n    i8: Option<i8>,\n    i16: Option<i16>,\n    i32: Option<i32>,\n    i64: Option<i64>,\n    u8: Option<u8>,\n    u16: Option<u16>,\n    u32: Option<u32>,\n    u64: Option<u64>,\n    raw_ts: Option<i64>,\n    c_str: Option<CString>,\n    str: Option<String>,\n    json_tag: Option<JsonTag>,\n}\n\n#[cfg(any(feature = \"test\", test))]\n#[taos::test(log_level = \"trace\")]\nasync fn de_seq_value(taos: &Taos, _database: &str) -> anyhow::Result<()> {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (gid int, location nchar(16))\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags(1, 'beijing') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"世界\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags(2, 'shanghai') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"世界\")\"#\n    ))?;\n\n    log::info!(\"select\");\n    let mut res = taos.query(\"select tbname,gid,location from stb1\").await?;\n    use futures::StreamExt;\n\n    use futures::future;\n    res.deserialize_stream::<Vec<Value>>()\n        .enumerate()\n        .for_each(|(_, v)| {\n            let value = v.unwrap();\n            log::debug!(\"{:?}\", value);\n            future::ready(())\n        })\n        .await;\n\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_seq_value2(taos: &Taos, _database: &str) -> anyhow::Result<()> {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (groupid int, location nchar(16))\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags(1, 'beijing') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"世界\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags(2, 'shanghai') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"世界\")\"#\n    ))?;\n\n    log::info!(\"select\");\n    let mut res = taos\n        .query(\"select tbname,groupid,location from stb1\")\n        .await?;\n    use futures::StreamExt;\n\n    // block.rows_iter()\n    // let mut stream = res.deserialize_stream();\n    use futures::future;\n    res.deserialize_stream::<Vec<Value>>()\n        .enumerate()\n        .for_each(|(_, v)| {\n            let value = v.unwrap();\n            log::debug!(\"{:?}\", value);\n            future::ready(())\n        })\n        .await;\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_all(taos: &Taos, _database: &str) -> anyhow::Result<()> {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (json_tag json)\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags('{\"name\":\"abc\"}') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"世界\")\"#\n    ))?;\n\n    log::info!(\"select\");\n    let mut res = taos.query(\"select * from stb1\").await?;\n    use futures::StreamExt;\n\n    // block.rows_iter()\n    let record: Record = res.deserialize_stream().next().await.unwrap()?;\n    log::debug!(\"fetched record {:?}\", record);\n    Ok(())\n}\n\n#[taos::test(log_level = \"trace\", dropping = \"none\")]\nasync fn de_all_option(taos: &Taos, _database: &str) -> anyhow::Result<()> {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (json_tag json)\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags('{\"name\":\"abc\"}') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"世界\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags('{\"name\":\"涛思数据\"}') \"#,\n        r#\"values (now,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\"#\n    ))?;\n    log::info!(\"select\");\n    let mut res = taos.query(\"select * from stb1\").await?;\n    // block.rows_iter()\n    let record: Vec<RecordOption> = res.deserialize_stream().try_collect().await?;\n    log::debug!(\"fetched record {:?}\", record);\n    Ok(())\n}\n\n#[taos::test(log_level = \"trace\")]\nasync fn de_all_option_with_json_tag_struct(taos: &Taos, _database: &str) -> anyhow::Result<()> {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (json_tag json)\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags('{\"name\":\"abc\"}') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"世界\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags('{\"name\":\"涛思数据\"}') \"#,\n        r#\"values (now,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\"#\n    ))?;\n    log::info!(\"select\");\n    let mut res = taos.query(\"select * from stb1\").await?;\n    // block.rows_iter()\n    let record: Vec<RecordOptionWithJsonTag> = res.deserialize_stream().try_collect().await?;\n    log::debug!(\"fetched records {:#?}\", record);\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_string(taos: &Taos) -> anyhow::Result<()> {\n    let mut res = taos.query(\"select server_version() as version\").await?;\n    use futures::StreamExt;\n\n    let version: String = res\n        .deserialize_stream()\n        .next()\n        .await\n        .expect(\"select version\")?;\n    println!(\"version: {version}\");\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_wrapper_struct(taos: &Taos) -> anyhow::Result<()> {\n    let mut res = taos.query(\"select server_version() as version\").await?;\n    use futures::StreamExt;\n\n    #[derive(::serde::Deserialize, Debug)]\n    struct Version(String);\n    let version: Version = res\n        .deserialize_stream()\n        .next()\n        .await\n        .expect(\"select version\")?;\n    println!(\"version: {:?}\", version);\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_named_struct(taos: &Taos) -> anyhow::Result<()> {\n    macro_rules! de {\n        ($taos:expr, $sql:expr) => {\n            $taos\n                .query($sql)\n                .await?\n                .deserialize_stream()\n                .next()\n                .await\n                .unwrap()?\n        };\n    }\n    #[derive(::serde::Deserialize, Debug)]\n    struct Version {\n        version: String,\n    }\n    #[derive(::serde::Deserialize, Debug)]\n    struct WrapperVersion(String);\n    #[derive(::serde::Deserialize, Debug)]\n    struct WrapperOptionVersion(Option<String>);\n\n    // value\n    let _version: String = de!(taos, \"select server_version()\");\n    // tuple\n    let _version: (String,) = de!(taos, \"select server_version()\");\n    // struct\n    let _version: Version = de!(taos, \"select server_version() as version\");\n    // option\n    let _version: Option<String> = de!(taos, \"select server_version() as version\");\n    // wrapper struct\n    let _version: WrapperVersion = de!(taos, \"select server_version() as version\");\n    // wrapper struct with option\n    let _version: WrapperOptionVersion = dbg!(de!(taos, \"select server_version() as version\"));\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_vec(taos: &Taos) -> anyhow::Result<()> {\n    // let taos = TaosOptions::new().build()?;\n    // std::env::set_var(\"RUST_LOG\", \"trace\");\n    // pretty_env_logger::init();\n\n    let db: Vec<ShowDatabase> = taos.databases().await?;\n    println!(\"db: {:?}\", db);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-error","build.rs"],"content":"use std::env;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::{error::Error, io::BufReader};\n\nuse heck::*;\nuse regex::Regex;\n\nfn code_from_header(\n    header: impl AsRef<Path>,\n    mut output: impl Write,\n) -> Result<(), Box<dyn Error>> {\n    let regex = Regex::new(\n        r\"#define TSDB_CODE_(?P<name>\\S+)\\s+TAOS_DEF_ERROR_CODE\\(0, (?P<code>\\S+)\\)\\s+//.(?P<reason>.*).\\)\",\n    )?;\n\n    let file = File::open(header)?;\n    let buf = BufReader::new(file);\n    const NAME: &str = \"Code\";\n    writeln!(\n        output,\n        r#\"\nuse std::fmt;\n\nuse num_enum::{{FromPrimitive, IntoPrimitive}};\n\nmacro_rules! _impl_fmt {{\n    ($fmt:ident) => {{\n        impl fmt::$fmt for {NAME} {{\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {{\n                let val = *self as i32;\n                fmt::$fmt::fmt(&val, f)\n            }}\n        }}\n    }};\n}}\n\n_impl_fmt!(Display);\n_impl_fmt!(LowerHex);\n_impl_fmt!(UpperHex);\n\n/// TDengine error code.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, FromPrimitive, IntoPrimitive)]\n#[repr(i32)]\n#[derive(serde::Deserialize)]\npub enum {NAME} {{\n    /// Success, 0\n    Success = 0x0000,\"#\n    )?;\n    let codes: Vec<_> = buf\n        .lines()\n        .flat_map(Result::ok)\n        .flat_map(|line| {\n            regex.captures(&line).map(|caps| {\n                (\n                    caps.name(\"name\").unwrap().as_str().to_string(),\n                    caps.name(\"code\").unwrap().as_str().to_string(),\n                    caps.name(\"reason\").unwrap().as_str().to_string(),\n                )\n            })\n        })\n        .collect();\n    for (name, code, reason) in &codes {\n        writeln!(output, \"    /// {}: {}\", name, reason)?;\n        writeln!(output, \"    {} = {},\", name.to_upper_camel_case(), code)?;\n    }\n    writeln!(\n        output,\n        r#\"\n    #[num_enum(default)]\n    Failed = 0xffff,\n}}\n\nimpl {NAME} {{\n    pub fn success(&self) -> bool {{\n        matches!(self, {NAME}::Success)\n    }}\"#\n    )?;\n\n    for (name, _, reason) in &codes {\n        writeln!(output, \"    /// {}: {}\", name, reason)?;\n        writeln!(\n            output,\n            \"    pub fn {}(&self) -> bool {{\\n        matches!(self, {NAME}::{})\\n    }}\",\n            name.to_snake_case(),\n            name.to_upper_camel_case()\n        )?;\n    }\n    writeln!(output, r#\"}}\"#)?;\n\n    writeln!(\n        output,\n        r#\"\nimpl {NAME} {{\n    pub fn to_str(&self) -> &'static str {{\n        use {NAME}::*;\n        match self {{\n            Success => \"Success\",\n\"#\n    )?;\n    for (name, _, reason) in &codes {\n        writeln!(\n            output,\n            r#\"            {} => \"{reason}\",\"#,\n            name.to_upper_camel_case()\n        )?;\n    }\n    writeln!(\n        output,\n        r#\"            Failed => \"Unknown or needn't tell detail error\",\"#\n    )?;\n    writeln!(\n        output,\n        r#\"        }}\n    }}\n}}\n\"#\n    )?;\n    Ok(())\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let header = \"src/taoserror.h\";\n    println!(\"cargo:rerun-if-changed={header}\");\n    println!(\"cargo:rerun-if-changed=build.rs\");\n\n    let out_dir = env::var_os(\"OUT_DIR\").unwrap();\n    let rs = File::create(Path::new(&out_dir).join(\"code.rs\"))?;\n    code_from_header(header, rs)?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-error","src","lib.rs"],"content":"use std::{\n    borrow::Cow,\n    fmt::{self, Display},\n    str::FromStr,\n};\n\nmod code {\n    include!(concat!(env!(\"OUT_DIR\"), \"/code.rs\"));\n}\n\npub use code::Code;\nuse serde::de;\n\n#[derive(Debug)]\npub struct Error {\n    code: Code,\n    err: Cow<'static, str>,\n}\n\npub type Result<T> = std::result::Result<T, Error>;\n\nimpl std::error::Error for Error {}\n\nimpl Error {\n    #[inline]\n    pub fn new(code: impl Into<Code>, err: impl Into<Cow<'static, str>>) -> Self {\n        Self {\n            code: code.into(),\n            err: err.into(),\n        }\n    }\n\n    #[inline]\n    pub fn from_code(code: impl Into<Code>) -> Self {\n        Self {\n            code: code.into(),\n            err: \"\".into(),\n        }\n    }\n\n    #[inline]\n    pub fn from_string(err: impl Into<Cow<'static, str>>) -> Self {\n        Self {\n            code: Code::Failed,\n            err: err.into(),\n        }\n    }\n}\n\nimpl FromStr for Error {\n    type Err = ();\n\n    #[inline]\n    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {\n        Ok(Self {\n            code: Code::Failed,\n            err: s.to_string().into(),\n        })\n    }\n}\n\nimpl Display for Error {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"[{:#06X}] {}\", self.code, self.err)\n    }\n}\n\nimpl de::Error for Error {\n    #[inline]\n    fn custom<T: fmt::Display>(msg: T) -> Error {\n        Error::from_string(format!(\"{}\", msg))\n    }\n}\n\n#[test]\nfn test_display() {\n    let err = Error::new(Code::Success, \"Success\");\n    assert_eq!(format!(\"{err}\"), \"[0x0000] Success\");\n}\n","traces":[{"line":26,"address":[8118550,8118320,8118576,8118778,8118806,8119017,8118522,8118832],"length":1,"stats":{"Line":0},"fn_name":"new<taos_error::code::Code, alloc::string::String>"},{"line":28,"address":[8118880,8118613,8118357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[8118419,8118939,8118675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[8119040],"length":1,"stats":{"Line":0},"fn_name":"from_code<taos_error::code::Code>"},{"line":36,"address":[8119069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[8119079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3841600,3841712],"length":1,"stats":{"Line":0},"fn_name":"from_string<&str>"},{"line":45,"address":[3841631,3841733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[8764448],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":55,"address":[8764515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[8764477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[8764485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3972080],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":65,"address":[3972113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[8782992,8783192],"length":1,"stats":{"Line":0},"fn_name":"custom<core::fmt::Arguments>"},{"line":72,"address":[8783080,8783022],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","src","lib.rs"],"content":"#[cfg(test)]\nmod tests {\n    use taos::Taos;\n    use taos_macros::test;\n\n    #[test]\n    fn sync() {}\n\n    #[test]\n    async fn async_unit() {}\n\n    #[test]\n    async fn async_with_taos(_taos: &Taos) {}\n\n    #[test]\n    async fn async_with_taos_db(_taos: &Taos, _database: &str) {}\n\n    #[test(databases = 10)]\n    async fn async_with_taos_multi(taos: &Taos, _databases: &[&str]) -> taos::Result<()> {\n        let a = taos.databases().await?;\n        assert!(a.len() >= 10);\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","anyhow-d6c2a10a550f3674","out","probe.rs"],"content":"\n    #![feature(backtrace)]\n    #![allow(dead_code)]\n\n    use std::backtrace::{Backtrace, BacktraceStatus};\n    use std::error::Error;\n    use std::fmt::{self, Display};\n\n    #[derive(Debug)]\n    struct E;\n\n    impl Display for E {\n        fn fmt(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {\n            unimplemented!()\n        }\n    }\n\n    impl Error for E {\n        fn backtrace(&self) -> Option<&Backtrace> {\n            let backtrace = Backtrace::capture();\n            match backtrace.status() {\n                BacktraceStatus::Captured | BacktraceStatus::Disabled | _ => {}\n            }\n            unimplemented!()\n        }\n    }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","anyhow-db2f151f47fbe6e5","out","probe.rs"],"content":"\n    #![feature(backtrace)]\n    #![allow(dead_code)]\n\n    use std::backtrace::{Backtrace, BacktraceStatus};\n    use std::error::Error;\n    use std::fmt::{self, Display};\n\n    #[derive(Debug)]\n    struct E;\n\n    impl Display for E {\n        fn fmt(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {\n            unimplemented!()\n        }\n    }\n\n    impl Error for E {\n        fn backtrace(&self) -> Option<&Backtrace> {\n            let backtrace = Backtrace::capture();\n            match backtrace.status() {\n                BacktraceStatus::Captured | BacktraceStatus::Disabled | _ => {}\n            }\n            unimplemented!()\n        }\n    }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","taos-error-377b4e21fb40c858","out","code.rs"],"content":"\nuse std::fmt;\n\nuse num_enum::{FromPrimitive, IntoPrimitive};\n\nmacro_rules! _impl_fmt {\n    ($fmt:ident) => {\n        impl fmt::$fmt for Code {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                let val = *self as i32;\n                fmt::$fmt::fmt(&val, f)\n            }\n        }\n    };\n}\n\n_impl_fmt!(Display);\n_impl_fmt!(LowerHex);\n_impl_fmt!(UpperHex);\n\n/// TDengine error code.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, FromPrimitive, IntoPrimitive)]\n#[repr(i32)]\n#[derive(serde::Deserialize)]\npub enum Code {\n    /// Success, 0\n    Success = 0x0000,\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    TscInvalidOperation = 0x0200,\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    TscInvalidQhandle = 0x0201,\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    TscInvalidTimeStamp = 0x0202,\n    /// TSC_INVALID_VALUE: Invalid value in client\n    TscInvalidValue = 0x0203,\n    /// TSC_INVALID_VERSION: Invalid client version\n    TscInvalidVersion = 0x0204,\n    /// TSC_INVALID_IE: Invalid client ie\n    TscInvalidIe = 0x0205,\n    /// TSC_INVALID_FQDN: Invalid host name\n    TscInvalidFqdn = 0x0206,\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    TscInvalidUserLength = 0x0207,\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    TscInvalidPassLength = 0x0208,\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    TscInvalidDbLength = 0x0209,\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    TscInvalidTableIdLength = 0x020A,\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    TscInvalidConnection = 0x020B,\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    TscOutOfMemory = 0x020C,\n    /// TSC_NO_DISKSPACE: System out of disk space\n    TscNoDiskspace = 0x020D,\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    TscQueryCacheErased = 0x020E,\n    /// TSC_QUERY_CANCELLED: Query terminated\n    TscQueryCancelled = 0x020F,\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    TscSortedResTooMany = 0x0210,\n    /// TSC_APP_ERROR: Application error\n    TscAppError = 0x0211,\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    TscActionInProgress = 0x0212,\n    /// TSC_DISCONNECTED: Disconnected from service\n    TscDisconnected = 0x0213,\n    /// TSC_NO_WRITE_AUTH: No write permission\n    TscNoWriteAuth = 0x0214,\n    /// TSC_CONN_KILLED: Connection killed\n    TscConnKilled = 0x0215,\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    TscSqlSyntaxError = 0x0216,\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    TscDbNotSelected = 0x0217,\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    TscInvalidTableName = 0x0218,\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    TscExceedSqlLimit = 0x0219,\n    /// TSC_FILE_EMPTY: File is empty\n    TscFileEmpty = 0x021A,\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    TscLineSyntaxError = 0x021B,\n    /// TSC_NO_META_CACHED: No table meta cached\n    TscNoMetaCached = 0x021C,\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    TscDupColNames = 0x021D,\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    TscInvalidTagLength = 0x021E,\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    TscInvalidColumnLength = 0x021F,\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    TscDupTagNames = 0x0220,\n    /// TSC_INVALID_JSON: Invalid JSON format\n    TscInvalidJson = 0x0221,\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    TscInvalidJsonType = 0x0222,\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    TscInvalidJsonConfig = 0x0223,\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    TscValueOutOfRange = 0x0224,\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    TscInvalidProtocolType = 0x0225,\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    TscInvalidPrecisionType = 0x0226,\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    TscResTooMany = 0x0227,\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    TscInvalidSchemaVersion = 0x0228,\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    MndInvalidTopic = 0x0392,\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    MndInvalidTopicOption = 0x0393,\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    MndInvalidTopicPartitons = 0x0394,\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    MndTopicAlreadyExist = 0x0395,\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    TdbInvalidTableId = 0x0600,\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    TdbInvalidTableType = 0x0601,\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    TdbIvdTbSchemaVersion = 0x0602,\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    TdbTableAlreadyExist = 0x0603,\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    TdbInvalidConfig = 0x0604,\n    /// TDB_INIT_FAILED: Tsdb init failed\n    TdbInitFailed = 0x0605,\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    TdbNoDiskspace = 0x0606,\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    TdbNoDiskPermissions = 0x0607,\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    TdbFileCorrupted = 0x0608,\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    TdbOutOfMemory = 0x0609,\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    TdbTagVerOutOfDate = 0x060A,\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    TdbTimestampOutOfRange = 0x060B,\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    TdbSubmitMsgMssedUp = 0x060C,\n    /// TDB_INVALID_ACTION: Invalid operation\n    TdbInvalidAction = 0x060D,\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    TdbInvalidCreateTbMsg = 0x060E,\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    TdbNoTableDataInMem = 0x060F,\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    TdbFileAlreadyExists = 0x0610,\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    TdbTableReconfigure = 0x0611,\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    TdbIvdCreateTableInfo = 0x0612,\n    /// TDB_NO_AVAIL_DISK: No available disk\n    TdbNoAvailDisk = 0x0613,\n    /// TDB_MESSED_MSG: TSDB messed message\n    TdbMessedMsg = 0x0614,\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    TdbIvldTagVal = 0x0615,\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    TdbNoCacheLastRow = 0x0616,\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    TdbIncompleteDfileset = 0x0617,\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    QryInvalidQhandle = 0x0700,\n    /// QRY_INVALID_MSG: Invalid message\n    QryInvalidMsg = 0x0701,\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    QryNoDiskspace = 0x0702,\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    QryOutOfMemory = 0x0703,\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    QryAppError = 0x0704,\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    QryDupJoinKey = 0x0705,\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    QryExceedTagsLimit = 0x0706,\n    /// QRY_NOT_READY: Query not ready\n    QryNotReady = 0x0707,\n    /// QRY_HAS_RSP: Query should response\n    QryHasRsp = 0x0708,\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    QryInExec = 0x0709,\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    QryTooManyTimewindow = 0x070A,\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    QryNotEnoughBuffer = 0x070B,\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    QryInconsistan = 0x070C,\n    /// QRY_SYS_ERROR: System error\n    QrySysError = 0x070D,\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    QryInvalidTimeCondition = 0x070E,\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    QryInvalidSchemaVersion = 0x0710,\n\n    #[num_enum(default)]\n    Failed = 0xffff,\n}\n\nimpl Code {\n    pub fn success(&self) -> bool {\n        matches!(self, Code::Success)\n    }\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    pub fn tsc_invalid_operation(&self) -> bool {\n        matches!(self, Code::TscInvalidOperation)\n    }\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    pub fn tsc_invalid_qhandle(&self) -> bool {\n        matches!(self, Code::TscInvalidQhandle)\n    }\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    pub fn tsc_invalid_time_stamp(&self) -> bool {\n        matches!(self, Code::TscInvalidTimeStamp)\n    }\n    /// TSC_INVALID_VALUE: Invalid value in client\n    pub fn tsc_invalid_value(&self) -> bool {\n        matches!(self, Code::TscInvalidValue)\n    }\n    /// TSC_INVALID_VERSION: Invalid client version\n    pub fn tsc_invalid_version(&self) -> bool {\n        matches!(self, Code::TscInvalidVersion)\n    }\n    /// TSC_INVALID_IE: Invalid client ie\n    pub fn tsc_invalid_ie(&self) -> bool {\n        matches!(self, Code::TscInvalidIe)\n    }\n    /// TSC_INVALID_FQDN: Invalid host name\n    pub fn tsc_invalid_fqdn(&self) -> bool {\n        matches!(self, Code::TscInvalidFqdn)\n    }\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    pub fn tsc_invalid_user_length(&self) -> bool {\n        matches!(self, Code::TscInvalidUserLength)\n    }\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    pub fn tsc_invalid_pass_length(&self) -> bool {\n        matches!(self, Code::TscInvalidPassLength)\n    }\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    pub fn tsc_invalid_db_length(&self) -> bool {\n        matches!(self, Code::TscInvalidDbLength)\n    }\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    pub fn tsc_invalid_table_id_length(&self) -> bool {\n        matches!(self, Code::TscInvalidTableIdLength)\n    }\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    pub fn tsc_invalid_connection(&self) -> bool {\n        matches!(self, Code::TscInvalidConnection)\n    }\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    pub fn tsc_out_of_memory(&self) -> bool {\n        matches!(self, Code::TscOutOfMemory)\n    }\n    /// TSC_NO_DISKSPACE: System out of disk space\n    pub fn tsc_no_diskspace(&self) -> bool {\n        matches!(self, Code::TscNoDiskspace)\n    }\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    pub fn tsc_query_cache_erased(&self) -> bool {\n        matches!(self, Code::TscQueryCacheErased)\n    }\n    /// TSC_QUERY_CANCELLED: Query terminated\n    pub fn tsc_query_cancelled(&self) -> bool {\n        matches!(self, Code::TscQueryCancelled)\n    }\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    pub fn tsc_sorted_res_too_many(&self) -> bool {\n        matches!(self, Code::TscSortedResTooMany)\n    }\n    /// TSC_APP_ERROR: Application error\n    pub fn tsc_app_error(&self) -> bool {\n        matches!(self, Code::TscAppError)\n    }\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    pub fn tsc_action_in_progress(&self) -> bool {\n        matches!(self, Code::TscActionInProgress)\n    }\n    /// TSC_DISCONNECTED: Disconnected from service\n    pub fn tsc_disconnected(&self) -> bool {\n        matches!(self, Code::TscDisconnected)\n    }\n    /// TSC_NO_WRITE_AUTH: No write permission\n    pub fn tsc_no_write_auth(&self) -> bool {\n        matches!(self, Code::TscNoWriteAuth)\n    }\n    /// TSC_CONN_KILLED: Connection killed\n    pub fn tsc_conn_killed(&self) -> bool {\n        matches!(self, Code::TscConnKilled)\n    }\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    pub fn tsc_sql_syntax_error(&self) -> bool {\n        matches!(self, Code::TscSqlSyntaxError)\n    }\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    pub fn tsc_db_not_selected(&self) -> bool {\n        matches!(self, Code::TscDbNotSelected)\n    }\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    pub fn tsc_invalid_table_name(&self) -> bool {\n        matches!(self, Code::TscInvalidTableName)\n    }\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    pub fn tsc_exceed_sql_limit(&self) -> bool {\n        matches!(self, Code::TscExceedSqlLimit)\n    }\n    /// TSC_FILE_EMPTY: File is empty\n    pub fn tsc_file_empty(&self) -> bool {\n        matches!(self, Code::TscFileEmpty)\n    }\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    pub fn tsc_line_syntax_error(&self) -> bool {\n        matches!(self, Code::TscLineSyntaxError)\n    }\n    /// TSC_NO_META_CACHED: No table meta cached\n    pub fn tsc_no_meta_cached(&self) -> bool {\n        matches!(self, Code::TscNoMetaCached)\n    }\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    pub fn tsc_dup_col_names(&self) -> bool {\n        matches!(self, Code::TscDupColNames)\n    }\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    pub fn tsc_invalid_tag_length(&self) -> bool {\n        matches!(self, Code::TscInvalidTagLength)\n    }\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    pub fn tsc_invalid_column_length(&self) -> bool {\n        matches!(self, Code::TscInvalidColumnLength)\n    }\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    pub fn tsc_dup_tag_names(&self) -> bool {\n        matches!(self, Code::TscDupTagNames)\n    }\n    /// TSC_INVALID_JSON: Invalid JSON format\n    pub fn tsc_invalid_json(&self) -> bool {\n        matches!(self, Code::TscInvalidJson)\n    }\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    pub fn tsc_invalid_json_type(&self) -> bool {\n        matches!(self, Code::TscInvalidJsonType)\n    }\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    pub fn tsc_invalid_json_config(&self) -> bool {\n        matches!(self, Code::TscInvalidJsonConfig)\n    }\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    pub fn tsc_value_out_of_range(&self) -> bool {\n        matches!(self, Code::TscValueOutOfRange)\n    }\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    pub fn tsc_invalid_protocol_type(&self) -> bool {\n        matches!(self, Code::TscInvalidProtocolType)\n    }\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    pub fn tsc_invalid_precision_type(&self) -> bool {\n        matches!(self, Code::TscInvalidPrecisionType)\n    }\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    pub fn tsc_res_too_many(&self) -> bool {\n        matches!(self, Code::TscResTooMany)\n    }\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    pub fn tsc_invalid_schema_version(&self) -> bool {\n        matches!(self, Code::TscInvalidSchemaVersion)\n    }\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    pub fn mnd_invalid_topic(&self) -> bool {\n        matches!(self, Code::MndInvalidTopic)\n    }\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    pub fn mnd_invalid_topic_option(&self) -> bool {\n        matches!(self, Code::MndInvalidTopicOption)\n    }\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    pub fn mnd_invalid_topic_partitons(&self) -> bool {\n        matches!(self, Code::MndInvalidTopicPartitons)\n    }\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    pub fn mnd_topic_already_exist(&self) -> bool {\n        matches!(self, Code::MndTopicAlreadyExist)\n    }\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    pub fn tdb_invalid_table_id(&self) -> bool {\n        matches!(self, Code::TdbInvalidTableId)\n    }\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    pub fn tdb_invalid_table_type(&self) -> bool {\n        matches!(self, Code::TdbInvalidTableType)\n    }\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    pub fn tdb_ivd_tb_schema_version(&self) -> bool {\n        matches!(self, Code::TdbIvdTbSchemaVersion)\n    }\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    pub fn tdb_table_already_exist(&self) -> bool {\n        matches!(self, Code::TdbTableAlreadyExist)\n    }\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    pub fn tdb_invalid_config(&self) -> bool {\n        matches!(self, Code::TdbInvalidConfig)\n    }\n    /// TDB_INIT_FAILED: Tsdb init failed\n    pub fn tdb_init_failed(&self) -> bool {\n        matches!(self, Code::TdbInitFailed)\n    }\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    pub fn tdb_no_diskspace(&self) -> bool {\n        matches!(self, Code::TdbNoDiskspace)\n    }\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    pub fn tdb_no_disk_permissions(&self) -> bool {\n        matches!(self, Code::TdbNoDiskPermissions)\n    }\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    pub fn tdb_file_corrupted(&self) -> bool {\n        matches!(self, Code::TdbFileCorrupted)\n    }\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    pub fn tdb_out_of_memory(&self) -> bool {\n        matches!(self, Code::TdbOutOfMemory)\n    }\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    pub fn tdb_tag_ver_out_of_date(&self) -> bool {\n        matches!(self, Code::TdbTagVerOutOfDate)\n    }\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    pub fn tdb_timestamp_out_of_range(&self) -> bool {\n        matches!(self, Code::TdbTimestampOutOfRange)\n    }\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    pub fn tdb_submit_msg_mssed_up(&self) -> bool {\n        matches!(self, Code::TdbSubmitMsgMssedUp)\n    }\n    /// TDB_INVALID_ACTION: Invalid operation\n    pub fn tdb_invalid_action(&self) -> bool {\n        matches!(self, Code::TdbInvalidAction)\n    }\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    pub fn tdb_invalid_create_tb_msg(&self) -> bool {\n        matches!(self, Code::TdbInvalidCreateTbMsg)\n    }\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    pub fn tdb_no_table_data_in_mem(&self) -> bool {\n        matches!(self, Code::TdbNoTableDataInMem)\n    }\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    pub fn tdb_file_already_exists(&self) -> bool {\n        matches!(self, Code::TdbFileAlreadyExists)\n    }\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    pub fn tdb_table_reconfigure(&self) -> bool {\n        matches!(self, Code::TdbTableReconfigure)\n    }\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    pub fn tdb_ivd_create_table_info(&self) -> bool {\n        matches!(self, Code::TdbIvdCreateTableInfo)\n    }\n    /// TDB_NO_AVAIL_DISK: No available disk\n    pub fn tdb_no_avail_disk(&self) -> bool {\n        matches!(self, Code::TdbNoAvailDisk)\n    }\n    /// TDB_MESSED_MSG: TSDB messed message\n    pub fn tdb_messed_msg(&self) -> bool {\n        matches!(self, Code::TdbMessedMsg)\n    }\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    pub fn tdb_ivld_tag_val(&self) -> bool {\n        matches!(self, Code::TdbIvldTagVal)\n    }\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    pub fn tdb_no_cache_last_row(&self) -> bool {\n        matches!(self, Code::TdbNoCacheLastRow)\n    }\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    pub fn tdb_incomplete_dfileset(&self) -> bool {\n        matches!(self, Code::TdbIncompleteDfileset)\n    }\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    pub fn qry_invalid_qhandle(&self) -> bool {\n        matches!(self, Code::QryInvalidQhandle)\n    }\n    /// QRY_INVALID_MSG: Invalid message\n    pub fn qry_invalid_msg(&self) -> bool {\n        matches!(self, Code::QryInvalidMsg)\n    }\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    pub fn qry_no_diskspace(&self) -> bool {\n        matches!(self, Code::QryNoDiskspace)\n    }\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    pub fn qry_out_of_memory(&self) -> bool {\n        matches!(self, Code::QryOutOfMemory)\n    }\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    pub fn qry_app_error(&self) -> bool {\n        matches!(self, Code::QryAppError)\n    }\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    pub fn qry_dup_join_key(&self) -> bool {\n        matches!(self, Code::QryDupJoinKey)\n    }\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    pub fn qry_exceed_tags_limit(&self) -> bool {\n        matches!(self, Code::QryExceedTagsLimit)\n    }\n    /// QRY_NOT_READY: Query not ready\n    pub fn qry_not_ready(&self) -> bool {\n        matches!(self, Code::QryNotReady)\n    }\n    /// QRY_HAS_RSP: Query should response\n    pub fn qry_has_rsp(&self) -> bool {\n        matches!(self, Code::QryHasRsp)\n    }\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    pub fn qry_in_exec(&self) -> bool {\n        matches!(self, Code::QryInExec)\n    }\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    pub fn qry_too_many_timewindow(&self) -> bool {\n        matches!(self, Code::QryTooManyTimewindow)\n    }\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    pub fn qry_not_enough_buffer(&self) -> bool {\n        matches!(self, Code::QryNotEnoughBuffer)\n    }\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    pub fn qry_inconsistan(&self) -> bool {\n        matches!(self, Code::QryInconsistan)\n    }\n    /// QRY_SYS_ERROR: System error\n    pub fn qry_sys_error(&self) -> bool {\n        matches!(self, Code::QrySysError)\n    }\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    pub fn qry_invalid_time_condition(&self) -> bool {\n        matches!(self, Code::QryInvalidTimeCondition)\n    }\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    pub fn qry_invalid_schema_version(&self) -> bool {\n        matches!(self, Code::QryInvalidSchemaVersion)\n    }\n}\n\nimpl Code {\n    pub fn to_str(&self) -> &'static str {\n        use Code::*;\n        match self {\n            Success => \"Success\",\n\n            TscInvalidOperation => \"Invalid Operation\",\n            TscInvalidQhandle => \"Invalid qhandle\",\n            TscInvalidTimeStamp => \"Invalid combination of client/service time\",\n            TscInvalidValue => \"Invalid value in client\",\n            TscInvalidVersion => \"Invalid client version\",\n            TscInvalidIe => \"Invalid client ie\",\n            TscInvalidFqdn => \"Invalid host name\",\n            TscInvalidUserLength => \"Invalid user name\",\n            TscInvalidPassLength => \"Invalid password\",\n            TscInvalidDbLength => \"Database name too long\",\n            TscInvalidTableIdLength => \"Table name too long\",\n            TscInvalidConnection => \"Invalid connection\",\n            TscOutOfMemory => \"System out of memory\",\n            TscNoDiskspace => \"System out of disk space\",\n            TscQueryCacheErased => \"Query cache erased\",\n            TscQueryCancelled => \"Query terminated\",\n            TscSortedResTooMany => \"Result set too large to be sorted\",\n            TscAppError => \"Application error\",\n            TscActionInProgress => \"Action in progress\",\n            TscDisconnected => \"Disconnected from service\",\n            TscNoWriteAuth => \"No write permission\",\n            TscConnKilled => \"Connection killed\",\n            TscSqlSyntaxError => \"Syntax error in SQL\",\n            TscDbNotSelected => \"Database not specified or available\",\n            TscInvalidTableName => \"Table does not exist\",\n            TscExceedSqlLimit => \"SQL statement too long check maxSQLLength config\",\n            TscFileEmpty => \"File is empty\",\n            TscLineSyntaxError => \"Syntax error in Line\",\n            TscNoMetaCached => \"No table meta cached\",\n            TscDupColNames => \"duplicated column names\",\n            TscInvalidTagLength => \"Invalid tag length\",\n            TscInvalidColumnLength => \"Invalid column length\",\n            TscDupTagNames => \"duplicated tag names\",\n            TscInvalidJson => \"Invalid JSON format\",\n            TscInvalidJsonType => \"Invalid JSON data type\",\n            TscInvalidJsonConfig => \"Invalid JSON configuration\",\n            TscValueOutOfRange => \"Value out of range\",\n            TscInvalidProtocolType => \"Invalid line protocol type\",\n            TscInvalidPrecisionType => \"Invalid timestamp precision type\",\n            TscResTooMany => \"Result set too large to be output\",\n            TscInvalidSchemaVersion => \"invalid table schema version\",\n            MndInvalidTopic => \"Invalid topic nam\",\n            MndInvalidTopicOption => \"Invalid topic optio\",\n            MndInvalidTopicPartitons => \"Invalid topic partitons num, valid range: [1, 1000\",\n            MndTopicAlreadyExist => \"Topic already exist\",\n            TdbInvalidTableId => \"Invalid table ID\",\n            TdbInvalidTableType => \"Invalid table type\",\n            TdbIvdTbSchemaVersion => \"Invalid table schema version\",\n            TdbTableAlreadyExist => \"Table already exists\",\n            TdbInvalidConfig => \"Invalid configuration\",\n            TdbInitFailed => \"Tsdb init failed\",\n            TdbNoDiskspace => \"No diskspace for tsdb\",\n            TdbNoDiskPermissions => \"No permission for disk files\",\n            TdbFileCorrupted => \"Data file(s) corrupted\",\n            TdbOutOfMemory => \"Out of memory\",\n            TdbTagVerOutOfDate => \"Tag too old\",\n            TdbTimestampOutOfRange => \"Timestamp data out of range\",\n            TdbSubmitMsgMssedUp => \"Submit message is messed up\",\n            TdbInvalidAction => \"Invalid operation\",\n            TdbInvalidCreateTbMsg => \"Invalid creation of table\",\n            TdbNoTableDataInMem => \"No table data in memory skiplist\",\n            TdbFileAlreadyExists => \"File already exists\",\n            TdbTableReconfigure => \"Need to reconfigure table\",\n            TdbIvdCreateTableInfo => \"Invalid information to create table\",\n            TdbNoAvailDisk => \"No available disk\",\n            TdbMessedMsg => \"TSDB messed message\",\n            TdbIvldTagVal => \"TSDB invalid tag value\",\n            TdbNoCacheLastRow => \"TSDB no cache last row data\",\n            TdbIncompleteDfileset => \"TSDB incomplete DFileSet\",\n            QryInvalidQhandle => \"Invalid handle\",\n            QryInvalidMsg => \"Invalid message\",\n            QryNoDiskspace => \"No diskspace for query\",\n            QryOutOfMemory => \"System out of memory\",\n            QryAppError => \"Unexpected generic error in query\",\n            QryDupJoinKey => \"Duplicated join key\",\n            QryExceedTagsLimit => \"Tag condition too many\",\n            QryNotReady => \"Query not ready\",\n            QryHasRsp => \"Query should response\",\n            QryInExec => \"Multiple retrieval of this query\",\n            QryTooManyTimewindow => \"Too many time window in query\",\n            QryNotEnoughBuffer => \"Query buffer limit has reached\",\n            QryInconsistan => \"File inconsistency in replica\",\n            QrySysError => \"System error\",\n            QryInvalidTimeCondition => \"invalid time condition\",\n            QryInvalidSchemaVersion => \"invalid schema version\",\n            Failed => \"Unknown or needn't tell detail error\",\n        }\n    }\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","taos-error-9a878855c40049e3","out","code.rs"],"content":"\nuse std::fmt;\n\nuse num_enum::{FromPrimitive, IntoPrimitive};\n\nmacro_rules! _impl_fmt {\n    ($fmt:ident) => {\n        impl fmt::$fmt for Code {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                let val = *self as i32;\n                fmt::$fmt::fmt(&val, f)\n            }\n        }\n    };\n}\n\n_impl_fmt!(Display);\n_impl_fmt!(LowerHex);\n_impl_fmt!(UpperHex);\n\n/// TDengine error code.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, FromPrimitive, IntoPrimitive)]\n#[repr(i32)]\n#[derive(serde::Deserialize)]\npub enum Code {\n    /// Success, 0\n    Success = 0x0000,\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    TscInvalidOperation = 0x0200,\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    TscInvalidQhandle = 0x0201,\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    TscInvalidTimeStamp = 0x0202,\n    /// TSC_INVALID_VALUE: Invalid value in client\n    TscInvalidValue = 0x0203,\n    /// TSC_INVALID_VERSION: Invalid client version\n    TscInvalidVersion = 0x0204,\n    /// TSC_INVALID_IE: Invalid client ie\n    TscInvalidIe = 0x0205,\n    /// TSC_INVALID_FQDN: Invalid host name\n    TscInvalidFqdn = 0x0206,\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    TscInvalidUserLength = 0x0207,\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    TscInvalidPassLength = 0x0208,\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    TscInvalidDbLength = 0x0209,\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    TscInvalidTableIdLength = 0x020A,\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    TscInvalidConnection = 0x020B,\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    TscOutOfMemory = 0x020C,\n    /// TSC_NO_DISKSPACE: System out of disk space\n    TscNoDiskspace = 0x020D,\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    TscQueryCacheErased = 0x020E,\n    /// TSC_QUERY_CANCELLED: Query terminated\n    TscQueryCancelled = 0x020F,\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    TscSortedResTooMany = 0x0210,\n    /// TSC_APP_ERROR: Application error\n    TscAppError = 0x0211,\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    TscActionInProgress = 0x0212,\n    /// TSC_DISCONNECTED: Disconnected from service\n    TscDisconnected = 0x0213,\n    /// TSC_NO_WRITE_AUTH: No write permission\n    TscNoWriteAuth = 0x0214,\n    /// TSC_CONN_KILLED: Connection killed\n    TscConnKilled = 0x0215,\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    TscSqlSyntaxError = 0x0216,\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    TscDbNotSelected = 0x0217,\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    TscInvalidTableName = 0x0218,\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    TscExceedSqlLimit = 0x0219,\n    /// TSC_FILE_EMPTY: File is empty\n    TscFileEmpty = 0x021A,\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    TscLineSyntaxError = 0x021B,\n    /// TSC_NO_META_CACHED: No table meta cached\n    TscNoMetaCached = 0x021C,\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    TscDupColNames = 0x021D,\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    TscInvalidTagLength = 0x021E,\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    TscInvalidColumnLength = 0x021F,\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    TscDupTagNames = 0x0220,\n    /// TSC_INVALID_JSON: Invalid JSON format\n    TscInvalidJson = 0x0221,\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    TscInvalidJsonType = 0x0222,\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    TscInvalidJsonConfig = 0x0223,\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    TscValueOutOfRange = 0x0224,\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    TscInvalidProtocolType = 0x0225,\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    TscInvalidPrecisionType = 0x0226,\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    TscResTooMany = 0x0227,\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    TscInvalidSchemaVersion = 0x0228,\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    MndInvalidTopic = 0x0392,\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    MndInvalidTopicOption = 0x0393,\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    MndInvalidTopicPartitons = 0x0394,\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    MndTopicAlreadyExist = 0x0395,\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    TdbInvalidTableId = 0x0600,\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    TdbInvalidTableType = 0x0601,\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    TdbIvdTbSchemaVersion = 0x0602,\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    TdbTableAlreadyExist = 0x0603,\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    TdbInvalidConfig = 0x0604,\n    /// TDB_INIT_FAILED: Tsdb init failed\n    TdbInitFailed = 0x0605,\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    TdbNoDiskspace = 0x0606,\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    TdbNoDiskPermissions = 0x0607,\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    TdbFileCorrupted = 0x0608,\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    TdbOutOfMemory = 0x0609,\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    TdbTagVerOutOfDate = 0x060A,\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    TdbTimestampOutOfRange = 0x060B,\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    TdbSubmitMsgMssedUp = 0x060C,\n    /// TDB_INVALID_ACTION: Invalid operation\n    TdbInvalidAction = 0x060D,\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    TdbInvalidCreateTbMsg = 0x060E,\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    TdbNoTableDataInMem = 0x060F,\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    TdbFileAlreadyExists = 0x0610,\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    TdbTableReconfigure = 0x0611,\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    TdbIvdCreateTableInfo = 0x0612,\n    /// TDB_NO_AVAIL_DISK: No available disk\n    TdbNoAvailDisk = 0x0613,\n    /// TDB_MESSED_MSG: TSDB messed message\n    TdbMessedMsg = 0x0614,\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    TdbIvldTagVal = 0x0615,\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    TdbNoCacheLastRow = 0x0616,\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    TdbIncompleteDfileset = 0x0617,\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    QryInvalidQhandle = 0x0700,\n    /// QRY_INVALID_MSG: Invalid message\n    QryInvalidMsg = 0x0701,\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    QryNoDiskspace = 0x0702,\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    QryOutOfMemory = 0x0703,\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    QryAppError = 0x0704,\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    QryDupJoinKey = 0x0705,\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    QryExceedTagsLimit = 0x0706,\n    /// QRY_NOT_READY: Query not ready\n    QryNotReady = 0x0707,\n    /// QRY_HAS_RSP: Query should response\n    QryHasRsp = 0x0708,\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    QryInExec = 0x0709,\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    QryTooManyTimewindow = 0x070A,\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    QryNotEnoughBuffer = 0x070B,\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    QryInconsistan = 0x070C,\n    /// QRY_SYS_ERROR: System error\n    QrySysError = 0x070D,\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    QryInvalidTimeCondition = 0x070E,\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    QryInvalidSchemaVersion = 0x0710,\n\n    #[num_enum(default)]\n    Failed = 0xffff,\n}\n\nimpl Code {\n    pub fn success(&self) -> bool {\n        matches!(self, Code::Success)\n    }\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    pub fn tsc_invalid_operation(&self) -> bool {\n        matches!(self, Code::TscInvalidOperation)\n    }\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    pub fn tsc_invalid_qhandle(&self) -> bool {\n        matches!(self, Code::TscInvalidQhandle)\n    }\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    pub fn tsc_invalid_time_stamp(&self) -> bool {\n        matches!(self, Code::TscInvalidTimeStamp)\n    }\n    /// TSC_INVALID_VALUE: Invalid value in client\n    pub fn tsc_invalid_value(&self) -> bool {\n        matches!(self, Code::TscInvalidValue)\n    }\n    /// TSC_INVALID_VERSION: Invalid client version\n    pub fn tsc_invalid_version(&self) -> bool {\n        matches!(self, Code::TscInvalidVersion)\n    }\n    /// TSC_INVALID_IE: Invalid client ie\n    pub fn tsc_invalid_ie(&self) -> bool {\n        matches!(self, Code::TscInvalidIe)\n    }\n    /// TSC_INVALID_FQDN: Invalid host name\n    pub fn tsc_invalid_fqdn(&self) -> bool {\n        matches!(self, Code::TscInvalidFqdn)\n    }\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    pub fn tsc_invalid_user_length(&self) -> bool {\n        matches!(self, Code::TscInvalidUserLength)\n    }\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    pub fn tsc_invalid_pass_length(&self) -> bool {\n        matches!(self, Code::TscInvalidPassLength)\n    }\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    pub fn tsc_invalid_db_length(&self) -> bool {\n        matches!(self, Code::TscInvalidDbLength)\n    }\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    pub fn tsc_invalid_table_id_length(&self) -> bool {\n        matches!(self, Code::TscInvalidTableIdLength)\n    }\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    pub fn tsc_invalid_connection(&self) -> bool {\n        matches!(self, Code::TscInvalidConnection)\n    }\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    pub fn tsc_out_of_memory(&self) -> bool {\n        matches!(self, Code::TscOutOfMemory)\n    }\n    /// TSC_NO_DISKSPACE: System out of disk space\n    pub fn tsc_no_diskspace(&self) -> bool {\n        matches!(self, Code::TscNoDiskspace)\n    }\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    pub fn tsc_query_cache_erased(&self) -> bool {\n        matches!(self, Code::TscQueryCacheErased)\n    }\n    /// TSC_QUERY_CANCELLED: Query terminated\n    pub fn tsc_query_cancelled(&self) -> bool {\n        matches!(self, Code::TscQueryCancelled)\n    }\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    pub fn tsc_sorted_res_too_many(&self) -> bool {\n        matches!(self, Code::TscSortedResTooMany)\n    }\n    /// TSC_APP_ERROR: Application error\n    pub fn tsc_app_error(&self) -> bool {\n        matches!(self, Code::TscAppError)\n    }\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    pub fn tsc_action_in_progress(&self) -> bool {\n        matches!(self, Code::TscActionInProgress)\n    }\n    /// TSC_DISCONNECTED: Disconnected from service\n    pub fn tsc_disconnected(&self) -> bool {\n        matches!(self, Code::TscDisconnected)\n    }\n    /// TSC_NO_WRITE_AUTH: No write permission\n    pub fn tsc_no_write_auth(&self) -> bool {\n        matches!(self, Code::TscNoWriteAuth)\n    }\n    /// TSC_CONN_KILLED: Connection killed\n    pub fn tsc_conn_killed(&self) -> bool {\n        matches!(self, Code::TscConnKilled)\n    }\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    pub fn tsc_sql_syntax_error(&self) -> bool {\n        matches!(self, Code::TscSqlSyntaxError)\n    }\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    pub fn tsc_db_not_selected(&self) -> bool {\n        matches!(self, Code::TscDbNotSelected)\n    }\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    pub fn tsc_invalid_table_name(&self) -> bool {\n        matches!(self, Code::TscInvalidTableName)\n    }\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    pub fn tsc_exceed_sql_limit(&self) -> bool {\n        matches!(self, Code::TscExceedSqlLimit)\n    }\n    /// TSC_FILE_EMPTY: File is empty\n    pub fn tsc_file_empty(&self) -> bool {\n        matches!(self, Code::TscFileEmpty)\n    }\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    pub fn tsc_line_syntax_error(&self) -> bool {\n        matches!(self, Code::TscLineSyntaxError)\n    }\n    /// TSC_NO_META_CACHED: No table meta cached\n    pub fn tsc_no_meta_cached(&self) -> bool {\n        matches!(self, Code::TscNoMetaCached)\n    }\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    pub fn tsc_dup_col_names(&self) -> bool {\n        matches!(self, Code::TscDupColNames)\n    }\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    pub fn tsc_invalid_tag_length(&self) -> bool {\n        matches!(self, Code::TscInvalidTagLength)\n    }\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    pub fn tsc_invalid_column_length(&self) -> bool {\n        matches!(self, Code::TscInvalidColumnLength)\n    }\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    pub fn tsc_dup_tag_names(&self) -> bool {\n        matches!(self, Code::TscDupTagNames)\n    }\n    /// TSC_INVALID_JSON: Invalid JSON format\n    pub fn tsc_invalid_json(&self) -> bool {\n        matches!(self, Code::TscInvalidJson)\n    }\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    pub fn tsc_invalid_json_type(&self) -> bool {\n        matches!(self, Code::TscInvalidJsonType)\n    }\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    pub fn tsc_invalid_json_config(&self) -> bool {\n        matches!(self, Code::TscInvalidJsonConfig)\n    }\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    pub fn tsc_value_out_of_range(&self) -> bool {\n        matches!(self, Code::TscValueOutOfRange)\n    }\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    pub fn tsc_invalid_protocol_type(&self) -> bool {\n        matches!(self, Code::TscInvalidProtocolType)\n    }\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    pub fn tsc_invalid_precision_type(&self) -> bool {\n        matches!(self, Code::TscInvalidPrecisionType)\n    }\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    pub fn tsc_res_too_many(&self) -> bool {\n        matches!(self, Code::TscResTooMany)\n    }\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    pub fn tsc_invalid_schema_version(&self) -> bool {\n        matches!(self, Code::TscInvalidSchemaVersion)\n    }\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    pub fn mnd_invalid_topic(&self) -> bool {\n        matches!(self, Code::MndInvalidTopic)\n    }\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    pub fn mnd_invalid_topic_option(&self) -> bool {\n        matches!(self, Code::MndInvalidTopicOption)\n    }\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    pub fn mnd_invalid_topic_partitons(&self) -> bool {\n        matches!(self, Code::MndInvalidTopicPartitons)\n    }\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    pub fn mnd_topic_already_exist(&self) -> bool {\n        matches!(self, Code::MndTopicAlreadyExist)\n    }\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    pub fn tdb_invalid_table_id(&self) -> bool {\n        matches!(self, Code::TdbInvalidTableId)\n    }\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    pub fn tdb_invalid_table_type(&self) -> bool {\n        matches!(self, Code::TdbInvalidTableType)\n    }\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    pub fn tdb_ivd_tb_schema_version(&self) -> bool {\n        matches!(self, Code::TdbIvdTbSchemaVersion)\n    }\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    pub fn tdb_table_already_exist(&self) -> bool {\n        matches!(self, Code::TdbTableAlreadyExist)\n    }\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    pub fn tdb_invalid_config(&self) -> bool {\n        matches!(self, Code::TdbInvalidConfig)\n    }\n    /// TDB_INIT_FAILED: Tsdb init failed\n    pub fn tdb_init_failed(&self) -> bool {\n        matches!(self, Code::TdbInitFailed)\n    }\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    pub fn tdb_no_diskspace(&self) -> bool {\n        matches!(self, Code::TdbNoDiskspace)\n    }\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    pub fn tdb_no_disk_permissions(&self) -> bool {\n        matches!(self, Code::TdbNoDiskPermissions)\n    }\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    pub fn tdb_file_corrupted(&self) -> bool {\n        matches!(self, Code::TdbFileCorrupted)\n    }\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    pub fn tdb_out_of_memory(&self) -> bool {\n        matches!(self, Code::TdbOutOfMemory)\n    }\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    pub fn tdb_tag_ver_out_of_date(&self) -> bool {\n        matches!(self, Code::TdbTagVerOutOfDate)\n    }\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    pub fn tdb_timestamp_out_of_range(&self) -> bool {\n        matches!(self, Code::TdbTimestampOutOfRange)\n    }\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    pub fn tdb_submit_msg_mssed_up(&self) -> bool {\n        matches!(self, Code::TdbSubmitMsgMssedUp)\n    }\n    /// TDB_INVALID_ACTION: Invalid operation\n    pub fn tdb_invalid_action(&self) -> bool {\n        matches!(self, Code::TdbInvalidAction)\n    }\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    pub fn tdb_invalid_create_tb_msg(&self) -> bool {\n        matches!(self, Code::TdbInvalidCreateTbMsg)\n    }\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    pub fn tdb_no_table_data_in_mem(&self) -> bool {\n        matches!(self, Code::TdbNoTableDataInMem)\n    }\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    pub fn tdb_file_already_exists(&self) -> bool {\n        matches!(self, Code::TdbFileAlreadyExists)\n    }\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    pub fn tdb_table_reconfigure(&self) -> bool {\n        matches!(self, Code::TdbTableReconfigure)\n    }\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    pub fn tdb_ivd_create_table_info(&self) -> bool {\n        matches!(self, Code::TdbIvdCreateTableInfo)\n    }\n    /// TDB_NO_AVAIL_DISK: No available disk\n    pub fn tdb_no_avail_disk(&self) -> bool {\n        matches!(self, Code::TdbNoAvailDisk)\n    }\n    /// TDB_MESSED_MSG: TSDB messed message\n    pub fn tdb_messed_msg(&self) -> bool {\n        matches!(self, Code::TdbMessedMsg)\n    }\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    pub fn tdb_ivld_tag_val(&self) -> bool {\n        matches!(self, Code::TdbIvldTagVal)\n    }\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    pub fn tdb_no_cache_last_row(&self) -> bool {\n        matches!(self, Code::TdbNoCacheLastRow)\n    }\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    pub fn tdb_incomplete_dfileset(&self) -> bool {\n        matches!(self, Code::TdbIncompleteDfileset)\n    }\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    pub fn qry_invalid_qhandle(&self) -> bool {\n        matches!(self, Code::QryInvalidQhandle)\n    }\n    /// QRY_INVALID_MSG: Invalid message\n    pub fn qry_invalid_msg(&self) -> bool {\n        matches!(self, Code::QryInvalidMsg)\n    }\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    pub fn qry_no_diskspace(&self) -> bool {\n        matches!(self, Code::QryNoDiskspace)\n    }\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    pub fn qry_out_of_memory(&self) -> bool {\n        matches!(self, Code::QryOutOfMemory)\n    }\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    pub fn qry_app_error(&self) -> bool {\n        matches!(self, Code::QryAppError)\n    }\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    pub fn qry_dup_join_key(&self) -> bool {\n        matches!(self, Code::QryDupJoinKey)\n    }\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    pub fn qry_exceed_tags_limit(&self) -> bool {\n        matches!(self, Code::QryExceedTagsLimit)\n    }\n    /// QRY_NOT_READY: Query not ready\n    pub fn qry_not_ready(&self) -> bool {\n        matches!(self, Code::QryNotReady)\n    }\n    /// QRY_HAS_RSP: Query should response\n    pub fn qry_has_rsp(&self) -> bool {\n        matches!(self, Code::QryHasRsp)\n    }\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    pub fn qry_in_exec(&self) -> bool {\n        matches!(self, Code::QryInExec)\n    }\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    pub fn qry_too_many_timewindow(&self) -> bool {\n        matches!(self, Code::QryTooManyTimewindow)\n    }\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    pub fn qry_not_enough_buffer(&self) -> bool {\n        matches!(self, Code::QryNotEnoughBuffer)\n    }\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    pub fn qry_inconsistan(&self) -> bool {\n        matches!(self, Code::QryInconsistan)\n    }\n    /// QRY_SYS_ERROR: System error\n    pub fn qry_sys_error(&self) -> bool {\n        matches!(self, Code::QrySysError)\n    }\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    pub fn qry_invalid_time_condition(&self) -> bool {\n        matches!(self, Code::QryInvalidTimeCondition)\n    }\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    pub fn qry_invalid_schema_version(&self) -> bool {\n        matches!(self, Code::QryInvalidSchemaVersion)\n    }\n}\n\nimpl Code {\n    pub fn to_str(&self) -> &'static str {\n        use Code::*;\n        match self {\n            Success => \"Success\",\n\n            TscInvalidOperation => \"Invalid Operation\",\n            TscInvalidQhandle => \"Invalid qhandle\",\n            TscInvalidTimeStamp => \"Invalid combination of client/service time\",\n            TscInvalidValue => \"Invalid value in client\",\n            TscInvalidVersion => \"Invalid client version\",\n            TscInvalidIe => \"Invalid client ie\",\n            TscInvalidFqdn => \"Invalid host name\",\n            TscInvalidUserLength => \"Invalid user name\",\n            TscInvalidPassLength => \"Invalid password\",\n            TscInvalidDbLength => \"Database name too long\",\n            TscInvalidTableIdLength => \"Table name too long\",\n            TscInvalidConnection => \"Invalid connection\",\n            TscOutOfMemory => \"System out of memory\",\n            TscNoDiskspace => \"System out of disk space\",\n            TscQueryCacheErased => \"Query cache erased\",\n            TscQueryCancelled => \"Query terminated\",\n            TscSortedResTooMany => \"Result set too large to be sorted\",\n            TscAppError => \"Application error\",\n            TscActionInProgress => \"Action in progress\",\n            TscDisconnected => \"Disconnected from service\",\n            TscNoWriteAuth => \"No write permission\",\n            TscConnKilled => \"Connection killed\",\n            TscSqlSyntaxError => \"Syntax error in SQL\",\n            TscDbNotSelected => \"Database not specified or available\",\n            TscInvalidTableName => \"Table does not exist\",\n            TscExceedSqlLimit => \"SQL statement too long check maxSQLLength config\",\n            TscFileEmpty => \"File is empty\",\n            TscLineSyntaxError => \"Syntax error in Line\",\n            TscNoMetaCached => \"No table meta cached\",\n            TscDupColNames => \"duplicated column names\",\n            TscInvalidTagLength => \"Invalid tag length\",\n            TscInvalidColumnLength => \"Invalid column length\",\n            TscDupTagNames => \"duplicated tag names\",\n            TscInvalidJson => \"Invalid JSON format\",\n            TscInvalidJsonType => \"Invalid JSON data type\",\n            TscInvalidJsonConfig => \"Invalid JSON configuration\",\n            TscValueOutOfRange => \"Value out of range\",\n            TscInvalidProtocolType => \"Invalid line protocol type\",\n            TscInvalidPrecisionType => \"Invalid timestamp precision type\",\n            TscResTooMany => \"Result set too large to be output\",\n            TscInvalidSchemaVersion => \"invalid table schema version\",\n            MndInvalidTopic => \"Invalid topic nam\",\n            MndInvalidTopicOption => \"Invalid topic optio\",\n            MndInvalidTopicPartitons => \"Invalid topic partitons num, valid range: [1, 1000\",\n            MndTopicAlreadyExist => \"Topic already exist\",\n            TdbInvalidTableId => \"Invalid table ID\",\n            TdbInvalidTableType => \"Invalid table type\",\n            TdbIvdTbSchemaVersion => \"Invalid table schema version\",\n            TdbTableAlreadyExist => \"Table already exists\",\n            TdbInvalidConfig => \"Invalid configuration\",\n            TdbInitFailed => \"Tsdb init failed\",\n            TdbNoDiskspace => \"No diskspace for tsdb\",\n            TdbNoDiskPermissions => \"No permission for disk files\",\n            TdbFileCorrupted => \"Data file(s) corrupted\",\n            TdbOutOfMemory => \"Out of memory\",\n            TdbTagVerOutOfDate => \"Tag too old\",\n            TdbTimestampOutOfRange => \"Timestamp data out of range\",\n            TdbSubmitMsgMssedUp => \"Submit message is messed up\",\n            TdbInvalidAction => \"Invalid operation\",\n            TdbInvalidCreateTbMsg => \"Invalid creation of table\",\n            TdbNoTableDataInMem => \"No table data in memory skiplist\",\n            TdbFileAlreadyExists => \"File already exists\",\n            TdbTableReconfigure => \"Need to reconfigure table\",\n            TdbIvdCreateTableInfo => \"Invalid information to create table\",\n            TdbNoAvailDisk => \"No available disk\",\n            TdbMessedMsg => \"TSDB messed message\",\n            TdbIvldTagVal => \"TSDB invalid tag value\",\n            TdbNoCacheLastRow => \"TSDB no cache last row data\",\n            TdbIncompleteDfileset => \"TSDB incomplete DFileSet\",\n            QryInvalidQhandle => \"Invalid handle\",\n            QryInvalidMsg => \"Invalid message\",\n            QryNoDiskspace => \"No diskspace for query\",\n            QryOutOfMemory => \"System out of memory\",\n            QryAppError => \"Unexpected generic error in query\",\n            QryDupJoinKey => \"Duplicated join key\",\n            QryExceedTagsLimit => \"Tag condition too many\",\n            QryNotReady => \"Query not ready\",\n            QryHasRsp => \"Query should response\",\n            QryInExec => \"Multiple retrieval of this query\",\n            QryTooManyTimewindow => \"Too many time window in query\",\n            QryNotEnoughBuffer => \"Query buffer limit has reached\",\n            QryInconsistan => \"File inconsistency in replica\",\n            QrySysError => \"System error\",\n            QryInvalidTimeCondition => \"invalid time condition\",\n            QryInvalidSchemaVersion => \"invalid schema version\",\n            Failed => \"Unknown or needn't tell detail error\",\n        }\n    }\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","src","cfg.rs"],"content":"use proc_macro2::*;\nuse quote::*;\nuse syn::{ForeignItemFn, ItemFn};\n\n/// Replace official `[cfg]` macro to add empty backport functions after the foreign mod block.\npub fn cfg(attr: impl Into<TokenStream>, item: impl Into<TokenStream>) -> TokenStream {\n    let cfg = attr.into();\n\n    let item = item.into();\n    // taos cfg only focus on foreign mod.\n    let syn: syn::ItemForeignMod = match syn::parse2(item.clone()) {\n        Ok(it) => it,\n        Err(_) => {\n            return quote! {\n              #[cfg(#cfg)]\n              #item\n            }\n        }\n    };\n\n    let mut backport = TokenStream::new();\n\n    for item_fn in syn.items {\n        assert!(matches!(item_fn, syn::ForeignItem::Fn(_)));\n        if let syn::ForeignItem::Fn(item_fn) = item_fn {\n            let item_fn = foreign_fn_to_item_fn(item_fn);\n            backport.extend(quote! {\n                #[cfg(not(#cfg))]\n                #[no_mangle]\n                #item_fn\n            });\n        }\n    }\n    return quote! {\n        #[cfg(#cfg)]\n        #item\n\n        #backport\n    };\n}\n\n/// Convert a extern \"C\" foreign function to a no_mangle Rust fn.\nfn foreign_fn_to_item_fn(item: ForeignItemFn) -> ItemFn {\n    let mut sig = item.sig;\n    // use extern \"C\"\n    let abi: syn::Abi = syn::parse_quote!(extern \"C\");\n    sig.abi = Some(abi);\n    let un: syn::token::Unsafe = syn::parse_quote!(unsafe);\n    sig.unsafety = Some(un);\n\n    // add panic block\n    let err = Literal::string(&format!(\n        \"C function {} is not supported in this build\",\n        sig.ident\n    ));\n    let block: syn::Block = syn::parse_quote! {\n        {\n            panic!(#err);\n        }\n    };\n    ItemFn {\n        attrs: item.attrs,\n        vis: item.vis,\n        sig: sig,\n        block: Box::new(block),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::cfg;\n    use quote::quote;\n    use syn::{ForeignItemFn, ItemFn};\n\n    #[test]\n    fn nothing() {\n        let attr = quote!(tmq);\n        let fn_item = quote! {\n            #[doc = \"doc\"]\n            fn abc() {}\n        };\n\n        let tokens = cfg(attr, fn_item);\n\n        let expect = quote! {\n            #[cfg(tmq)]\n            #[doc = \"doc\"]\n            fn abc() {}\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn simple() {\n        let attr = quote!(tmq);\n        let fn_item = quote! {\n            // doc\n            extern \"C\" {\n                pub fn a();\n            }\n        };\n\n        let tokens = cfg(attr, fn_item);\n\n        let expect = quote! {\n            #[cfg(tmq)]\n            extern \"C\" {\n                pub fn a();\n            }\n            #[cfg(not(tmq))]\n            #[no_mangle]\n            pub unsafe extern \"C\" fn a () {\n              panic!(\"C function a is not supported in this build\");\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn test_foreign_to_item() {\n        let c: ForeignItemFn = syn::parse_quote! {\n\n            pub fn tmq_list_new() -> *mut tmq_list_t;\n        };\n        let r = super::foreign_fn_to_item_fn(c);\n\n        let e: ItemFn = syn::parse_quote!(\n            pub unsafe extern \"C\" fn tmq_list_new() -> *mut tmq_list_t {\n                panic!(\"C function tmq_list_new is not supported in this build\");\n            }\n        );\n        assert_eq!(r, e);\n        dbg!(&r);\n    }\n\n    #[test]\n    fn tmq_demo() {\n        let attr = quote!(tmq);\n        let fn_item = quote! {\n            // doc\n            extern \"C\" {\n                pub fn tmq_list_new() -> *mut tmq_list_t;\n                pub fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -> i32;\n            }\n        };\n\n        let tokens = cfg(attr, fn_item);\n\n        let expect = quote! {\n            #[cfg(tmq)]\n            extern \"C\" {\n                pub fn tmq_list_new() -> *mut tmq_list_t;\n                pub fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -> i32;\n            }\n\n            #[cfg(not(tmq))]\n            #[no_mangle]\n            pub unsafe extern \"C\" fn tmq_list_new() -> *mut tmq_list_t {\n                panic!(\"C function tmq_list_new is not supported in this build\");\n            }\n            #[cfg(not(tmq))]\n            #[no_mangle]\n            pub unsafe extern \"C\" fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -> i32 {\n                panic!(\"C function tmq_list_append is not supported in this build\");\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","src","lib.rs"],"content":"extern crate proc_macro;\n\nmod cfg;\nmod test;\n\n/// A `[cfg]`-like macro to add backport code for extern \"C\" foreign mod.\n///\n/// ```rust\n/// # use taos_macros::c_cfg;\n///\n/// #[c_cfg(feature = \"ft1\")]\n/// extern \"C\" {\n///     pub fn raw_c_fn(arg1: *mut std::os::raw::c_void) -> std::os::raw::c_int;\n/// }\n/// ```\n///\n/// The code will expand to:\n///\n/// ```rust\n/// #[cfg(feature = \"ft1\")]\n/// extern \"C\" {\n///     pub fn raw_c_fn(arg1: *mut std::os::raw::c_void) -> std::os::raw::c_int;\n/// }\n/// #[cfg(not(feature = \"ft1\"))]\n/// #[no_mangle]\n/// pub extern \"C\" fn raw_c_fn(arg1: *mut std::os::raw::c_void) -> std::os::raw::c_int {\n///     panic!(\"C function raw_c_fn is not supported in this build\");\n/// }\n/// ```\n#[proc_macro_attribute]\npub fn c_cfg(\n    attr: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    cfg::cfg(attr, item).into()\n}\n\n/// A powerful test macro for taos, you can replace std test macro in your taos test cases.\n///\n/// ## Use as [`[test]`](https://doc.rust-lang.org/std/prelude/v1/macro.test.html) does\n///\n/// ```rust\n/// use taos_macros::test;\n/// #[test]\n/// fn test1() {}\n/// ```\n///\n/// ## Use with taos connection.\n///\n/// ```rust\n/// use taos_macros::test;\n///\n/// #[test]\n/// async fn show_databases(taos: &Taos) -> Result<()> {\n///     let _ = taos.databases().await;\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Use with taos connection and a prebuilt database\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test]\n/// async fn use_database(taos: &Taos, database: &str) -> Result<()> {\n///     let databases = taos.databases().await?;\n///     assert!(databases.iter().any(|db| db.name == database));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Use with taos connection and a prebuilt database with specific precision\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(precision = \"ns\")]\n/// async fn with_precision(taos: &Taos, database: &str) -> Result<()> {\n///     let databases = taos.databases().await?;\n///     assert!(databases\n///         .iter()\n///         .any(|db| db.name == database && db.props.precision.as_ref().unwrap().eq(\"ns\")));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Specify a custom database name\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(naming = \"abc1\")]\n/// async fn custom_database(taos: &Taos, database: &str) -> Result<()> {\n///     let databases = taos.databases().await?;\n///     assert!(database == \"abc1\");\n///     assert!(databases.iter().any(|db| db.name == database));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Naming the database with random words\n///\n/// By default, `[test]` macro use [uuid v1](https://docs.rs/uuid/latest/uuid/struct.Uuid.html#method.new_v1)\n/// naming strategy. It will satisfy most cases. But if you want to use another naming strategy, you can use\n/// `\"random\"` to generate database names with [faker_rand](https://docs.rs/faker_rand).\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(naming = \"random\")]\n/// async fn random_naming(taos: &Taos, database: &str) -> Result<()> {\n///     let databases = taos.databases().await?;\n///     assert!(databases.iter().any(|db| db.name == database));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Generate many databases in one case\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(databases = 10)]\n/// async fn multi_databases(_taos: &Taos, databases: &[&str]) -> Result<()> {\n///     assert!(databases.len() == 10);\n///     Ok(())\n/// }\n/// ```\n///\n#[proc_macro_attribute]\npub fn test(\n    attr: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    test::test(attr, item)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","src","test.rs"],"content":"use proc_macro2::*;\nuse quote::*;\n\n#[derive(Debug, PartialEq, Eq)]\nenum Requires {\n    None,\n    TaosOnly,\n    WithDatabase,\n    WithMulti,\n}\n\nimpl Default for Requires {\n    fn default() -> Self {\n        Self::None\n    }\n}\n\n#[derive(Default, Debug, PartialEq, Eq)]\nstruct Params {\n    is_async: bool,\n    fn_name: String,\n    requires: Requires,\n    is_result: bool,\n}\n\nimpl Params {\n    fn from_tokens(item: TokenStream) -> Self {\n        // let item_fn: syn::ItemFn = match syn::parse(item.clone().into()) {\n        //     Ok(item) => item,\n        //     Err(e) => panic!(\"#[test] only used in function\"),\n        // };\n        // dbg!(item_fn);\n        let tokens: Vec<_> = item.into_iter().collect();\n        let mut iter = tokens.iter();\n\n        let mut params = Params::default();\n        while let Some(token) = iter.next() {\n            use TokenTree::*;\n            match token {\n                // Function comment\n                Punct(punct) if punct.as_char() == '#' => {\n                    let _ = iter.next();\n                }\n                // Check if is async function\n                Ident(ident) if ident.to_string() == \"async\" => {\n                    params.is_async = true;\n                }\n                // Parse function name and parameters\n                Ident(ident) if ident.to_string() == \"fn\" => {\n                    if let Some(Ident(ident)) = iter.next() {\n                        params.fn_name = ident.to_string();\n                    } else {\n                        panic!(\"can't parse fn name\");\n                    }\n\n                    if let Some(Group(fn_params)) = iter.next() {\n                        let tt: Vec<_> = fn_params.stream().into_iter().collect();\n                        params.requires = parse_database_requires(&tt);\n                    }\n                }\n                // Parse return type\n                Punct(punct) if punct.as_char() == '-' => {\n                    // >\n                    let _ = iter.next();\n                    let mut return_type_tt = Vec::new();\n                    if let Some(ident) = iter.next() {\n                        // dbg!(&ty);\n                        if let Ident(ty) = ident {\n                            if ty.to_string().ends_with(\"Result\") {\n                                params.is_result = true;\n                                break;\n                            }\n                        }\n                        return_type_tt.push(ident.clone());\n                    }\n\n                    while let Some(token) = iter.next() {\n                        if let Group(group) = token {\n                            let v = group.delimiter();\n                            if v == Delimiter::Brace {\n                                break;\n                            }\n                        }\n                        return_type_tt.push(token.clone());\n                    }\n\n                    params.is_result = return_type_tt.into_iter().any(|t| {\n                        if let Ident(ty) = t {\n                            ty.to_string().ends_with(\"Result\")\n                        } else {\n                            false\n                        }\n                    });\n                }\n                _ => {\n                    // dbg!(&token);\n                }\n            }\n        }\n        params\n    }\n}\n\n#[derive(Default, Debug)]\nstruct Attr {\n    rt: Option<String>,\n    databases: Option<usize>,\n    naming: Option<Literal>,\n    precision: Option<Literal>,\n    dropping: Option<Literal>,\n    log_level: Option<Literal>,\n}\n\nimpl PartialEq for Attr {\n    fn eq(&self, other: &Self) -> bool {\n        macro_rules! _literal_eq {\n            ($attr:ident) => {\n                match (self.$attr.as_ref(), other.$attr.as_ref()) {\n                    (None, None) => true,\n                    (Some(lhs), Some(rhs)) if lhs.to_string() == rhs.to_string() => true,\n                    _ => false,\n                }\n            };\n        }\n        self.rt == other.rt\n            && self.databases == other.databases\n            && _literal_eq!(naming)\n            && _literal_eq!(precision)\n            && _literal_eq!(dropping)\n    }\n}\n\nimpl Attr {\n    fn from_iter(iter: impl IntoIterator<Item = TokenTree>) -> Attr {\n        let mut iter = iter.into_iter();\n        let mut attr = Attr::default();\n        while let Some(t) = iter.next() {\n            // panic!(\"{}\", &t);\n            // dbg!(&t);\n            match t {\n                TokenTree::Ident(ident) if ident.to_string() == \"databases\" => {\n                    const EXPECT: &str = \"expect `[test(databases = \\\"\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) => {\n                            attr.databases = Some(value.to_string().parse().expect(EXPECT))\n                        }\n                        _ => unreachable!(\"expect `[test(databases = \\\"\\\")]`\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"rt\" => {\n                    const EXPECT: &str = \"`[test(rt = \\\"tokio|async_std\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) => attr.rt = Some(value.to_string()),\n                        _ => unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"naming\" => {\n                    const EXPECT: &str =\n                        \"`[test(naming = \\\"random|uuid-v1|sequential|<custom>\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) => attr.naming = Some(value.clone()),\n                        _ => unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"dropping\" => {\n                    const EXPECT: &str = \"`[test(drop = \\\"none|before|after|always\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) => attr.dropping = Some(value.clone()),\n                        _ => unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"precision\" => {\n                    const EXPECT: &str = \"`[test(drop = \\\"ms|us|ns|random|cyclic\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) => attr.precision = Some(value.clone()),\n                        _ => unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n\n                TokenTree::Ident(ident)\n                    if ident.to_string() == \"log_level\" || ident.to_string() == \"log-level\" =>\n                {\n                    const EXPECT: &str = \"`[test(log_level = \\\"trace|debug|info|warn|error\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) => attr.log_level = Some(value.clone()),\n                        _ => unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                _ => (),\n            }\n        }\n        attr\n    }\n\n    fn naming_token_stream(&self) -> TokenStream {\n        match &self.naming {\n            Some(naming) => naming.into_token_stream(),\n            None => quote!(()),\n        }\n    }\n\n    fn drop_token_stream(&self) -> TokenStream {\n        match &self.dropping {\n            Some(drop) => drop.into_token_stream(),\n            None => quote!(()),\n        }\n    }\n    fn precision_token_stream(&self) -> TokenStream {\n        match &self.precision {\n            Some(precision) => precision.into_token_stream(),\n            None => quote!(()),\n        }\n    }\n\n    fn crate_token_stream(&self) -> TokenStream {\n        let crate_name = std::env::var(\"CARGO_PKG_NAME\").unwrap();\n\n        if crate_name == \"taos\" {\n            quote!(crate)\n        } else {\n            quote!(taos)\n        }\n    }\n\n    fn databases(&self, requires: &Requires) -> usize {\n        match requires {\n            Requires::None => 0,\n            Requires::TaosOnly => 0,\n            Requires::WithDatabase => 1,\n            Requires::WithMulti => self.databases.unwrap_or(1),\n        }\n    }\n\n    fn log_level(&self) -> TokenStream {\n        match &self.log_level {\n            Some(log_level) => log_level.into_token_stream(),\n            None => quote!(()),\n        }\n    }\n\n    fn with_params(&self, tokens: TokenStream) -> TokenStream {\n        let Params {\n            is_async,\n            fn_name,\n            requires,\n            is_result,\n        } = Params::from_tokens(tokens.clone());\n\n        let fn_name = Ident::new(&fn_name, Span::call_site());\n        let naming = self.naming_token_stream();\n        let drop = self.drop_token_stream();\n        let precision = self.precision_token_stream();\n        let log_level = self.log_level();\n        let _crate = self.crate_token_stream();\n        let databases = self.databases(&requires);\n\n        let common = quote! {\n            #_crate::helpers::tests::Common::default()\n                .log_level(#log_level)\n                .init()?;\n        };\n\n        let builder = quote! {\n            let __taos = #_crate::helpers::tests::Builder::default()\n               .naming(#naming)\n               .precision(#precision)\n               .dropping(#drop)\n               .databases(#databases)\n               .build()?;\n            let _taos = __taos.taos();\n        };\n        let builder = match requires {\n            Requires::None => quote!(\n                #fn_name()\n            ),\n            Requires::TaosOnly => quote! {\n                #builder\n                #fn_name(_taos)\n            },\n            Requires::WithDatabase => quote! {\n                #builder\n                let _database = __taos.default_database();\n                #fn_name(_taos, _database)\n            },\n            Requires::WithMulti => quote! {\n                #builder\n                let _databases = __taos.databases();\n                #fn_name(_taos, &_databases)\n            },\n        };\n\n        match (is_async, is_result) {\n            (true, true) => {\n                quote! {\n                    #[tokio::test]\n                    async fn #fn_name() -> anyhow::Result<()> {\n                        #tokens\n                        #common\n                        #builder.await?;\n                        Ok(())\n                    }\n                }\n            }\n            (true, false) => {\n                quote! {\n                    #[tokio::test]\n                    async fn #fn_name() -> anyhow::Result<()> {\n                        #tokens\n                        #common\n                        #builder.await;\n                        Ok(())\n                    }\n                }\n            }\n            (false, true) => {\n                quote! {\n                    #[std::prelude::v1::test]\n                    fn #fn_name() -> anyhow::Result<()> {\n                        #tokens\n                        #common\n                        #builder?;\n                        Ok(())\n                    }\n                }\n            }\n            _ => {\n                quote! {\n                    #[std::prelude::v1::test]\n                    fn #fn_name() -> anyhow::Result<()> {\n                        #tokens\n                        #common\n                        #builder;\n                        Ok(())\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn parse_database_requires(params: &[TokenTree]) -> Requires {\n    let mut iter = params.iter();\n    let mut has_taos = false;\n    let mut ret = Requires::None;\n    while let Some(t) = iter.next() {\n        use TokenTree::*;\n        match t {\n            Ident(ident) if ident.to_string() == \"taos\" || ident.to_string() == \"_taos\" => {\n                let _ = iter.next();\n                let _ = iter.next();\n                let ty = iter.next().unwrap();\n                assert!(ty.to_string().ends_with(\"Taos\"));\n                has_taos = true;\n                ret = Requires::TaosOnly;\n            }\n            Ident(ident) if ident.to_string() == \"database\" || ident.to_string() == \"_database\" => {\n                if !has_taos {\n                    panic!(\"please use test fn parameters: `taos: &Taos, database: &str`\");\n                }\n                ret = Requires::WithDatabase;\n            }\n            Ident(ident)\n                if ident.to_string() == \"databases\" || ident.to_string() == \"_databases\" =>\n            {\n                if !has_taos {\n                    panic!(\"please use test fn parameters: `taos: &Taos, databases: &[String]`\");\n                }\n                ret = Requires::WithMulti;\n            }\n            _ => (),\n        }\n    }\n    ret\n}\npub(crate) fn test(\n    attr: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    Attr::from_iter(TokenStream::from(attr))\n        .with_params(TokenStream::from(item))\n        .into()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Attr;\n    use proc_macro2::*;\n    use quote::quote;\n\n    #[test]\n    fn default_sync() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            fn test_fn() { }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[std::prelude::v1::test]\n            fn test_fn() -> anyhow::Result<()> {\n                fn test_fn() { }\n\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                test_fn();\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn default_async() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            async fn async_simple() { }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[tokio::test]\n            async fn async_simple() -> anyhow::Result<()> {\n                async fn async_simple() { }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                async_simple().await;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn sync_with_result() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            fn test() -> Result<()> {\n                Ok(())\n            }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[std::prelude::v1::test]\n            fn test() -> anyhow::Result<()> {\n                fn test() -> Result<()> {\n                    Ok(())\n                }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                test()?;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn async_with_result() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            async fn test() -> Result<()> {\n                Ok(())\n            }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[tokio::test]\n            async fn test() -> anyhow::Result<()> {\n                async fn test() -> Result<()> {\n                    Ok(())\n                }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                test().await?;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n    #[test]\n    fn attr_from_iter() {\n        let attr = quote! {\n            databases = 10, rt = \"tokio\", naming = \"random\", dropping = \"always\"\n        };\n\n        let attr = super::Attr::from_iter(attr);\n\n        assert_eq!(\n            attr,\n            Attr {\n                databases: Some(10),\n                rt: Some(\"\\\"tokio\\\"\".to_string()),\n                naming: Some(Literal::string(\"random\")),\n                precision: None,\n                dropping: Some(Literal::string(\"always\")),\n                log_level: None,\n            }\n        );\n\n        let fn_item = quote! {\n            /// Comment.\n            ///\n            /// Long comment.\n            async fn test_a(taos: &Taos, database: &str) -> anyhow::Result<()> {\n                Ok(())\n            }\n        };\n        let params = super::Params::from_tokens(fn_item.clone().into());\n        dbg!(params);\n        let tokens = attr.with_params(fn_item);\n\n        let expect = quote! {\n            #[tokio::test]\n            async fn test_a() -> anyhow::Result<()> {\n                /// Comment.\n                ///\n                /// Long comment.\n                async fn test_a(taos: &Taos, database: &str) -> anyhow::Result<()> {\n                    Ok(())\n                }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                let __taos = taos::helpers::tests::Builder::default()\n                       .naming(\"random\")\n                       .precision(())\n                       .dropping(\"always\")\n                       .databases(1usize)\n                       .build()?;\n                let _taos = __taos.taos();\n                let _database = __taos.default_database();\n                test_a(_taos, _database).await?;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n        dbg!(tokens.to_string());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","tests","taos_cfg.rs"],"content":"use taos_macros::c_cfg;\n\n#[c_cfg(v3)]\nextern \"C\" {\n    fn test_cfg(_a: usize, _b: *mut usize);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","tests","test.rs"],"content":"use anyhow::Result;\nuse taos::prelude::*;\nuse taos_macros::test;\n\n#[test()]\nfn sync() {}\n\n#[test]\nasync fn async_unit() {}\n\n#[test]\nasync fn async_with_taos(taos: &Taos) {\n    dbg!(taos);\n}\n\n#[test]\nasync fn async_with_taos_db(_taos: &Taos, _database: &str) {}\n\n#[test]\nasync fn show_databases(taos: &Taos, database: &str) -> Result<()> {\n    let databases = taos.databases().await?;\n    assert!(databases.iter().any(|db| db.name == database));\n    Ok(())\n}\n\n#[test(precision = \"ns\")]\nasync fn with_precision(taos: &Taos, database: &str) -> Result<()> {\n    let databases = taos.databases().await?;\n    assert!(databases\n        .iter()\n        .any(|db| db.name == database && db.props.precision.as_ref().unwrap().as_str().eq(\"ns\")));\n    Ok(())\n}\n\n#[test(naming = \"abc1\")]\nasync fn custom_database(taos: &Taos, database: &str) -> Result<()> {\n    let databases = taos.databases().await?;\n    assert!(database == \"abc1\");\n    assert!(databases.iter().any(|db| db.name == database));\n    Ok(())\n}\n\n#[test(databases = 10)]\nasync fn multi_databases(_taos: &Taos, databases: &[&str]) -> Result<()> {\n    assert!(databases.len() == 10);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","build.rs"],"content":"fn main() {\n    if rustc_version::version_meta().unwrap().channel == rustc_version::Channel::Nightly {\n        println!(\"cargo:rustc-cfg=nightly\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","column","mod.rs"],"content":"use bitvec_simd::BitVec;\nuse itertools::Itertools;\n\n// use crate::stmt::MultiBind;\n\nuse super::value::BorrowedValue;\n\n#[derive(Debug, serde::Serialize)]\npub enum BorrowedColumn<'b> {\n    Null(usize),\n    Bool(BitVec, &'b [bool]),  // 1\n    TinyInt(BitVec, &'b [i8]), // 2\n    SmallInt(BitVec, &'b [i16]),\n    Int(BitVec, &'b [i32]),\n    BigInt(BitVec, &'b [i64]),\n    Float(BitVec, &'b [f32]),\n    Double(BitVec, &'b [f64]),\n    Binary(Vec<Option<&'b [u8]>>),\n    Timestamp(BitVec, &'b [i64]),\n    NChar(Vec<Option<&'b str>>),\n    UTinyInt(BitVec, &'b [u8]),\n    USmallInt(BitVec, &'b [u16]),\n    UInt(BitVec, &'b [u32]),\n    UBigInt(BitVec, &'b [u64]), // 14\n    Json(BitVec, &'b [u8]),\n    VarChar(BitVec, Vec<&'b [u8]>),\n    VarBinary(BitVec, Vec<&'b [u8]>),\n    Decimal(BitVec, &'b [f64]),\n    Blob(BitVec, Vec<&'b [u8]>),\n}\n\n#[derive(Debug, serde::Serialize, serde::Deserialize)]\npub enum Column {\n    Null(usize),\n    Bool(BitVec, Vec<bool>),  // 1\n    TinyInt(BitVec, Vec<i8>), // 2\n    SmallInt(BitVec, Vec<i16>),\n    Int(BitVec, Vec<i32>),\n    BigInt(BitVec, Vec<i64>),\n    Float(BitVec, Vec<f32>),\n    Double(BitVec, Vec<f64>),\n    Binary(Vec<Option<Vec<u8>>>),\n    Timestamp(BitVec, Vec<i64>),\n    NChar(Vec<Option<String>>),\n    UTinyInt(BitVec, Vec<u8>),\n    USmallInt(BitVec, Vec<u16>),\n    UInt(BitVec, Vec<u32>),\n    UBigInt(BitVec, Vec<u64>), // 14\n    Json(BitVec, Vec<u8>),\n    VarChar(BitVec, Vec<Vec<u8>>),\n    VarBinary(BitVec, Vec<Vec<u8>>),\n    Decimal(BitVec, Vec<f64>),\n    Blob(BitVec, Vec<Vec<u8>>),\n}\n\nimpl<'block> BorrowedColumn<'block> {\n    pub fn get(&self, index: usize) -> BorrowedValue<'block> {\n        macro_rules! get_primitive {\n            ($target:ident, $nulls:expr, $values:expr) => {\n                paste::paste! {\n                    if $nulls.get_unchecked(index) {\n                        BorrowedValue::Null\n                    } else {\n                        BorrowedValue::$target(*unsafe { $values.get_unchecked(index) })\n                    }\n                }\n            };\n        }\n        match self {\n            Self::Null(_n) => BorrowedValue::Null,\n            Self::Bool(nulls, values) => get_primitive!(Bool, nulls, values),\n            Self::TinyInt(nulls, values) => get_primitive!(TinyInt, nulls, values),\n            Self::SmallInt(nulls, values) => get_primitive!(SmallInt, nulls, values),\n            Self::Int(nulls, values) => get_primitive!(Int, nulls, values),\n            Self::BigInt(nulls, values) => get_primitive!(BigInt, nulls, values),\n            Self::UTinyInt(nulls, values) => get_primitive!(UTinyInt, nulls, values),\n            Self::USmallInt(nulls, values) => get_primitive!(USmallInt, nulls, values),\n            Self::UInt(nulls, values) => get_primitive!(UInt, nulls, values),\n            Self::UBigInt(nulls, values) => get_primitive!(UBigInt, nulls, values),\n            Self::Float(nulls, values) => get_primitive!(Float, nulls, values),\n            Self::Double(nulls, values) => get_primitive!(Double, nulls, values),\n            Self::Timestamp(nulls, _values) => {\n                if nulls.get_unchecked(index) {\n                    BorrowedValue::Null\n                } else {\n                    // BorrowedValue::Timestamp(TimestampValue::new(*unsafe { values.get_unchecked(index) }, self.precision()))\n                    todo!()\n                }\n            }\n            Self::Binary(values) => match unsafe { values.get_unchecked(index) } {\n                Some(bytes) => {\n                    BorrowedValue::VarChar(unsafe { std::str::from_utf8_unchecked(bytes) })\n                }\n                None => BorrowedValue::Null,\n            },\n            Self::NChar(_values) => BorrowedValue::Null,\n            _ => unreachable!(),\n        }\n    }\n}\n\nimpl<'block> BorrowedColumn<'block> {\n    pub fn into_owned(self) -> Column {\n        match self {\n            BorrowedColumn::Null(rows) => Column::Null(rows),\n            BorrowedColumn::Bool(is_nulls, slice) => Column::Bool(is_nulls, slice.to_owned()),\n            BorrowedColumn::TinyInt(is_nulls, slice) => Column::TinyInt(is_nulls, slice.to_owned()),\n            BorrowedColumn::SmallInt(is_nulls, slice) => {\n                Column::SmallInt(is_nulls, slice.to_owned())\n            }\n            BorrowedColumn::Int(is_nulls, slice) => Column::Int(is_nulls, slice.to_owned()),\n            BorrowedColumn::BigInt(is_nulls, slice) => Column::BigInt(is_nulls, slice.to_owned()),\n            BorrowedColumn::UTinyInt(is_nulls, slice) => {\n                Column::UTinyInt(is_nulls, slice.to_owned())\n            }\n            BorrowedColumn::USmallInt(is_nulls, slice) => {\n                Column::USmallInt(is_nulls, slice.to_owned())\n            }\n            BorrowedColumn::UInt(is_nulls, slice) => Column::UInt(is_nulls, slice.to_owned()),\n            BorrowedColumn::UBigInt(is_nulls, slice) => Column::UBigInt(is_nulls, slice.to_owned()),\n\n            BorrowedColumn::Float(is_nulls, slice) => Column::Float(is_nulls, slice.to_owned()),\n            BorrowedColumn::Double(is_nulls, slice) => Column::Double(is_nulls, slice.to_owned()),\n            BorrowedColumn::Binary(binary) => Column::Binary(\n                binary\n                    .into_iter()\n                    .map(|val| val.map(ToOwned::to_owned))\n                    .collect_vec(),\n            ),\n            BorrowedColumn::NChar(binary) => Column::NChar(\n                binary\n                    .into_iter()\n                    .map(|val| val.map(|val| val.to_string()))\n                    .collect_vec(),\n            ),\n            BorrowedColumn::Timestamp(is_nulls, slice) => {\n                Column::Timestamp(is_nulls, slice.to_owned())\n            }\n            _ => unreachable!(\"unsupported data type\"),\n        }\n    }\n}\n\n#[test]\nfn test_serde() {\n    const N: usize = 100;\n    let nulls = BitVec::zeros(N);\n    let v: Vec<i32> = (0..N).map(|_| rand::random()).collect();\n    let ints = BorrowedColumn::Int(nulls, &v);\n\n    let json = serde_json::to_string(&ints).unwrap();\n\n    let ints2: Column = serde_json::from_str(&json).unwrap();\n\n    println!(\"{ints:?}\");\n    println!(\"{ints2:?}\");\n}\n","traces":[{"line":57,"address":[2712096],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2712151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[2712238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[2712274,2714286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2712343,2714195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2712412,2714102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2714011,2712481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2713918,2712550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2712901,2713430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2712970,2713337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[2713039,2713252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[2713108,2713233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2712619,2713823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2713728,2712688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[2712804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2713521,2712831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2713565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2713597,2712749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2713654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[2713665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2713641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[2712865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[2719377,2717466,2714384],"length":1,"stats":{"Line":0},"fn_name":"into_owned"},{"line":104,"address":[2714429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2714752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[2719011,2714788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2714974,2718881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[2715160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2715298,2718751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2718621,2715346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[2718491,2715532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2716480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[2716618,2717767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2716666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2716792,2717637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[2716840,2717507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2716996,2717339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2715718,2718361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[2715904,2718231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2716122,2718145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2002976,2003029],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2717913,2716410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2003158,2003109,2003056,2003136],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2716192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[2716330,2717999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2034976,2034981],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":147,"address":[2729871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[2035008,2035022],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":149,"address":[2730025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[2730214,2730291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[2730405,2730329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[2730450,2730517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[2730601],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":8,"coverable":63},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","describe.rs"],"content":"use std::ops::{Deref, DerefMut};\n\nuse itertools::Itertools;\nuse serde::{Deserialize, Serialize};\n\nuse crate::helpers::ColumnMeta;\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Describe(pub(crate) Vec<ColumnMeta>);\n\nimpl IntoIterator for Describe {\n    type Item = ColumnMeta;\n\n    type IntoIter = std::vec::IntoIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\nimpl FromIterator<ColumnMeta> for Describe {\n    fn from_iter<T: IntoIterator<Item = ColumnMeta>>(iter: T) -> Self {\n        Describe(iter.into_iter().collect())\n    }\n}\n\nimpl Deref for Describe {\n    type Target = Vec<ColumnMeta>;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl DerefMut for Describe {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\nimpl Describe {\n    #[inline]\n    fn fields(&self) -> &[ColumnMeta] {\n        &self.0\n    }\n    pub fn is_stable(&self) -> bool {\n        self.fields().iter().any(|f| f.is_tag())\n    }\n    pub fn names(&self) -> impl Iterator<Item = &str> {\n        self.fields().iter().map(|f| f.field())\n    }\n\n    pub fn tag_names(&self) -> impl Iterator<Item = &str> {\n        self.fields()\n            .iter()\n            .filter(|f| f.is_tag())\n            .map(|f| f.field())\n    }\n    pub fn to_create_table_sql(&self, table: &str) -> String {\n        let (cols, tags): (Vec<_>, Vec<_>) = self.fields().iter().partition(|f| !f.is_tag());\n        let col_sql = cols.into_iter().map(|f| f.sql_repr()).join(\",\");\n\n        if tags.is_empty() {\n            format!(\"create table if not exists {table} ({col_sql})\")\n        } else {\n            let tags_sql = tags.into_iter().map(|f| f.sql_repr()).join(\",\");\n            format!(\"create table if not exists {table} ({col_sql}) tags({tags_sql})\")\n        }\n    }\n}\n","traces":[{"line":16,"address":[8430160],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":17,"address":[8430172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[8430224],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":36,"address":[8430240],"length":1,"stats":{"Line":0},"fn_name":"deref_mut"},{"line":42,"address":[8430256],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":43,"address":[2276393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[8430304],"length":1,"stats":{"Line":0},"fn_name":"is_stable"},{"line":46,"address":[2824160,2824187],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":48,"address":[2276512],"length":1,"stats":{"Line":0},"fn_name":"names"},{"line":49,"address":[2276521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[8430496],"length":1,"stats":{"Line":0},"fn_name":"tag_names"},{"line":53,"address":[2276617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[2278183,2276720,2277183],"length":1,"stats":{"Line":0},"fn_name":"to_create_table_sql"},{"line":59,"address":[2824224,2824238],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":60,"address":[8430983,8430875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2277246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2277339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[2277273,2277614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[2277755],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","field.rs"],"content":"use std::fmt::{Debug, Display};\n\nuse crate::util::{Inlinable, InlinableRead, InlinableWrite};\n\nuse super::ty::Ty;\n\n/// A `Field` represents the name and data type of one column or tag.\n///\n/// For example, a table as \"create table tb1 (ts timestamp, n nchar(100))\".\n///\n/// When query with \"select * from tb1\", you will get two fields:\n///\n/// 1. `{ name: \"ts\", ty: Timestamp, bytes: 8 }`, a `TIMESTAMP` field with name `ts`,\n///    bytes length 8 which is the byte-width of `i64`.\n/// 2. `{ name: \"n\", ty: NChar, bytes: 100 }`, a `NCHAR` filed with name `n`,\n///    bytes length 100 which is the length of the variable-length data.\n\n#[derive(Debug)]\npub struct Field {\n    name: String,\n    ty: Ty,\n    bytes: u32,\n}\n\nimpl Inlinable for Field {\n    fn write_inlined<W: std::io::Write>(&self, mut wtr: W) -> std::io::Result<usize> {\n        let mut l = wtr.write_u8(self.ty as u8)?;\n        l += wtr.write_u32(self.bytes)?;\n        l += wtr.write_inlined_str::<2>(&self.name)?;\n        Ok(l)\n    }\n\n    fn read_inlined<R: std::io::Read>(mut reader: R) -> std::io::Result<Self> {\n        let ty = Ty::from(reader.read_u8()?);\n        let bytes = reader.read_u32()?;\n        let name = reader.read_inlined_str::<2>()?;\n        Ok(Self { name, ty, bytes })\n    }\n}\n\nimpl Field {\n    pub fn new(name: impl Into<String>, ty: Ty, bytes: u32) -> Self {\n        let name = name.into();\n        Self { name, ty, bytes }\n    }\n\n    /// Field name.\n    pub fn name(&self) -> &str {\n        &self.name\n    }\n\n    /// Data type of the field.\n    pub const fn ty(&self) -> Ty {\n        self.ty\n    }\n\n    /// Preset length of variable length data type.\n    ///\n    /// It's the byte-width in other types.\n    pub const fn bytes(&self) -> u32 {\n        self.bytes\n    }\n\n    /// Represent the data type in sql.\n    ///\n    /// For example: \"INT\", \"VARCHAR(100)\".\n    pub fn sql_repr(&self) -> String {\n        let ty = self.ty();\n        if ty.is_var_type() {\n            format!(\"{}({})\", ty.name(), self.bytes())\n        } else {\n            ty.name().to_string()\n        }\n    }\n}\n\nimpl Display for Field {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let ty = self.ty();\n        if ty.is_var_type() {\n            write!(f, \"({}: {}({}))\", self.name(), ty.name(), self.bytes())\n        } else {\n            write!(f, \"({}: {})\", self.name(), ty.name())\n        }\n    }\n}\n","traces":[{"line":26,"address":[3239260,3239980,3238560,3239280],"length":1,"stats":{"Line":0},"fn_name":"write_inlined<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":27,"address":[3238595,3238730,3239362,3239315,3239450,3238642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3238702,3238967,3238945,3239422,3239687,3239515,3239665,3238795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[3239924,3238950,3239227,3239204,3239742,3239670,3239022,3239947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[3239929,3239209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[3240000,3240723],"length":1,"stats":{"Line":0},"fn_name":"read_inlined<&mut &[u8]>"},{"line":34,"address":[3240076,3240191,3240032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[3240208,3240294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3240282,3240661,3240369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3240498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3240752],"length":1,"stats":{"Line":2},"fn_name":"new<&str>"},{"line":43,"address":[8094800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[2085200],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":49,"address":[2085209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[2085248],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":54,"address":[2085253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[8158624],"length":1,"stats":{"Line":0},"fn_name":"bytes"},{"line":61,"address":[8158629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[2085280],"length":1,"stats":{"Line":0},"fn_name":"sql_repr"},{"line":68,"address":[2085318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2085327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[2085381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2085629,2085351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[2085648],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":79,"address":[2085681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2085693,2086290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2085756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2086077,2085725],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":28},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","itypes.rs"],"content":"use std::{fmt::Display, ops::Deref};\n\nuse derive_more::{Deref, DerefMut, Display, From};\n\nuse rust_decimal::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value as Json;\n\nuse super::{Column, Ty, Value};\n\npub type INull = ();\npub type IBool = bool;\npub type ITinyInt = i8;\npub type ISmallInt = i16;\npub type IInt = i32;\npub type IBigInt = i64;\npub type IUTinyInt = u8;\npub type IUSmallInt = u16;\npub type IUInt = u32;\npub type IUBigInt = u64;\npub type IFloat = f32;\npub type IDouble = f64;\npub type IJson = Json;\npub type IDecimal = Decimal;\n\n#[derive(Debug, Clone, Copy, Deref, DerefMut, Deserialize, Serialize, Display, From)]\npub struct ITimestamp(pub i64);\n\n#[derive(Debug, Deref, DerefMut, Clone, Deserialize, Serialize)]\npub struct IVarChar(String);\n\n/// Alias of [IVarChar].\npub type IBinary = IVarChar;\n\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct INChar(String);\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct IVarBinary(Vec<u8>);\n\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct IMediumBlob(Vec<u8>);\n\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct IBlob(Vec<u8>);\n\nimpl From<String> for IVarChar {\n    fn from(v: String) -> Self {\n        Self(v)\n    }\n}\nimpl From<&str> for IVarChar {\n    fn from(v: &str) -> Self {\n        Self(v.to_string())\n    }\n}\n\nimpl IVarChar {\n    pub const fn new() -> Self {\n        Self(String::new())\n    }\n    pub fn with_capacity(cap: usize) -> Self {\n        Self(String::with_capacity(cap))\n    }\n}\npub trait IsValue: Sized {\n    const TY: Ty;\n\n    fn is_null(&self) -> bool {\n        false\n    }\n\n    fn is_primitive(&self) -> bool {\n        std::mem::size_of::<Self>() == Self::TY.fixed_length()\n    }\n\n    fn as_timestamp(&self) -> i64 {\n        debug_assert!(Self::TY == Ty::Timestamp);\n        unimplemented!()\n    }\n\n    fn as_var_char(&self) -> &str {\n        debug_assert!(Self::TY == Ty::VarChar);\n        unimplemented!()\n    }\n\n    fn as_nchar(&self) -> &str {\n        debug_assert!(Self::TY == Ty::NChar);\n        unimplemented!()\n    }\n\n    fn as_medium_blob(&self) -> &[u8] {\n        debug_assert!(Self::TY == Ty::MediumBlob);\n        unimplemented!()\n    }\n\n    fn as_blob(&self) -> &[u8] {\n        debug_assert!(Self::TY == Ty::Blob);\n        unimplemented!()\n    }\n}\n\nimpl<T> IsValue for Option<T>\nwhere\n    T: IsValue,\n{\n    const TY: Ty = T::TY;\n\n    fn is_null(&self) -> bool {\n        self.is_none()\n    }\n\n    fn is_primitive(&self) -> bool {\n        self.as_ref().unwrap().is_primitive()\n    }\n\n    fn as_timestamp(&self) -> i64 {\n        self.as_ref().unwrap().as_timestamp()\n    }\n\n    fn as_var_char(&self) -> &str {\n        self.as_ref().unwrap().as_var_char()\n    }\n    fn as_nchar(&self) -> &str {\n        self.as_ref().unwrap().as_nchar()\n    }\n    fn as_medium_blob(&self) -> &[u8] {\n        self.as_ref().unwrap().as_medium_blob()\n    }\n    fn as_blob(&self) -> &[u8] {\n        self.as_ref().unwrap().as_blob()\n    }\n}\n\npub trait IValue: Sized {\n    const TY: Ty;\n\n    type Inner: Sized;\n\n    fn is_null(&self) -> bool {\n        false\n    }\n\n    fn into_value(self) -> Value;\n\n    fn into_inner(self) -> Self::Inner;\n}\n\nimpl IValue for INull {\n    const TY: Ty = Ty::Null;\n\n    fn is_null(&self) -> bool {\n        true\n    }\n    fn into_value(self) -> Value {\n        Value::Null\n    }\n\n    type Inner = ();\n\n    fn into_inner(self) -> Self::Inner {\n        ()\n    }\n}\n\n/// Primitive type to TDengine data type.\nmacro_rules! impl_prim {\n    ($($ty:ident = $inner:ty)*) => {\n        $(paste::paste! {\n            impl IValue for [<I $ty>] {\n                const TY: Ty = Ty::$ty;\n                type Inner = $inner;\n\n                #[inline]\n                fn is_null(&self) -> bool {\n                    false\n                }\n\n                #[inline]\n                fn into_value(self) -> Value {\n                    Value::$ty(self)\n                }\n\n                #[inline]\n                fn into_inner(self) -> Self::Inner {\n                    self\n                }\n            }\n        })*\n    };\n}\n\nimpl_prim!(\n    Bool = bool\n    TinyInt = i8\n    SmallInt =  i16\n    Int = i32\n    BigInt = i64\n    UTinyInt = u8\n    USmallInt = u16\n    UInt = u32\n    UBigInt = u64\n    Float = f32\n    Double = f64\n    Decimal = Decimal\n    Json = Json\n);\n\npub trait IsPrimitive: Copy {\n    const TY: Ty;\n    fn is_primitive(&self) -> bool {\n        std::mem::size_of::<Self>() == Self::TY.fixed_length()\n    }\n}\n\nmacro_rules! impl_is_primitive {\n    ($($ty:ident) *) => {\n        $(paste::paste! {\n            impl IsPrimitive for [<I $ty>] {\n                const TY: Ty = Ty::$ty;\n            }\n            impl IsValue for [<I $ty>] {\n                const TY: Ty = Ty::$ty;\n            }\n        })*\n    };\n}\n\nimpl_is_primitive!(\n    Bool TinyInt SmallInt Int BigInt\n    UTinyInt USmallInt UInt UBigInt\n    Float Double Decimal\n);\n\nimpl IsValue for ITimestamp {\n    const TY: Ty = Ty::Timestamp;\n\n    #[inline]\n    fn as_timestamp(&self) -> i64 {\n        self.0\n    }\n}\n\nimpl IsValue for IVarChar {\n    const TY: Ty = Ty::VarChar;\n\n    #[inline]\n    fn as_var_char(&self) -> &str {\n        &self\n    }\n}\n\nimpl IsValue for INChar {\n    const TY: Ty = Ty::NChar;\n\n    #[inline]\n    fn as_nchar(&self) -> &str {\n        &self\n    }\n}\n\npub trait IsVarChar {\n    fn as_var_char(&self) -> &str;\n}\n\nimpl IsVarChar for IVarChar {\n    fn as_var_char(&self) -> &str {\n        &self\n    }\n}\n\npub trait IsNChar {\n    fn as_nchar(&self) -> &str;\n}\n\nimpl IsNChar for INChar {\n    fn as_nchar(&self) -> &str {\n        &self\n    }\n}\n\npub trait IsJson {\n    fn to_json(&self) -> String;\n}\n\nimpl IsJson for IJson {\n    fn to_json(&self) -> String {\n        self.to_string()\n    }\n}\n\npub trait IsMediumBlob {\n    fn as_medium_blob(&self) -> &[u8];\n}\n\nimpl IsMediumBlob for IMediumBlob {\n    fn as_medium_blob(&self) -> &[u8] {\n        &self\n    }\n}\n\npub trait IsBlob {\n    fn as_blob(&self) -> &[u8];\n}\n\nimpl IsBlob for IBlob {\n    fn as_blob(&self) -> &[u8] {\n        &self\n    }\n}\n\nimpl IValue for ITimestamp {\n    const TY: Ty = Ty::Timestamp;\n\n    type Inner = i64;\n\n    fn into_value(self) -> Value {\n        todo!()\n    }\n\n    fn into_inner(self) -> Self::Inner {\n        self.0\n    }\n}\n\nmacro_rules! impl_wrapper_struct {\n    ($($ty:ident)*) => {\n        $(paste::paste! {\n            impl IValue for [<I $ty>] {\n                const TY: Ty = Ty::$ty;\n                #[inline]\n                fn into_value(self) -> Value {\n                    Value::$ty(self.0)\n                }\n            }\n        })*\n    };\n    ($($ty:ident, $inner:ty;)*) => {\n        $(paste::paste! {\n            #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Deserialize, Serialize)]\n            pub struct [<I $ty>]($inner);\n\n            impl Deref for [<I $ty>] {\n                type Target = $inner;\n\n                #[inline]\n                fn deref(&self) -> &Self::Target {\n                        &self.0\n                }\n            }\n\n            impl IValue for [<I $ty>] {\n                const TY: Ty = Ty::$ty;\n                #[inline]\n                fn into_value(self) -> Value {\n                    Value::$ty(self.0)\n                }\n            }\n        })*\n    };\n}\n","traces":[{"line":47,"address":[2815888],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":48,"address":[2815895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2815952],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":53,"address":[2815975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[2816032],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":59,"address":[2816045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[2816096],"length":1,"stats":{"Line":0},"fn_name":"with_capacity"},{"line":62,"address":[2816115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[2392336],"length":1,"stats":{"Line":0},"fn_name":"is_null<rust_decimal::decimal::Decimal>"},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2392352],"length":1,"stats":{"Line":0},"fn_name":"is_primitive<rust_decimal::decimal::Decimal>"},{"line":73,"address":[2392361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2470784,2470560,2471344,2471456,2470448,2471120,2471680,2471568,2470672,2471008,2470336,2471232,2470896],"length":1,"stats":{"Line":0},"fn_name":"as_timestamp<i16>"},{"line":77,"address":[2470569,2470793,2471528,2471017,2470520,2471304,2471640,2471465,2470632,2470968,2471353,2470457,2471689,2470408,2471752,2471241,2471416,2471129,2471577,2470905,2471080,2471192,2470856,2470744,2470681,2470345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2472016,2471792,2472128,2472688,2472800,2472240,2472912,2471904,2472352,2473136,2472464,2472576,2473024],"length":1,"stats":{"Line":0},"fn_name":"as_var_char<i16>"},{"line":82,"address":[2471864,2472424,2471913,2472312,2472872,2473033,2472809,2471976,2473208,2472361,2472648,2473145,2472921,2472200,2472697,2472984,2473096,2472585,2472088,2471801,2472137,2472249,2472760,2472473,2472025,2472536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[2473696,2473584,2474368,2474256,2473920,2474144,2474480,2474592,2474032,2473472,2473360,2473808,2473248],"length":1,"stats":{"Line":0},"fn_name":"as_nchar<u8>"},{"line":87,"address":[2473593,2474601,2474216,2474440,2474265,2473544,2473880,2473768,2473320,2474041,2474377,2474489,2474552,2474664,2473369,2473705,2473656,2473817,2473929,2474328,2474153,2473992,2473481,2473257,2473432,2474104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2474816,2474928,2475040,2475936,2476048,2475264,2476160,2475600,2475488,2475376,2475824,2475712,2475152,2474704],"length":1,"stats":{"Line":0},"fn_name":"as_medium_blob<u8>"},{"line":92,"address":[2392761,2392824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[2392864],"length":1,"stats":{"Line":0},"fn_name":"as_blob<rust_decimal::decimal::Decimal>"},{"line":97,"address":[2392873,2392936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2477840],"length":1,"stats":{"Line":0},"fn_name":"is_null<taos_query::common::itypes::ITimestamp>"},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[2816176],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":154,"address":[2816192],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":155,"address":[2816196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[2816208],"length":1,"stats":{"Line":0},"fn_name":"into_inner"},{"line":174,"address":[2171264],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":179,"address":[2171280],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":180,"address":[2171287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2171376],"length":1,"stats":{"Line":0},"fn_name":"into_inner"},{"line":185,"address":[2171379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2392976],"length":1,"stats":{"Line":0},"fn_name":"is_primitive<rust_decimal::decimal::Decimal>"},{"line":211,"address":[2392985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[2816224],"length":1,"stats":{"Line":0},"fn_name":"as_timestamp"},{"line":239,"address":[2816229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2816240],"length":1,"stats":{"Line":0},"fn_name":"as_var_char"},{"line":248,"address":[2816249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2816304],"length":1,"stats":{"Line":0},"fn_name":"as_nchar"},{"line":257,"address":[2816313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[2816368],"length":1,"stats":{"Line":0},"fn_name":"as_var_char"},{"line":267,"address":[2816377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2816432],"length":1,"stats":{"Line":0},"fn_name":"as_nchar"},{"line":277,"address":[2816441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2171216],"length":1,"stats":{"Line":0},"fn_name":"to_json"},{"line":287,"address":[2171233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[2816496],"length":1,"stats":{"Line":0},"fn_name":"as_medium_blob"},{"line":297,"address":[2816505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[2816560],"length":1,"stats":{"Line":0},"fn_name":"as_blob"},{"line":307,"address":[2816569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[2816624],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":320,"address":[2816672],"length":1,"stats":{"Line":0},"fn_name":"into_inner"}],"covered":0,"coverable":67},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","mod.rs"],"content":"mod column;\nmod describe;\nmod field;\nmod opts;\nmod precision;\nmod raw;\nmod timestamp;\nmod ty;\nmod value;\n\npub use column::*;\npub use describe::*;\npub use field::*;\npub use opts::*;\npub use precision::*;\npub use raw::*;\npub use timestamp::*;\npub use ty::*;\npub use value::*;\n\npub mod itypes;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","opts.rs"],"content":"use std::collections::BTreeMap;\n\nuse mdsn::Dsn;\n// use url::ParseError;\nuse mdsn::DsnError as Error;\n\n#[derive(Debug, Default, PartialEq, Eq)]\npub struct TaosOpts {\n    pub host: Option<String>,\n    pub port: Option<u16>,\n    pub username: Option<String>,\n    pub password: Option<String>,\n    pub database: Option<String>,\n    pub params: BTreeMap<String, String>,\n}\n\nmacro_rules! _build_opt {\n    ($option:ident, $($doc:literal) *) => {\n        $(#[doc = $doc])*\n        pub fn $option<T: Into<String>>(mut self, $option: T) -> Self {\n            self.$option = Some($option.into());\n            self\n        }\n    };\n    ($option:ident, $ty:ty, $($doc:literal) *) => {\n        $(#[doc = $doc])*\n        pub fn $option<T: Into<$ty>>(mut self, $option: T) -> Self {\n            self.$option = Some($option.into());\n            self\n        }\n    };\n}\n\nimpl TaosOpts {\n    /// Default to [Default::default].\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    pub fn to_dsn_string(&self) -> String {\n        todo!()\n    }\n\n    /// Parse from a [DSN](https://en.wikipedia.org/wiki/Data_source_name) string.\n    ///\n    /// We use URL-described DSN style like this:\n    ///\n    /// ```text\n    /// <driver>[+<protocol>]://<username>:<password>@<host>:<port>[,<host2>:<port2>]/<database>?<params>\n    /// ```\n    ///\n    /// - **driver**: to distinct from other data source, for TDengine, always use `taos`.\n    /// - **protocol**: additional information for connection, for TDengine, we have a plan to support\n    ///     taosc(the default protocol), http and websocket(with protocol identifier: `ws`).\n    /// - **username**: username for the connection\n    /// - **password**: password for the current user.\n    /// - **host**: host to TDengine server.\n    /// - **port**: port to TDengine server.\n    /// - **database**: default database for the connection, so that you don't need to write with full\n    ///     database name in sql like `select * from database.tb1`.\n    /// - **params**: in-query parameters are key-value pairs, drivers should be aware of the params list\n    ///     to support specific configuration for each driver or protocol.\n    ///\n    pub fn parse(dsn: &str) -> Result<TaosOpts, Error> {\n        if dsn.is_empty() {\n            return Ok(Self::new());\n        }\n        let _ = Dsn::parse(dsn)?;\n\n        Ok(Self::default())\n    }\n\n    _build_opt!(host, \"Set host name or ip address of TDengine server\");\n    _build_opt!(username, \"Set default username for TDengine connection\");\n    _build_opt!(password, \"Set default password for TDengine connection\");\n    _build_opt!(database, \"Set default database name of the connection\");\n    _build_opt!(port, u16, \"Set port to the TDengine server\");\n\n    /// Set other params by k-v pair.\n    pub fn with<K: Into<String>, V: Into<String>>(\n        mut self,\n        iter: impl Iterator<Item = (K, V)>,\n    ) -> Self {\n        for (k, v) in iter {\n            self.set(k, v);\n        }\n        self\n    }\n\n    fn set(&mut self, key: impl Into<String>, value: impl Into<String>) -> &mut Self {\n        self.params.insert(key.into(), value.into());\n        self\n    }\n}\n\n#[test]\nfn test_options() {\n    let opts = TaosOpts::parse(\"postgresql://root:pass@tcp(host1:123,host2:456)/somedb?target_session_attrs=any&application_name=myapp\");\n    dbg!(opts);\n}\n\n#[test]\nfn test_options_builder_all() {\n    let opts = TaosOpts::new()\n        .host(\"localhost\")\n        .port(6030u16)\n        .username(\"root\")\n        .password(\"taosdata\");\n\n    assert_eq!(\n        opts,\n        TaosOpts {\n            host: Some(\"localhost\".to_string()),\n            port: Some(6030),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            database: None,\n            params: Default::default(),\n        },\n        \"builder pattern for TaosOpts\"\n    );\n}\n","traces":[{"line":20,"address":[2703301,2702464,2703040,2702752,2703013,2702719],"length":1,"stats":{"Line":3},"fn_name":"host<&str>"},{"line":21,"address":[2702810,2702577,2702865,2703153,2702522,2703098],"length":1,"stats":{"Line":6},"fn_name":null},{"line":22,"address":[2702990,2703278,2702696],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[2703460,2703328],"length":1,"stats":{"Line":1},"fn_name":"port<u16>"},{"line":28,"address":[2703410,2703354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[2703440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[3281664],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":37,"address":[3281672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[3281696],"length":1,"stats":{"Line":0},"fn_name":"to_dsn_string"},{"line":64,"address":[3281744],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":65,"address":[3281801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[3281845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3281904,3281829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[3282103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2703488,2703493],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":98,"address":[3284167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[3284225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[2703525,2703520],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":104,"address":[3284839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[3285565,3285683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[3285368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[3285038,3284974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[3285070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[3285161,3285090],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[3285193,3285261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[3285293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[3285305],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":30},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","precision.rs"],"content":"use std::{\n    fmt::{self, Display},\n    str::FromStr,\n};\n\nuse serde::Deserialize;\n\n#[derive(Debug, thiserror::Error)]\npub enum PrecisionError {\n    #[error(\"invalid precision repr: {0}\")]\n    Invalid(String),\n}\n\n/// The precision of a timestamp or a database.\n#[repr(i32)]\n#[derive(Debug, Copy, Clone, PartialEq, Eq, serde_repr::Serialize_repr)]\npub enum Precision {\n    Millisecond = 0,\n    Microsecond,\n    Nanosecond,\n}\n\nimpl PartialEq<str> for Precision {\n    fn eq(&self, other: &str) -> bool {\n        self.as_str() == other\n    }\n}\n\nimpl PartialEq<&str> for Precision {\n    fn eq(&self, other: &&str) -> bool {\n        self.as_str() == *other\n    }\n}\n\nimpl Precision {\n    pub const fn as_str(&self) -> &'static str {\n        use Precision::*;\n        match self {\n            Millisecond => \"ms\",\n            Microsecond => \"us\",\n            Nanosecond => \"ns\",\n        }\n    }\n\n    pub const fn as_u8(&self) -> u8 {\n        match self {\n            Self::Millisecond => 0,\n            Self::Microsecond => 1,\n            Self::Nanosecond => 2,\n        }\n    }\n    pub const fn from_u8(precision: u8) -> Self {\n        match precision {\n            0 => Self::Millisecond,\n            1 => Self::Microsecond,\n            2 => Self::Nanosecond,\n            _ => panic!(\"precision integer only allow 0/1/2\"),\n        }\n    }\n}\n\nmacro_rules! _impl_from {\n    ($($ty:ty) *) => {\n        $(impl From<$ty> for Precision {\n            fn from(v: $ty) -> Self {\n                Self::from_u8(v as _)\n            }\n        })*\n    }\n}\n\n_impl_from!(i8 i16 i32 i64 isize u8 u16 u32 u64 usize);\n\nimpl Display for Precision {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl FromStr for Precision {\n    type Err = PrecisionError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"ms\" => Ok(Precision::Millisecond),\n            \"us\" => Ok(Precision::Microsecond),\n            \"ns\" => Ok(Precision::Nanosecond),\n            s => Err(PrecisionError::Invalid(s.to_string())),\n        }\n    }\n}\n\nimpl<'de> Deserialize<'de> for Precision {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        struct PrecisionVisitor;\n\n        impl<'de> serde::de::Visitor<'de> for PrecisionVisitor {\n            type Value = Precision;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"expect integer 0/1/2 or string ms/us/ns\")\n            }\n\n            fn visit_i8<E>(self, v: i8) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n            fn visit_i16<E>(self, v: i16) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_i32<E>(self, v: i32) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Precision::try_from(v).map_err(<E as serde::de::Error>::custom)\n            }\n\n            fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u8<E>(self, v: u8) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u16<E>(self, v: u16) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u32<E>(self, v: u32) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Precision::from_str(v).map_err(<E as serde::de::Error>::custom)\n            }\n\n            fn visit_none<E>(self) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Precision::Millisecond)\n            }\n\n            fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,\n            {\n                deserializer.deserialize_any(self)\n            }\n\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Precision::Millisecond)\n            }\n        }\n\n        deserializer.deserialize_any(PrecisionVisitor)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{\n        de::{\n            value::{I32Deserializer, StrDeserializer, UnitDeserializer},\n            IntoDeserializer,\n        },\n        Deserialize,\n    };\n\n    use super::Precision;\n\n    #[test]\n    fn de() {\n        type SD<'a> = StrDeserializer<'a, serde::de::value::Error>;\n        let precision = Precision::deserialize::<SD>(\"ms\".into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Millisecond);\n        let precision = Precision::deserialize::<SD>(\"us\".into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Microsecond);\n        let precision = Precision::deserialize::<SD>(\"ns\".into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Nanosecond);\n\n        type I32D = I32Deserializer<serde::de::value::Error>;\n        let precision = Precision::deserialize::<I32D>(0.into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Millisecond);\n        let precision = Precision::deserialize::<I32D>(1.into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Microsecond);\n        let precision = Precision::deserialize::<I32D>(2.into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Nanosecond);\n\n        type UnitD = UnitDeserializer<serde::de::value::Error>;\n        let precision = Precision::deserialize::<UnitD>(().into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Millisecond);\n\n        let json = serde_json::to_string(&precision).unwrap();\n        assert_eq!(json, \"0\");\n    }\n}\n","traces":[{"line":24,"address":[2833600],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":25,"address":[2833619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2833680],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":31,"address":[2833699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[2833760],"length":1,"stats":{"Line":1},"fn_name":"as_str"},{"line":38,"address":[2833769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2833796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2833819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[2833842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2833888],"length":1,"stats":{"Line":0},"fn_name":"as_u8"},{"line":46,"address":[2833897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2833922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[2833929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2833936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2833952],"length":1,"stats":{"Line":1},"fn_name":"from_u8"},{"line":53,"address":[2833967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2834029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2834039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[2834049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[2834059,2833993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[2835504,2835280,2835344,2835392,2835440,2835536,2835472,2835584,2835312,2835248],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":66,"address":[2835545,2835448,2835481,2835509,2835256,2835593,2835289,2835401,2835317,2835353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[2834096],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":76,"address":[2834118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2834256],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":85,"address":[2834378,2834309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[2834452,2834350,2834408],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[2834517,2834471,2834424],"length":1,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[2834487,2834540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2891632,2891664,2891696,2891744],"length":1,"stats":{"Line":3},"fn_name":"deserialize<serde::de::value::UnitDeserializer<serde::de::value::Error>>"},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[2834608],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":104,"address":[2834635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2891824],"length":1,"stats":{"Line":0},"fn_name":"visit_i8<serde::de::value::Error>"},{"line":111,"address":[2891843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2891872],"length":1,"stats":{"Line":0},"fn_name":"visit_i16<serde::de::value::Error>"},{"line":117,"address":[2891892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2891920],"length":1,"stats":{"Line":1},"fn_name":"visit_i32<serde::de::value::Error>"},{"line":124,"address":[2891949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[2891984],"length":1,"stats":{"Line":0},"fn_name":"visit_i64<serde::de::value::Error>"},{"line":131,"address":[2892000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2892016],"length":1,"stats":{"Line":0},"fn_name":"visit_u8<serde::de::value::Error>"},{"line":138,"address":[2892035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[2892064],"length":1,"stats":{"Line":0},"fn_name":"visit_u16<serde::de::value::Error>"},{"line":145,"address":[2892084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2892112],"length":1,"stats":{"Line":0},"fn_name":"visit_u32<serde::de::value::Error>"},{"line":152,"address":[2892128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[2892144],"length":1,"stats":{"Line":0},"fn_name":"visit_u64<serde::de::value::Error>"},{"line":159,"address":[2892160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2892176],"length":1,"stats":{"Line":1},"fn_name":"visit_str<serde::de::value::Error>"},{"line":166,"address":[2892199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[2892240],"length":1,"stats":{"Line":0},"fn_name":"visit_none<serde::de::value::Error>"},{"line":173,"address":[2892247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[2892288],"length":1,"stats":{"Line":0},"fn_name":"visit_some<serde::__private::de::content::ContentDeserializer<serde::de::value::Error>>"},{"line":180,"address":[2892300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2892368],"length":1,"stats":{"Line":1},"fn_name":"visit_unit<serde::de::value::Error>"},{"line":187,"address":[2892375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[2891680,2891717,2891644,2891755],"length":1,"stats":{"Line":3},"fn_name":null},{"line":208,"address":[2815861,2815856],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":210,"address":[2835639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[2835885,2835729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[2835833,2835945],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[2836141,2835985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[2836201,2836089],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[2836241,2836368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[2836342,2836416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[2836456,2836574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[2836548,2836622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[2836780,2836662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[2836828,2836754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[2836977,2836868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[2836960,2837021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[2837186,2837061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[2837153,2837230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[2837417,2837266,2837386],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":41,"coverable":76},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","raw","inner.rs"],"content":"use crate::{\n    common::{Column, Field, Precision, Timestamp, Ty, Value},\n    util::{Inlinable, InlinableRead, InlinableWrite},\n    BlockExt,\n};\nuse once_cell::unsync::OnceCell;\n\nuse core::slice;\nuse std::{fmt::Debug, mem::size_of, mem::transmute};\n\n#[derive(Debug, Clone, Copy)]\n#[repr(C)]\n#[repr(packed(2))] // use packed(2) because it's int16_t in raw block.\npub struct ColSchema {\n    ty: Ty,\n    len: u32,\n}\n\n#[test]\nfn col_schema() {\n    let col = ColSchema {\n        ty: Ty::BigInt,\n        len: 1,\n    };\n    let bytes: [u8; 6] = unsafe { std::mem::transmute_copy(&col) };\n    dbg!(&bytes);\n\n    let bytes: [u8; 6] = [4, 0, 1, 0, 0, 0];\n    let col2: ColSchema = unsafe { std::mem::transmute_copy(&bytes) };\n    dbg!(col2);\n}\n#[test]\nfn test_bin() {\n    let v: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let ptr = v.as_ptr();\n\n    let v_u16 = unsafe { *transmute::<*const u8, *const u16>(ptr) };\n    println!(\"{v_u16:#x?}: {:?}\", v_u16.to_le_bytes());\n    #[derive(Debug, Clone, Copy)]\n    #[repr(packed)]\n    #[allow(dead_code)]\n    struct A {\n        a: u16,\n        b: u32,\n    }\n    println!(\"A size: {}\", std::mem::size_of::<A>());\n    let a: &A = unsafe { transmute::<*const u8, *const A>(ptr).as_ref().unwrap() };\n    println!(\"{a:#x?}\");\n}\n\n/// Raw data block format (B for bytes):\n///\n/// ```text,ignore\n/// +-----+----------+---------------+-----------+-----------------------+-----------------+\n/// | len | group id | col_schema... | length... | (bitmap or offsets    | col data)   ... |\n/// | 4B  | 8B       | (2+4)B * cols | 4B * cols | (row+7)/8 or 4 * rows | length[col] ... |\n/// +-----+----------+---------------+-----------+-----------------------+-----------------+\n/// ```\n///\n/// The length of bitmap is decided by number of rows of this data block, and the length of each column data is\n/// recorded in the first segment, next to the struct header\n#[derive(Debug)]\npub struct RawBlock {\n    data: *mut u8,\n    len: usize,\n    cap: usize, // usually same to len.\n    rows: usize,\n    cols: usize,\n    precision: Precision,\n    offsets: OnceCell<Vec<(Ty, isize, isize)>>,\n}\n\nimpl Default for RawBlock {\n    fn default() -> Self {\n        Self {\n            data: std::ptr::null_mut(),\n            len: Default::default(),\n            cap: Default::default(),\n            rows: Default::default(),\n            cols: Default::default(),\n            precision: Precision::Millisecond,\n            offsets: Default::default(),\n        }\n    }\n}\n\nimpl Drop for RawBlock {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe { Vec::from_raw_parts(self.data, self.len, self.cap) };\n    }\n}\n\nimpl Inlinable for RawBlock {\n    /// **NOTE**: raw block bytes is not enough to parse data from.\n    /// You must call [with_rows](#method.with_rows)\n    fn read_inlined<R: std::io::Read>(mut reader: R) -> std::io::Result<Self> {\n        let bytes = reader.read_inlined_bytes::<4>()?;\n        Ok(Self::new(bytes))\n    }\n\n    fn write_inlined<W: std::io::Write>(&self, mut wtr: W) -> std::io::Result<usize> {\n        wtr.write_inlined_bytes::<4>(self.as_bytes())\n    }\n}\nimpl RawBlock {\n    #[inline]\n    pub fn new(mut vec: Vec<u8>) -> Self {\n        let data = vec.as_mut_ptr();\n        let len = vec.len();\n        let cap = vec.capacity();\n        assert_eq!(len, cap);\n        std::mem::forget(vec);\n        Self {\n            data,\n            len,\n            cap,\n            rows: Default::default(),\n            cols: Default::default(),\n            precision: Precision::Millisecond,\n            offsets: Default::default(),\n        }\n    }\n\n    #[inline]\n    pub fn with_rows(&mut self, rows: usize) -> &mut Self {\n        self.rows = rows;\n        self\n    }\n\n    #[inline]\n    pub fn with_cols(&mut self, cols: usize) -> &mut Self {\n        self.cols = cols;\n        self\n    }\n\n    #[inline]\n    pub fn with_precision(&mut self, precision: Precision) -> &mut Self {\n        self.precision = precision;\n        self\n    }\n\n    #[inline]\n    /// From raw data block.\n    pub unsafe fn from_ptr(\n        data: *const u8,\n        rows: usize,\n        cols: usize,\n        precision: Precision,\n    ) -> Self {\n        let len = *transmute::<*const u8, *const u32>(data) as usize;\n        let data = std::slice::from_raw_parts(data.offset(4), len).to_vec();\n        Self::from_bytes(data, rows, cols, precision)\n    }\n\n    #[inline]\n    /// Build inner block from bytes.\n    pub fn from_bytes(mut vec: Vec<u8>, rows: usize, cols: usize, precision: Precision) -> Self {\n        let data = vec.as_mut_ptr();\n        let len = vec.len();\n        let cap = vec.capacity();\n        assert_eq!(len, cap);\n        std::mem::forget(vec);\n        Self {\n            data,\n            len,\n            cap,\n            rows,\n            cols,\n            precision,\n            offsets: OnceCell::new(),\n        }\n    }\n\n    #[inline]\n    /// The whole block slice length.\n    pub const fn len(&self) -> usize {\n        self.len\n    }\n\n    #[inline]\n    pub const fn nrows(&self) -> usize {\n        self.rows\n    }\n\n    #[inline]\n    pub const fn ncols(&self) -> usize {\n        self.cols\n    }\n\n    #[inline]\n    /// The group id of the raw block.\n    pub const fn group_id(&self) -> u64 {\n        unsafe { *std::mem::transmute::<*const u8, *const u64>(self.as_ptr()) }\n    }\n\n    /// Inner block as bytes slice.\n    #[inline]\n    #[rustversion::attr(nightly, const)]\n    pub fn as_bytes(&self) -> &[u8] {\n        unsafe { std::slice::from_raw_parts(self.data, self.len) }\n    }\n\n    #[inline]\n    /// Raw data block bytes.\n    pub fn to_vec(&self) -> Vec<u8> {\n        self.as_bytes().to_owned()\n    }\n\n    #[inline]\n    /// Raw data into block bytes.\n    pub fn into_vec(self) -> Vec<u8> {\n        unsafe { Vec::from_raw_parts(self.data, self.len, self.cap) }\n    }\n\n    #[inline]\n    /// Pointer to raw block data slice.\n    const fn as_ptr(&self) -> *const u8 {\n        self.data\n    }\n\n    #[inline]\n    /// Offset to column schema start position.\n    const fn schema_offset(&self) -> isize {\n        // 4 = block data length.\n        // 8 = group id.\n        8\n    }\n\n    #[inline]\n    /// Offset to lengths start position.\n    const fn lengths_offset(&self) -> isize {\n        // 6 == size_of::<ColumnSchema>()\n        self.schema_offset() + self.cols as isize * 6\n    }\n\n    #[inline]\n    /// Offset to column data start position.\n    const fn data_offset(&self) -> isize {\n        self.lengths_offset() + self.cols as isize * 4\n    }\n\n    /// Pointer to specific offset.\n    const unsafe fn offset(&self, count: isize) -> *const u8 {\n        self.as_ptr().offset(count)\n    }\n\n    /// Length of each bitmap block.\n    const fn bitmap_len(&self) -> usize {\n        (self.rows + 7) / 8\n    }\n\n    /// A lazy-init-ed index to each column.\n    ///\n    /// For each column, the index is a 3-element tuple:\n    ///\n    /// 0. Column data type represented as [Ty]\n    /// 1. Offset to column data start position relative to the block front.\n    ///   - For var-type, it's a `rows` length `i32` vector contains the offsets to each row.\n    ///   - For non-var-type, it's the is-null bitmap.\n    /// 2. Offset to the start position of real column data.\n    fn column_offsets(&self) -> &[(Ty, isize, isize)] {\n        self.offsets.get_or_init(|| {\n            let lengths = self.lengths();\n            let mut data_offset = self.data_offset();\n            self.schemas()\n                .iter()\n                .enumerate()\n                .map(|(i, col)| {\n                    assert!(data_offset < self.len() as isize);\n                    if col.ty.is_var_type() {\n                        let o = (col.ty, data_offset, data_offset + 4 * self.rows as isize);\n                        data_offset = o.2 + lengths[i] as isize;\n                        o\n                    } else {\n                        let o = (\n                            col.ty,\n                            data_offset,\n                            data_offset + self.bitmap_len() as isize,\n                        );\n                        data_offset = o.2 + lengths[i] as isize;\n\n                        assert!(data_offset < self.len() as isize);\n                        o\n                    }\n                })\n                .collect()\n        })\n    }\n\n    /// Column schema extractor.\n    #[inline]\n    pub const fn schemas(&self) -> &[ColSchema] {\n        unsafe {\n            let ptr = self.offset(self.schema_offset());\n            slice::from_raw_parts(ptr as *mut ColSchema, self.cols)\n        }\n    }\n\n    /// Get column data type.\n    #[inline]\n    #[rustversion::attr(nightly, const)]\n    pub fn get_type_of(&self, col: usize) -> Ty {\n        self.get_schema_of(col).ty\n    }\n\n    /// Get column schema which includes data type and bytes length.\n    #[inline]\n    #[rustversion::attr(nightly, const)]\n    pub fn get_schema_of(&self, col: usize) -> &ColSchema {\n        unsafe { self.schemas().get_unchecked(col) }\n    }\n\n    #[inline]\n    /// Lengths for each column raw data.\n    const fn lengths(&self) -> &[i32] {\n        unsafe {\n            let ptr = self.offset(self.lengths_offset());\n            slice::from_raw_parts(ptr as *mut i32, self.cols)\n        }\n    }\n\n    #[inline]\n    /// Get one value at `(row, col)` of the block.\n    pub unsafe fn get_unchecked(&self, row: usize, col: usize) -> Value {\n        let (ty, o1, o2) = self.column_offsets().get_unchecked(col);\n\n        macro_rules! is_null {\n            ($bm:expr, $row:expr) => {{\n                (*$bm.offset($row as isize >> 3) >> (7 - ($row & 7)) as u8) & 0x1 == 1\n            }};\n        }\n\n        macro_rules! _primitive_value {\n            ($ty:ident, $native:ty) => {{\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::<$native>()) as isize)\n                        as *const $native);\n                    Value::$ty(v)\n                }\n            }};\n        }\n\n        match ty {\n            Ty::Null => Value::Null,\n            Ty::Bool => _primitive_value!(Bool, bool),\n            Ty::TinyInt => _primitive_value!(TinyInt, i8),\n            Ty::SmallInt => _primitive_value!(SmallInt, i16),\n            Ty::Int => _primitive_value!(Int, i32),\n            Ty::BigInt => _primitive_value!(BigInt, i64),\n            Ty::Float => _primitive_value!(Float, f32),\n            Ty::Double => _primitive_value!(Double, f64),\n            Ty::VarChar => {\n                //\n                let offset =\n                    *transmute::<*const u8, *const i32>(self.offset(o1 + row as isize * 4));\n                if offset < 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    Value::VarChar(\n                        std::str::from_utf8_unchecked(slice::from_raw_parts(\n                            ptr.offset(2),\n                            len as usize,\n                        ))\n                        .to_string(),\n                    )\n                }\n            }\n            Ty::Timestamp => {\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::<i64>()) as isize) as *const i64);\n                    Value::Timestamp(Timestamp::new(v, self.precision))\n                }\n            }\n            Ty::NChar => {\n                let offset =\n                    *transmute::<*const u8, *const i32>(self.offset(o1 + row as isize * 4));\n                if offset < 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n\n                    Value::NChar(\n                        slice::from_raw_parts(ptr.offset(2) as *mut char, len as usize / 4)\n                            .into_iter()\n                            .collect(),\n                    )\n                }\n            }\n            Ty::UTinyInt => _primitive_value!(UTinyInt, u8),\n            Ty::USmallInt => _primitive_value!(USmallInt, u16),\n            Ty::UInt => _primitive_value!(UInt, u32),\n            Ty::UBigInt => _primitive_value!(UBigInt, u64),\n            Ty::Json => {\n                let offset =\n                    *transmute::<*const u8, *const i32>(self.offset(o1 + row as isize * 4));\n                if offset < 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    debug_assert!(self.len() as isize >= o1 + row as isize * 4 + len as isize);\n                    let chars_len = len / 4;\n                    let chars_ptr = ptr.offset(2) as *mut char;\n                    let chars = slice::from_raw_parts(chars_ptr, chars_len as usize);\n                    let json: String = chars.into_iter().collect();\n\n                    serde_json::from_str(&json)\n                        .ok()\n                        .map(Value::Json)\n                        .unwrap_or(Value::Null)\n                }\n            }\n            ty => unreachable!(\"unsupported type: {ty}\"),\n        }\n    }\n}\n\n#[test]\nfn inner_block() {\n    use crate::common::Precision::Millisecond;\n    use crate::common::Timestamp::Milliseconds;\n    let bytes = b\"5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x08\\x00\\x00\\x00\\x0b\\x00\\x01\\x00\\x00\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\r\\x00\\x04\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x04\\x00\\x00\\x00\\x07\\x00\\x08\\x00\\x00\\x00\\x08\\x00f\\x00\\x00\\x00\\n\\x00\\x92\\x01\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x00\\xf2=\\xc3u\\x81\\x01\\x00\\x00\\xdaA\\xc3u\\x81\\x01\\x00\\x00@\\x01\\x00@\\xff\\x00@\\xff\\xff\\x00\\x00@\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00@\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00@\\x01\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x03\\x00abc\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x14\\x00\\x9bm\\x00\\x00\\x1d`\\x00\\x00\\x1e\\xd1\\x01\\x00pe\\x00\\x00nc\\x00\\x00\\x00\\x00\\x00\\x00\";\n    let rows = 2;\n    let cols = 14;\n    let precision = Millisecond;\n\n    let block = unsafe { RawBlock::from_ptr(bytes.as_ptr(), rows, cols, precision) };\n\n    assert_eq!(block.len(), bytes.len() - 4);\n    assert_eq!(block.as_bytes(), &bytes[4..]);\n    assert_eq!(block.group_id(), 0);\n\n    use Value::*;\n    let values = vec![\n        vec![\n            Timestamp(Milliseconds(1655538138610)),\n            Bool(true),\n            Value::TinyInt(-1),\n            SmallInt(-1),\n            Int(-1),\n            BigInt(-1),\n            UTinyInt(1),\n            USmallInt(1),\n            UInt(1),\n            UBigInt(1),\n            Float(0.0),\n            Double(0.0),\n            VarChar(\"abc\".to_string()),\n            NChar(\"涛思𝄞数据\".to_string()),\n        ],\n        {\n            Some(Timestamp(Milliseconds(1655538139610)))\n                .into_iter()\n                .chain(std::iter::repeat(Value::Null).take(14))\n                .collect::<Vec<_>>()\n        },\n    ];\n    assert!(block.cols == 14);\n\n    for row in 0..rows {\n        for col in 0..block.cols {\n            let v = unsafe { block.get_unchecked(row, col) };\n            assert_eq!(v, values[row][col]);\n        }\n    }\n\n    let inlined = block.inlined();\n    assert!(inlined == bytes);\n}\n","traces":[{"line":20,"address":[3220304],"length":1,"stats":{"Line":3},"fn_name":"col_schema"},{"line":25,"address":[3220352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[3220408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[3220860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[3220916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[3220972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[3221440],"length":1,"stats":{"Line":3},"fn_name":"test_bin"},{"line":34,"address":[3221447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[3221527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[3221570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[3221607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[3221820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[3221930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[3222001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[3208928],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":77,"address":[3208976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[3208986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[3208996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[3209006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[3209023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[2803424],"length":1,"stats":{"Line":1},"fn_name":"drop"},{"line":90,"address":[2803433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[2076336,2076435],"length":1,"stats":{"Line":1},"fn_name":"write_inlined<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":103,"address":[2076426,2076371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[3209136,3209684,3209715],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":109,"address":[3209249,3209166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[3209257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3209288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3209456,3209314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[3209396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[3209526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3209538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3209569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3209728],"length":1,"stats":{"Line":0},"fn_name":"with_rows"},{"line":127,"address":[3209744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[3209760],"length":1,"stats":{"Line":0},"fn_name":"with_cols"},{"line":133,"address":[3209776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3209792],"length":1,"stats":{"Line":0},"fn_name":"with_precision"},{"line":139,"address":[3209807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3209824],"length":1,"stats":{"Line":2},"fn_name":"from_ptr"},{"line":151,"address":[3209893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[3209994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[3210051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[3210690,3210112,3210659],"length":1,"stats":{"Line":2},"fn_name":"from_bytes"},{"line":159,"address":[3210181,3210264],"length":1,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[3210272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[3210303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[3210329,3210471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3210411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[3210548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[3210704],"length":1,"stats":{"Line":1},"fn_name":"len"},{"line":178,"address":[3210709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[3210720],"length":1,"stats":{"Line":1},"fn_name":"nrows"},{"line":183,"address":[3210725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[3210736],"length":1,"stats":{"Line":1},"fn_name":"ncols"},{"line":188,"address":[3210741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[3210752],"length":1,"stats":{"Line":1},"fn_name":"group_id"},{"line":194,"address":[3210761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[3222960],"length":1,"stats":{"Line":1},"fn_name":"as_bytes"},{"line":201,"address":[3222972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[3210816],"length":1,"stats":{"Line":0},"fn_name":"to_vec"},{"line":207,"address":[3210848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[3210896,3210978],"length":1,"stats":{"Line":0},"fn_name":"into_vec"},{"line":213,"address":[3210916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3211024],"length":1,"stats":{"Line":1},"fn_name":"as_ptr"},{"line":219,"address":[3211029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[3211040],"length":1,"stats":{"Line":1},"fn_name":"schema_offset"},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3211056],"length":1,"stats":{"Line":1},"fn_name":"lengths_offset"},{"line":234,"address":[3211070,3211172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[3211216],"length":1,"stats":{"Line":1},"fn_name":"data_offset"},{"line":240,"address":[3211230,3211332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[3211376],"length":1,"stats":{"Line":1},"fn_name":"offset"},{"line":245,"address":[3211395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[3211456],"length":1,"stats":{"Line":1},"fn_name":"bitmap_len"},{"line":250,"address":[3211499,3211465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[3211536],"length":1,"stats":{"Line":1},"fn_name":"column_offsets"},{"line":263,"address":[2076464],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":264,"address":[2076502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[2076538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[2076553,2076666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[2076783,2076720,2076629],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":270,"address":[2076807,2076888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[2077799,2076925,2077385,2076874],"length":1,"stats":{"Line":4},"fn_name":null},{"line":272,"address":[2077216,2077016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[2077387,2077267,2077182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[2077350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[2077495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[2076947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[2076953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[2076964,2077449,2077553],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[2077604,2077705,2077519],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[2077679,2077744,2077804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[2077764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[3211616],"length":1,"stats":{"Line":1},"fn_name":"schemas"},{"line":295,"address":[3211630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[3211675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[3223008],"length":1,"stats":{"Line":0},"fn_name":"get_type_of"},{"line":304,"address":[3223022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[3223056],"length":1,"stats":{"Line":0},"fn_name":"get_schema_of"},{"line":311,"address":[3223075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3211712],"length":1,"stats":{"Line":1},"fn_name":"lengths"},{"line":318,"address":[3211726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[3211771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[3214002,3211808],"length":1,"stats":{"Line":1},"fn_name":"get_unchecked"},{"line":326,"address":[3211890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[3212021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[3212121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3212145,3219680,3219755],"length":1,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[3212190,3219378,3219303],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[3212235,3218887,3218974],"length":1,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[3218549,3218462,3212280],"length":1,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[3218121,3218034,3212325],"length":1,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[3217603,3212370,3217690],"length":1,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[3217259,3212415,3217172],"length":1,"stats":{"Line":3},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[3216708,3212452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[3217159,3216887,3216838],"length":1,"stats":{"Line":3},"fn_name":null},{"line":361,"address":[3216884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[3216908,3216858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[3216937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[3217024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[3217020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[3212501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[3216687,3216220,3216307,3216473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":377,"address":[3216470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[3216478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[3216628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[3215750,3212538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[3216207,3215880,3215929],"length":1,"stats":{"Line":3},"fn_name":null},{"line":387,"address":[3215926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[3215900,3215950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":390,"address":[3215979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[3216062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[3215404,3212587,3215317],"length":1,"stats":{"Line":3},"fn_name":null},{"line":400,"address":[3212632,3214976,3214889],"length":1,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[3214464,3214551,3212677],"length":1,"stats":{"Line":3},"fn_name":null},{"line":402,"address":[3212722,3214036,3214123],"length":1,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[3213002,3212759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[3213132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[3213178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[3213213,3213152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[3213250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[3213496,3213269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[3213481,3213534,3213620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[3213666,3213618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[3213674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[3213732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[3213792,3213976,3213875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[3213952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[2078261,2078256],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":432,"address":[3223143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[3223166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[3223178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[3223190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[3223201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[3223338,3223597,3223275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[3223917,3223558,3223661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[3223972,3224113,3223886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[3225945,3225716,3224082,3224213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[3225392,3224567,3224674,3224751,3224190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[3224271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[3224331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[3224347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[3224363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[3224381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[3224400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[3224420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[3224436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[3224454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[3224473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[3224493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[3224512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[3224532,3224599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[3224639,3224711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[3225849,3225912,3225577],"length":1,"stats":{"Line":3},"fn_name":null},{"line":463,"address":[3225748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[3225756,3225927,3225888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[3226012,3226094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[3226180,3226030,3226296],"length":1,"stats":{"Line":3},"fn_name":null},{"line":471,"address":[3226317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[3226528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[3226540,3226617,3226756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[3226286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[3226819,3226878,3226903],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":140,"coverable":213},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","raw","mod.rs"],"content":"mod inner;\n\nuse std::io::Write;\n\nuse super::{Column, Field, Precision};\n\nuse crate::util::*;\npub use inner::*;\n\nuse bitflags::bitflags;\nuse once_cell::unsync::OnceCell;\n\nbitflags! {\n    #[derive(Default)]\n    #[repr(transparent)]\n    struct Fx: u8 {\n        /// Has database name in the block.\n        const HAS_DB = 0b00000001;\n        /// Has table name in the block\n        const HAS_TB = 0b00000010;\n        /// Has fields data in the block\n        const HAS_FL = 0b00000100;\n        /// Has precision set.\n        const HAS_PC = 0b00001000;\n        /// Precision set as 'ms'(milliseconds).\n        const IS_MS  = 0b00001000;\n        /// Precision set as 'us'(microseconds).\n        const IS_US  = 0b00011000;\n        /// Precision set as 'ns'(nanoseconds).\n        const IS_NS  = 0b00101000;\n    }\n}\n\npub struct Block {\n    database: Option<String>,\n    table: Option<String>,\n    fields: Option<Vec<Field>>,\n    raw: OnceCell<RawBlock>,\n    columns: OnceCell<Vec<Column>>,\n}\n\nimpl Inlinable for Block {\n    #[inline]\n    fn read_inlined<R: std::io::Read>(mut reader: R) -> std::io::Result<Self> {\n        let flags = Fx::from_bits(reader.read_u8()?).unwrap();\n        let database = if flags.contains(Fx::HAS_DB) {\n            Some(reader.read_inlined_str::<2>()?)\n        } else {\n            None\n        };\n        let table = if flags.contains(Fx::HAS_DB) {\n            Some(reader.read_inlined_str::<2>()?)\n        } else {\n            None\n        };\n        use itertools::Itertools;\n        let fields = if flags.contains(Fx::HAS_FL) {\n            Some(\n                (0..reader.read_u16()?)\n                    .map(|f| reader.read_inlinable::<Field>())\n                    .try_collect()?,\n            )\n        } else {\n            None\n        };\n\n        let precision = if flags.contains(Fx::IS_MS) {\n            Precision::Millisecond\n        } else if flags.contains(Fx::IS_US) {\n            Precision::Microsecond\n        } else if flags.contains(Fx::IS_NS) {\n            Precision::Nanosecond\n        } else {\n            Precision::Millisecond\n        };\n\n        let rows = reader.read_u32()?;\n        let cols = reader.read_u32()?;\n\n        let bytes = reader.read_inlined_bytes::<4>()?;\n        let raw = OnceCell::new();\n        raw.try_insert(RawBlock::from_bytes(\n            bytes,\n            rows as usize,\n            cols as usize,\n            precision,\n        ))\n        .unwrap();\n\n        Ok(Self {\n            database,\n            table,\n            fields,\n            raw,\n            columns: OnceCell::new(),\n        })\n    }\n\n    #[inline]\n    fn write_inlined<W: Write>(&self, mut wtr: W) -> std::io::Result<usize> {\n        let mut l = wtr.write_u8(self.flags().bits)?;\n\n        if let Some(name) = self.database.as_ref() {\n            l += wtr.write_inlined_bytes::<2>(name.as_bytes())?;\n        }\n        if let Some(name) = self.table.as_ref() {\n            l += wtr.write_inlined_bytes::<2>(name.as_bytes())?;\n        }\n        if let Some(fields) = self.fields.as_ref() {\n            l += wtr.write_len_with_width::<2>(fields.len())?;\n            for field in fields {\n                l += wtr.write_inlinable(field)?;\n            }\n        }\n        let raw = self.as_raw_block();\n        l += wtr.write_len_with_width::<4>(raw.nrows())?;\n        l += wtr.write_len_with_width::<4>(raw.ncols())?;\n        l += wtr.write_inlined_bytes::<4>(raw.as_bytes())?;\n        Ok(l)\n    }\n}\n\nimpl Block {\n    #[inline]\n    pub fn fields(&self) -> &[Field] {\n        const FIELDS: [Field; 0] = [];\n        if let Some(f) = self.fields.as_ref() {\n            &f\n        } else {\n            &FIELDS\n        }\n    }\n\n    #[inline]\n    pub const fn has_database_name(&self) -> bool {\n        self.database.is_some()\n    }\n    #[inline]\n    pub const fn has_table_name(&self) -> bool {\n        self.table.is_some()\n    }\n\n    #[inline]\n    pub fn with_database_name(&mut self, database: &str) -> &mut Self {\n        self.database = Some(database.to_string());\n        self\n    }\n\n    #[inline]\n    pub fn with_table_name(&mut self, table: &str) -> &mut Self {\n        self.table = Some(table.to_string());\n        self\n    }\n\n    #[inline]\n    pub fn with_fields(&mut self, fields: Vec<Field>) -> &mut Self {\n        assert!(fields.len() > 0);\n        self.fields = Some(fields);\n        self\n    }\n\n    #[inline]\n    pub fn from_raw_block(data: RawBlock) -> Self {\n        let raw = OnceCell::new();\n        raw.try_insert(data).unwrap();\n        Self {\n            raw,\n            database: None,\n            table: None,\n            fields: None,\n            columns: OnceCell::new(),\n        }\n    }\n\n    #[inline]\n    pub fn from_raw_bytes(bytes: Vec<u8>, rows: usize, cols: usize, precision: Precision) -> Self {\n        let data = RawBlock::from_bytes(bytes, rows, cols, precision);\n        Self::from_raw_block(data)\n    }\n\n    #[inline]\n    pub fn push_column(&mut self, column: impl Into<Column>) -> &mut Self {\n        if let Some(mut v) = self.columns.take() {\n            v.push(column.into());\n            self.columns.try_insert(v).unwrap();\n        } else {\n            let v = vec![column.into()];\n            self.columns.try_insert(v).unwrap();\n        }\n        self\n    }\n\n    #[inline]\n    pub fn as_raw_block(&self) -> &RawBlock {\n        self.raw.get_or_init(|| todo!())\n    }\n\n    #[inline]\n    pub fn to_raw_vec(&self) -> std::io::Result<Vec<u8>> {\n        let mut bytes = Vec::new();\n        bytes.write_inlinable(self)?;\n        Ok(bytes)\n    }\n\n    #[inline]\n    pub fn nrows(&self) -> usize {\n        self.as_raw_block().nrows()\n    }\n\n    #[inline]\n    pub fn ncols(&self) -> usize {\n        self.as_raw_block().ncols()\n    }\n\n    fn flags(&self) -> Fx {\n        let mut flags = Fx::default();\n        if self.has_database_name() {\n            flags |= Fx::HAS_DB;\n        }\n        if self.has_table_name() {\n            flags |= Fx::HAS_TB;\n        }\n        if self.fields.is_some() {\n            flags |= Fx::HAS_FL;\n        }\n        flags\n    }\n}\n\n#[test]\nfn inner_block() -> anyhow::Result<()> {\n    use crate::common::Precision::Millisecond;\n    let bytes = b\"5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x08\\x00\\x00\\x00\\x0b\\x00\\x01\\x00\\x00\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\r\\x00\\x04\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x04\\x00\\x00\\x00\\x07\\x00\\x08\\x00\\x00\\x00\\x08\\x00f\\x00\\x00\\x00\\n\\x00\\x92\\x01\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x00\\xf2=\\xc3u\\x81\\x01\\x00\\x00\\xdaA\\xc3u\\x81\\x01\\x00\\x00@\\x01\\x00@\\xff\\x00@\\xff\\xff\\x00\\x00@\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00@\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00@\\x01\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x03\\x00abc\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x14\\x00\\x9bm\\x00\\x00\\x1d`\\x00\\x00\\x1e\\xd1\\x01\\x00pe\\x00\\x00nc\\x00\\x00\\x00\\x00\\x00\\x00\";\n    let rows = 2;\n    let cols = 14;\n    let precision = Millisecond;\n\n    let raw = unsafe { RawBlock::from_ptr(bytes.as_ptr(), rows, cols, precision) };\n\n    let mut block = Block::from_raw_block(raw);\n    block.with_database_name(\"abc\").with_table_name(\"n1\");\n\n    let a = block.printable_inlined();\n\n    let inlined = block.inlined();\n\n    anyhow::ensure!(\n        &inlined[0..18] == b\"\\x03\\x03\\x00abc\\x02\\x00n1\\x02\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\"\n    );\n    assert!(&inlined[18..] == bytes);\n\n    let block = Block::read_inlined(inlined.as_slice())?;\n    let b = block.printable_inlined();\n\n    assert_eq!(a, b);\n    Ok(())\n}\n","traces":[{"line":13,"address":[1929213,1929085,1929021,1928893,1929277,1928957,1929149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[1925086,1925072],"length":1,"stats":{"Line":2},"fn_name":"default"},{"line":44,"address":[2707655,2707821,2704464],"length":1,"stats":{"Line":1},"fn_name":"read_inlined<&[u8]>"},{"line":45,"address":[2704708,2704491,2704585],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[2704753,2704791,2704998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[2704809,2705005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2704774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2705391,2705169,2705143,2705087],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[2705187,2705398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2705149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[2705576,2705494,2705550,2706018],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[2705594,2705690,2705791,2705814,2706041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2705682,2707840,2707864],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<&[u8]>"},{"line":61,"address":[2706025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2705556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[2706127,2706183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[2706210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2706199,2706245,2706283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[2706272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[2706306,2706289,2706261,2706319],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[2706308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2706295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[2706234,2706337,2706412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[2706400,2706580,2706505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[2706779,2706568,2706658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[2706764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2706911,2706991,2707063],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[2706919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[2706959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[2706963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2706967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[2707349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[2707092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[2707126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[2707166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[2707206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[2707302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[2710428,2707888],"length":1,"stats":{"Line":1},"fn_name":"write_inlined<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":101,"address":[2708125,2707994,2707946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[2708524,2708201,2708098],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[2708516,2708529,2708251,2708340],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[2708888,2708569,2708282],"length":1,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[2708880,2708619,2708893,2708704],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2708650,2708934],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[2709220,2709045,2708989,2709245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2709576,2709228,2709288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[2709581,2709398,2709568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2709619,2709009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[2709627,2709835,2709855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[2709843,2709909,2710084,2710109],"length":1,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[2710366,2710168,2710395,2710092],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[2710374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1922608],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":127,"address":[1922740,1922617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1922664,1922730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1922685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1922752],"length":1,"stats":{"Line":1},"fn_name":"has_database_name"},{"line":136,"address":[1922761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[1922800],"length":1,"stats":{"Line":1},"fn_name":"has_table_name"},{"line":140,"address":[1922809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1922848,1922940],"length":1,"stats":{"Line":1},"fn_name":"with_database_name"},{"line":145,"address":[1922973,1922872],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[1923008,1923105],"length":1,"stats":{"Line":1},"fn_name":"with_table_name"},{"line":151,"address":[1923032,1923138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1923184,1923471,1923495],"length":1,"stats":{"Line":0},"fn_name":"with_fields"},{"line":157,"address":[1923224,1923273,1923349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1923296,1923386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[1923214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1923520,1924153,1924235],"length":1,"stats":{"Line":1},"fn_name":"from_raw_block"},{"line":164,"address":[1923542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1923624,1923765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1923901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[1924272],"length":1,"stats":{"Line":0},"fn_name":"from_raw_bytes"},{"line":177,"address":[1924313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[1924354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[1924416],"length":1,"stats":{"Line":1},"fn_name":"as_raw_block"},{"line":195,"address":[1924425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1924756,1924464],"length":1,"stats":{"Line":0},"fn_name":"to_raw_vec"},{"line":200,"address":[1924491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1924688,1924562,1924517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1924617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[1924800],"length":1,"stats":{"Line":0},"fn_name":"nrows"},{"line":207,"address":[1924809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1924848],"length":1,"stats":{"Line":0},"fn_name":"ncols"},{"line":212,"address":[1924857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[1924896],"length":1,"stats":{"Line":1},"fn_name":"flags"},{"line":216,"address":[1924910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1924924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[1924959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[1924948,1924980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[1925006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[1925027,1924991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[1925042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1929328,1930861,1930779],"length":1,"stats":{"Line":3},"fn_name":"inner_block"},{"line":233,"address":[1929335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1929350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[1929362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1929374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1929385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1929451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1929498,1929581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[1929616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[1929639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1929714,1929822,1929994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1929690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[1929938,1930111,1930189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[1930239,1930172,1930386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[1930376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[1930686,1930732,1930562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[1930692],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":78,"coverable":119},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","timestamp.rs"],"content":"use std::fmt::{self, Debug, Display};\n\nuse serde::{Deserialize, Serialize};\n\nuse super::Precision;\n\n#[derive(Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]\npub enum Timestamp {\n    Milliseconds(i64),\n    Microseconds(i64),\n    Nanoseconds(i64),\n}\n\nimpl Debug for Timestamp {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if f.alternate() {\n            match self {\n                Self::Milliseconds(arg0) => f.debug_tuple(\"Milliseconds\").field(arg0).finish(),\n                Self::Microseconds(arg0) => f.debug_tuple(\"Microseconds\").field(arg0).finish(),\n                Self::Nanoseconds(arg0) => f.debug_tuple(\"Nanoseconds\").field(arg0).finish(),\n            }\n        } else {\n            Debug::fmt(&self.to_naive_datetime(), f)\n        }\n    }\n}\n\nimpl Display for Timestamp {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        Display::fmt(&self.to_naive_datetime(), f)\n    }\n}\n\nimpl Timestamp {\n    pub fn new(raw: i64, precision: Precision) -> Self {\n        match precision {\n            Precision::Millisecond => Timestamp::Milliseconds(raw),\n            Precision::Microsecond => Timestamp::Microseconds(raw),\n            Precision::Nanosecond => Timestamp::Nanoseconds(raw),\n        }\n    }\n    pub fn as_raw_i64(&self) -> i64 {\n        match self {\n            Timestamp::Milliseconds(raw)\n            | Timestamp::Microseconds(raw)\n            | Timestamp::Nanoseconds(raw) => *raw,\n        }\n    }\n    pub fn to_naive_datetime(&self) -> chrono::NaiveDateTime {\n        let duration = match self {\n            Timestamp::Milliseconds(raw) => chrono::Duration::milliseconds(*raw),\n            Timestamp::Microseconds(raw) => chrono::Duration::microseconds(*raw),\n            Timestamp::Nanoseconds(raw) => chrono::Duration::nanoseconds(*raw),\n        };\n        chrono::NaiveDateTime::from_timestamp(0, 0)\n            .checked_add_signed(duration)\n            .unwrap()\n    }\n\n    // todo: support to tz.\n    pub fn to_datetime_with_tz(&self) {}\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ts_new() {\n        use Precision::*;\n        for prec in [Millisecond, Microsecond, Nanosecond] {\n            let ts = Timestamp::new(0, prec);\n            assert!(ts.as_raw_i64() == 0);\n            assert!(ts.to_naive_datetime() == chrono::NaiveDateTime::from_timestamp(0, 0));\n        }\n    }\n\n    #[test]\n    fn ts_debug() {\n        let ts = Timestamp::new(0, Precision::Millisecond);\n        assert_eq!(format!(\"{:?}\", ts), \"1970-01-01T00:00:00\");\n        assert_eq!(format!(\"{:#?}\", ts), \"Milliseconds(\\n    0,\\n)\");\n        assert_eq!(format!(\"{}\", ts), \"1970-01-01 00:00:00\");\n    }\n}\n","traces":[{"line":15,"address":[2699936],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":16,"address":[8227662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[2700030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[2700072,2700339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2700127,2700292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[2700179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[2700384,2700007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[2700416],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":30,"address":[2700441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2700496],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":36,"address":[2700513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[2700546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[2700566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2700586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2700624],"length":1,"stats":{"Line":1},"fn_name":"as_raw_i64"},{"line":43,"address":[2700682,2700697,2700637],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[2700688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2700736],"length":1,"stats":{"Line":1},"fn_name":"to_naive_datetime"},{"line":50,"address":[2700760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[2700797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2700834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[2700871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2700901,2700926],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[2700917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[2700976,2700981],"length":1,"stats":{"Line":0},"fn_name":"to_datetime_with_tz"},{"line":69,"address":[2458733,2458272],"length":1,"stats":{"Line":3},"fn_name":"ts_new"},{"line":71,"address":[2458279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2458506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2458610,2458557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2458654,2458603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[2458768,2459170],"length":1,"stats":{"Line":3},"fn_name":"ts_debug"},{"line":80,"address":[2458775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[2458818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2459196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2459571],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":35},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","ty.rs"],"content":"use std::{\n    fmt::{self, Display},\n    str::FromStr,\n};\n\nuse serde::de::Visitor;\n\n// todo: useful?\n// pub const TY_NULL: Ty = Ty::Null; // 1 bytes\n// pub const TY_BOOL: Ty = Ty::Bool; // 1 bytes\n// pub const TY_TINY_INT: Ty = Ty::TinyInt; // 1 byte\n// pub const TY_SMALL_INT: Ty = Ty::SmallInt; // 2 bytes\n// pub const TY_INT: Ty = Ty::Int; // 4 bytes\n// pub const TY_BIGINT: Ty = Ty::BigInt; // 8 bytes\n// pub const TY_FLOAT: Ty = Ty::Float; // 4 bytes\n// pub const TY_DOUBLE: Ty = Ty::Double; // 8 bytes\n// pub const TY_BINARY: Ty = Ty::VarChar; // string, alias for varchar\n// pub const TY_TIMESTAMP: Ty = Ty::Timestamp; // 8 bytes\n// pub const TY_NCHAR: Ty = Ty::NChar; // unicode string\n// pub const TY_U_TINY_INT: Ty = Ty::UTinyInt; // 1 byte\n// pub const TY_U_SMALL_INT: Ty = Ty::USmallInt; // 2 bytes\n// pub const TY_UINT: Ty = Ty::UInt; // 4 bytes\n// pub const TY_UBIGINT: Ty = Ty::UBigInt; // 8 bytes\n// pub const TY_JSON: Ty = Ty::Json; // json\n// pub const TY_VARCHAR: Ty = Ty::VarChar; // string\n// pub const TY_VAR_BINARY: Ty = Ty::VarBinary; // binary\n// pub const TY_DECIMAL: Ty = Ty::Decimal; // decimal\n// pub const TY_BLOB: Ty = Ty::Blob; // binary\n// pub const TY_MEDIUM_BLOB: Ty = Ty::MediumBlob; // binary\n\n/// TDengine data type enumeration.\n///\n/// | enum       | int | sql name         | rust type |\n/// | ----       |:---:| --------         |:---------:|\n/// | Null       | 0   | NULL             | None      |\n/// | Bool       | 1   | BOOL             | bool      |\n/// | TinyInt    | 2   | TINYINT          | i8        |\n/// | SmallInt   | 3   | SMALLINT         | i16       |\n/// | Int        | 4   | INT              | i32       |\n/// | BitInt     | 5   | BIGINT           | i64       |\n/// | Float      | 6   | FLOAT            | f32       |\n/// | Double     | 7   | DOUBLE           | f64       |\n/// | VarChar    | 8   | BINARY/VARCHAR   | str/String        |\n/// | Timestamp  | 9   | TIMESTAMP        | i64               |\n/// | NChar      | 10  | NCHAR            | str/String        |\n/// | UTinyInt   | 11  | TINYINT UNSIGNED | u8                |\n/// | USmallInt  | 12  | SMALLINT UNSIGNED| u16               |\n/// | UInt       | 13  | INT UNSIGNED     | u32               |\n/// | UBigInt    | 14  | BIGINT UNSIGNED  | u64               |\n/// | Json       | 15  | JSON             | serde_json::Value |\n/// | VarBinary  | 16  | VARBINARY        | Vec<u8>           |\n/// | Decimal    | 17  | DECIMAL          | ?                 |\n/// | Blob       | 18  | BLOB             | ?                 |\n/// | MediumBlob | 19  | MEDIUMBLOB       | ?                 |\n///\n/// Note:\n/// - VarChar sql name is BINARY in v2, and VARCHAR in v3.\n/// - Decimal/Blob/MediumBlob is not supported in 2.0/3.0 .\n#[derive(Debug, Clone, Copy, PartialEq, Eq, serde_repr::Serialize_repr)]\n#[repr(u8)]\n#[non_exhaustive]\npub enum Ty {\n    /// 0: Null is only a value, not a *real* type, a nullable data type could be represented as [Option<T>] in Rust.\n    Null = 0,\n    /// 1: Bool, `bool` type in sql, will be represented as [bool] in Rust.\n    Bool, // 1\n    /// 2: TinyInt, `tinyint` type in sql, will be represented in Rust as [i8].\n    TinyInt, // 2\n    /// 3: SmallInt, `smallint` type in sql, will be represented in Rust as [i16].\n    SmallInt, // 3\n    /// 4: Int, `int` type in sql, will be represented in Rust as [i32].\n    Int, // 4\n    /// 5: BigInt, `bigint` type in sql, will be represented in Rust as [i64].\n    BigInt, // 5\n    /// 6: Float, `float` type in sql, will be represented in Rust as [f32].\n    Float, // 6\n    /// 7: Double, `tinyint` type in sql, will be represented in Rust as [f64].\n    Double, // 7\n    /// 8: VarChar, `binary` type in sql for TDengine 2.x, `varchar` for TDengine 3.x,\n    ///  will be represented in Rust as [&str] or [String]. This type of data be deserialized to [Vec<u8>].\n    VarChar,\n    /// 9: Timestamp, `timestamp` type in sql, will be represented as [i64] in Rust.\n    /// But can be deserialized to [chrono::naive::NaiveDateTime] or [String].\n    Timestamp, // 9\n    /// 10: NChar, `nchar` type in sql, the recommended way in TDengine to store utf-8 [String].\n    NChar, // 10\n    /// 11: UTinyInt, `tinyint unsigned` in sql, [u8] in Rust.\n    UTinyInt, // 11\n    /// 12: USmallInt, `smallint unsigned` in sql, [u16] in Rust.\n    USmallInt, // 12\n    /// 13: UInt, `int unsigned` in sql, [u32] in Rust.\n    UInt, // 13\n    /// 14: UBigInt, `bigint unsigned` in sql, [u64] in Rust.\n    UBigInt, // 14\n    /// 15: Json, `json` tag in sql, will be represented as [serde_json::value::Value] in Rust.\n    Json, // 15\n    /// 16, VarBinary, `varbinary` in sql, [Vec<u8>] in Rust, which is supported since TDengine 3.0.\n    VarBinary, // 16\n    /// 17, Not supported now.\n    Decimal, // 17\n    /// 18, Not supported now.\n    Blob, // 18\n    /// 19, Not supported now.\n    MediumBlob, // 19\n}\n\nimpl<'de> serde::Deserialize<'de> for Ty {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        struct TyVisitor;\n\n        impl<'de> Visitor<'de> for TyVisitor {\n            type Value = Ty;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"invalid TDengine type\")\n            }\n            fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::from_u8(v as u8))\n            }\n\n            fn visit_u8<E>(self, v: u8) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::from_u8(v))\n            }\n\n            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::from_u8(v as u8))\n            }\n\n            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ty::from_str(v).map_err(<E as serde::de::Error>::custom)\n            }\n\n            fn visit_none<E>(self) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::Null)\n            }\n\n            fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,\n            {\n                deserializer.deserialize_any(self)\n            }\n\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::Null)\n            }\n        }\n\n        deserializer.deserialize_any(TyVisitor)\n    }\n}\n\n// todo: decimal/blob\nimpl FromStr for Ty {\n    type Err = &'static str;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s.to_lowercase().as_str() {\n            \"timestamp\" => Ok(Ty::Timestamp),\n            \"bool\" => Ok(Ty::Bool),\n            \"tinyint\" => Ok(Ty::TinyInt),\n            \"smallint\" => Ok(Ty::SmallInt),\n            \"int\" => Ok(Ty::Int),\n            \"bigint\" => Ok(Ty::BigInt),\n            \"tinyint unsigned\" => Ok(Ty::UTinyInt),\n            \"smallint unsigned\" => Ok(Ty::USmallInt),\n            \"int unsigned\" => Ok(Ty::UInt),\n            \"bigint unsigned\" => Ok(Ty::UBigInt),\n            \"float\" => Ok(Ty::Float),\n            \"double\" => Ok(Ty::Double),\n            \"binary\" | \"varchar\" => Ok(Ty::VarChar),\n            \"nchar\" => Ok(Ty::NChar),\n            \"json\" => Ok(Ty::Json),\n            \"varbinary\" => Ok(Ty::VarBinary),\n            \"decimal\" => Ok(Ty::Decimal),\n            \"blob\" => Ok(Ty::Blob),\n            \"mediumblob\" => Ok(Ty::MediumBlob),\n            _ => Err(\"not a valid data type string\"),\n        }\n    }\n}\n\nimpl Ty {\n    /// Check if the data type is null or not.\n    pub const fn is_null(&self) -> bool {\n        matches!(self, Ty::Null)\n    }\n\n    /// Var type which is one of [Ty::VarChar], [Ty::VarBinary] or [Ty::NChar].\n    pub const fn is_var_type(&self) -> bool {\n        use Ty::*;\n        matches!(self, VarChar | VarBinary | NChar)\n    }\n\n    pub const fn is_primitive(&self) -> bool {\n        use Ty::*;\n        matches!(\n            self,\n            Bool | TinyInt\n                | SmallInt\n                | Int\n                | BigInt\n                | UTinyInt\n                | USmallInt\n                | UInt\n                | UBigInt\n                | Float\n                | Double\n                | Decimal\n        )\n    }\n\n    /// Fixed length if the type is primitive.\n    pub const fn fixed_length(&self) -> usize {\n        use Ty::*;\n        match self {\n            Bool => 1,\n            TinyInt => 1,\n            SmallInt => 2,\n            Int => 4,\n            BigInt => 8,\n            Float => 4,\n            Double => 8,\n            Timestamp => 8,\n            UTinyInt => 1,\n            USmallInt => 2,\n            UInt => 4,\n            UBigInt => 8,\n            Decimal => 16,\n            _ => panic!(\"not a fixed length type\"),\n        }\n    }\n\n    /// The sql name of type.\n    pub const fn name(&self) -> &'static str {\n        use Ty::*;\n        match self {\n            Null => \"NULL\",\n            Bool => \"BOOL\",\n            TinyInt => \"TINYINT\",\n            SmallInt => \"SMALLINT\",\n            Int => \"INT\",\n            BigInt => \"BIGINT\",\n            Float => \"FLOAT\",\n            Double => \"DOUBLE\",\n            VarChar => \"BINARY\",\n            Timestamp => \"TIMESTAMP\",\n            NChar => \"NCHAR\",\n            UTinyInt => \"TINYINT UNSIGNED\",\n            USmallInt => \"SMALLINT UNSIGNED\",\n            UInt => \"INT UNSIGNED\",\n            UBigInt => \"BIGINT UNSIGNED\",\n            Json => \"JSON\",\n            VarBinary => \"VARBINARY\",\n            Decimal => \"DECIMAL\",\n            Blob => \"BLOB\",\n            MediumBlob => \"MEDIUMBLOB\",\n        }\n    }\n\n    /// The enum constants directly to str.\n    pub const fn as_variant_str(&self) -> &'static str {\n        use Ty::*;\n        macro_rules! _var_str {\n          ($($v:ident) *) => {\n              match self {\n                $($v => stringify!($v),) *\n              }\n          }\n        }\n        return _var_str!(\n            Null Bool TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt\n            Float Double VarChar NChar Timestamp Json VarBinary Decimal Blob MediumBlob\n        );\n    }\n\n    pub fn from_u8(v: u8) -> Self {\n        use Ty::*;\n        match v {\n            0 => Null,\n            1 => Bool,\n            2 => TinyInt,\n            3 => SmallInt,\n            4 => Int,\n            5 => BigInt,\n            6 => Float,\n            7 => Double,\n            8 => VarChar,\n            9 => Timestamp,\n            10 => NChar,\n            11 => UTinyInt,\n            12 => USmallInt,\n            13 => UInt,\n            14 => UBigInt,\n            15 => Json,\n            16 => VarBinary,\n            17 => Decimal,\n            18 => Blob,\n            19 => MediumBlob,\n            _ => unreachable!(\"unknown data type\"),\n        }\n    }\n}\nimpl From<u8> for Ty {\n    fn from(v: u8) -> Self {\n        unsafe { std::mem::transmute(v) }\n    }\n}\n\nimpl Display for Ty {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.name())\n    }\n}\nmacro_rules! _impl_from_primitive {\n    ($($ty:ty) *) => {\n      $(\n         impl From<$ty> for Ty {\n           fn from(v: $ty) -> Self {\n             Self::from_u8(v as _)\n           }\n         }\n      )*\n    }\n}\n\n_impl_from_primitive!(i8 i16 i32 i64 u16 u32 u64);\n","traces":[{"line":108,"address":[2638816,2638848],"length":1,"stats":{"Line":1},"fn_name":"deserialize<&mut serde_json::de::Deserializer<serde_json::read::StrRead>>"},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2280560],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":118,"address":[2280587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2638912,2638976],"length":1,"stats":{"Line":0},"fn_name":"visit_i64<serde::de::value::Error>"},{"line":124,"address":[2638994,2638930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2639040],"length":1,"stats":{"Line":0},"fn_name":"visit_u8<serde::de::value::Error>"},{"line":131,"address":[2639061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2639168,2639104],"length":1,"stats":{"Line":1},"fn_name":"visit_u64<serde_json::error::Error>"},{"line":138,"address":[2639122,2639186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[2639232,2639296],"length":1,"stats":{"Line":0},"fn_name":"visit_str<serde::de::value::Error>"},{"line":145,"address":[2639256,2639320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2639360],"length":1,"stats":{"Line":0},"fn_name":"visit_none<serde::de::value::Error>"},{"line":152,"address":[2639367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2639392],"length":1,"stats":{"Line":0},"fn_name":"visit_unit<serde_json::error::Error>"},{"line":166,"address":[2639399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[2638833,2638861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[2281912,2280624],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":178,"address":[2280651,2280732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[2280748,2280819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[2280791,2280890,2280846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[2280947,2280862,2280903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2280919,2280963,2281007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2280979,2281067,2281023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2281083,2281127,2281039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[2281143,2281187,2281099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2281159,2281203,2281247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[2281307,2281263,2281219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[2281279,2281323,2281367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2281383,2281339,2281427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[2281487,2281399,2281443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[2281503,2281459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[2281579,2281650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[2281666,2281710,2281622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2281770,2281682,2281726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[2281830,2281742,2281786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2281890,2281846,2281802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2281906,2281862,2281972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[2281940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[2282000],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":206,"address":[2282009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2282048],"length":1,"stats":{"Line":1},"fn_name":"is_var_type"},{"line":212,"address":[2282057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[2282128],"length":1,"stats":{"Line":0},"fn_name":"is_primitive"},{"line":217,"address":[2282143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[2282137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[2282208],"length":1,"stats":{"Line":0},"fn_name":"fixed_length"},{"line":236,"address":[2282217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[2282291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[2282305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[2282319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[2282333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[2282344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[2282355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[2282366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2282377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[2282388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[2282399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2282410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[2282421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[2282432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[2282252,2282443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[2282480],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":257,"address":[2282489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[2282518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[2282544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[2282570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[2282596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[2282622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[2282648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[2282674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[2282700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[2282726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[2282752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2282778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[2282804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[2282830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[2282856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[2282882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[2282905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[2282928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[2282951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2282974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[2282997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[2283040],"length":1,"stats":{"Line":1},"fn_name":"as_variant_str"},{"line":291,"address":[2283049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[2283600],"length":1,"stats":{"Line":1},"fn_name":"from_u8"},{"line":299,"address":[2283617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[2283689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[2283699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[2283709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[2283719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[2283729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[2283739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[2283749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[2283759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[2283769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[2283779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[2283789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[2283799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[2283809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2283819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[2283829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[2283839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[2283846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[2283853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[2283860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[2283867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[2283984],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":326,"address":[2283995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[2284016],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":332,"address":[2284038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[2285056,2285120,2285024,2285168,2285200,2285232,2285088],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":340,"address":[2285177,2285065,2285129,2285205,2285093,2285032,2285241],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":117},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","borrowed.rs"],"content":"use super::super::*;\nuse super::*;\nuse serde::{\n    de::{self, value::Error, DeserializeSeed, IntoDeserializer, Visitor},\n    forward_to_deserialize_any,\n};\n\nimpl<'b, 'de: 'b> serde::de::EnumAccess<'de> for BorrowedValue<'b> {\n    type Error = Error;\n\n    type Variant = UnitOnly;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let d = self.strict_as_str().into_deserializer();\n        seed.deserialize(d).map(|v| (v, UnitOnly))\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumTimestampDeserializer<'b> {\n    value: BorrowedValue<'b>,\n}\n\n#[derive(Debug, Clone)]\nstruct EnumValueDeserializer<'b> {\n    value: BorrowedValue<'b>,\n}\n\nimpl<'de, 'b: 'de> serde::de::EnumAccess<'de> for EnumValueDeserializer<'b> {\n    type Error = Error;\n\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        return seed\n            .deserialize(self.value.ty().as_variant_str().into_deserializer())\n            .map(|v| (v, self));\n    }\n}\n\nimpl<'de, 'b: 'de> de::VariantAccess<'de> for EnumValueDeserializer<'b> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        seed.deserialize(self.value)\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        todo!()\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        todo!()\n    }\n}\n\nimpl<'b, 'de> serde::de::EnumAccess<'de> for EnumTimestampDeserializer<'b> {\n    type Error = Error;\n\n    type Variant = VariantTimestampDeserializer;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        // let variant = self.value.ty().as_variant_str();\n        // use BorrowedValue::*;\n\n        match &self.value {\n            BorrowedValue::Timestamp(Timestamp::Microseconds(v)) => Ok((\n                seed.deserialize(\"Microseconds\".into_deserializer())?,\n                VariantTimestampDeserializer { value: *v },\n            )),\n            BorrowedValue::Timestamp(Timestamp::Milliseconds(v)) => Ok((\n                seed.deserialize(\"Milliseconds\".into_deserializer())?,\n                VariantTimestampDeserializer { value: *v },\n            )),\n            BorrowedValue::Timestamp(Timestamp::Nanoseconds(v)) => Ok((\n                seed.deserialize(\"Nanoseconds\".into_deserializer())?,\n                VariantTimestampDeserializer { value: *v },\n            )),\n            _ => todo!(),\n        }\n    }\n}\n\nimpl<'de, 'b: 'de> serde::de::Deserializer<'de> for BorrowedValue<'de> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_any: {self:?}\");\n        use BorrowedValue::*;\n        // todo!()\n        match self {\n            Null => visitor.visit_none(),\n            Bool(v) => visitor.visit_bool(v),\n            TinyInt(v) => visitor.visit_i8(v),\n            SmallInt(v) => visitor.visit_i16(v),\n            Int(v) => visitor.visit_i32(v),\n            BigInt(v) => visitor.visit_i64(v),\n            UTinyInt(v) => visitor.visit_u8(v),\n            USmallInt(v) => visitor.visit_u16(v),\n            UInt(v) => visitor.visit_u32(v),\n            UBigInt(v) => visitor.visit_u64(v),\n            Float(v) => visitor.visit_f32(v),\n            Double(v) => visitor.visit_f64(v),\n            VarChar(v) => visitor.visit_borrowed_str(v),\n            NChar(v) => match v {\n                Cow::Borrowed(v) => visitor.visit_borrowed_str(v),\n                Cow::Owned(v) => visitor.visit_string(v),\n            },\n            Json(v) => match v {\n                Cow::Borrowed(v) => serde_json::Deserializer::from_slice(v)\n                    .deserialize_any(visitor)\n                    .map_err(<Self::Error as de::Error>::custom),\n                Cow::Owned(v) => serde_json::from_slice::<serde_json::Value>(&v)\n                    .map_err(<Self::Error as de::Error>::custom)?\n                    .into_deserializer()\n                    .deserialize_any(visitor)\n                    .map_err(<Self::Error as de::Error>::custom),\n            },\n            Timestamp(v) => visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) => visitor.visit_borrowed_bytes(v),\n            _ => Err(<Self::Error as de::Error>::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    forward_to_deserialize_any! {bool i8 u8 i16 u16 i32 u32 i64 u64 f32 f64 char}\n\n    forward_to_deserialize_any! {\n        unit\n        bytes byte_buf unit_struct\n        tuple identifier ignored_any\n    }\n\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_str: {self:?}\");\n        use BorrowedValue::*;\n        match self {\n            Null => visitor.visit_borrowed_str(\"\"), // todo: empty string or error?\n            Bool(v) => visitor.visit_bool(v),\n            TinyInt(v) => visitor.visit_i8(v),\n            SmallInt(v) => visitor.visit_i16(v),\n            Int(v) => visitor.visit_i32(v),\n            BigInt(v) => visitor.visit_i64(v),\n            UTinyInt(v) => visitor.visit_u8(v),\n            USmallInt(v) => visitor.visit_u16(v),\n            UInt(v) => visitor.visit_u32(v),\n            UBigInt(v) => visitor.visit_u64(v),\n            Float(v) => visitor.visit_f32(v),\n            Double(v) => visitor.visit_f64(v),\n            Json(v) => match v {\n                Cow::Borrowed(v) => std::str::from_utf8(v)\n                    .map_err(<Self::Error as serde::de::Error>::custom)\n                    .and_then(|s| visitor.visit_borrowed_str(s)),\n                Cow::Owned(v) => String::from_utf8(v)\n                    .map_err(<Self::Error as serde::de::Error>::custom)\n                    .and_then(|s| visitor.visit_string(s)),\n            },\n            VarChar(v) => visitor.visit_borrowed_str(v),\n            NChar(v) => match v {\n                Cow::Borrowed(v) => visitor.visit_borrowed_str(v),\n                Cow::Owned(v) => visitor.visit_str(&v),\n            },\n            Timestamp(v) => visitor.visit_string(\n                v.to_naive_datetime()\n                    .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                    .to_string(),\n            ),\n            _ => Err(<Self::Error as de::Error>::custom(\n                \"unsupported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_string\");\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_option\");\n        if self.is_null() {\n            visitor.visit_none()\n        } else {\n            visitor.visit_some(self)\n        }\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::trace!(\"deserialize_newtype_struct: {_name}\");\n        use BorrowedValue::*;\n        macro_rules! _v_ {\n            ($v:expr) => {\n                visitor.visit_newtype_struct($v.into_deserializer())\n            };\n        }\n        // todo!()\n        match self {\n            Null => visitor.visit_none(),\n            Bool(v) => _v_!(v),\n            TinyInt(v) => _v_!(v),\n            SmallInt(v) => _v_!(v),\n            Int(v) => _v_!(v),\n            BigInt(v) => _v_!(v),\n            UTinyInt(v) => _v_!(v),\n            USmallInt(v) => _v_!(v),\n            UInt(v) => _v_!(v),\n            UBigInt(v) => _v_!(v),\n            Float(v) => _v_!(v),\n            Double(v) => _v_!(v),\n            VarChar(v) => _v_!(v),\n            NChar(v) => _v_!(v),\n            Json(v) => match v {\n                Cow::Borrowed(v) => serde_json::Deserializer::from_slice(v)\n                    .deserialize_newtype_struct(_name, visitor)\n                    .map_err(<Self::Error as de::Error>::custom),\n                Cow::Owned(v) => serde_json::from_slice::<serde_json::Value>(&v)\n                    .map_err(<Self::Error as de::Error>::custom)?\n                    .into_deserializer()\n                    .deserialize_newtype_struct(_name, visitor)\n                    .map_err(<Self::Error as de::Error>::custom),\n            },\n            Timestamp(v) => visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) => visitor.visit_borrowed_bytes(v),\n            _ => Err(<Self::Error as de::Error>::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_map\");\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize seq by value\");\n        use BorrowedValue::*;\n        match self {\n            Null => Vec::<u8>::new()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            Json(v) => v.to_vec().into_deserializer().deserialize_seq(visitor),\n            Timestamp(_) => todo!(),\n            VarChar(v) => v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            NChar(v) => v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            VarBinary(v) | Blob(v) | MediumBlob(v) => {\n                v.to_vec().into_deserializer().deserialize_seq(visitor)\n            }\n            _ => todo!(),\n        }\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::trace!(\"deserialize enum with name: {name}, variants: {variants:?}\");\n\n        if name == \"Timestamp\" && variants == TIMESTAMP_VARIANTS {\n            return visitor.visit_enum(EnumTimestampDeserializer { value: self });\n        }\n        if name == \"Value\" && variants == VALUE_VARIANTS {\n            return visitor.visit_enum(EnumValueDeserializer {\n                // variants,\n                value: self,\n            });\n        }\n\n        visitor.visit_enum(self)\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            BorrowedValue::Json(v) => match v {\n                Cow::Borrowed(v) => serde_json::Deserializer::from_slice(v)\n                    .deserialize_struct(name, fields, visitor)\n                    .map_err(<Self::Error as serde::de::Error>::custom),\n                Cow::Owned(v) => serde_json::from_slice::<serde_json::Value>(&v)\n                    .map_err(<Self::Error as de::Error>::custom)?\n                    .into_deserializer()\n                    .deserialize_struct(name, fields, visitor)\n                    .map_err(<Self::Error as de::Error>::custom),\n            },\n            _ => self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_tuple_struct<V>(\n        self,\n        name: &'static str,\n        len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            BorrowedValue::Json(v) => match v {\n                Cow::Borrowed(v) => serde_json::Deserializer::from_slice(v)\n                    .deserialize_tuple_struct(name, len, visitor)\n                    .map_err(<Self::Error as serde::de::Error>::custom),\n                Cow::Owned(v) => serde_json::from_slice::<serde_json::Value>(&v)\n                    .map_err(<Self::Error as de::Error>::custom)?\n                    .into_deserializer()\n                    .deserialize_tuple_struct(name, len, visitor)\n                    .map_err(<Self::Error as de::Error>::custom),\n            },\n            _ => self.deserialize_any(visitor),\n        }\n    }\n}\n\nimpl<'de> serde::de::IntoDeserializer<'de, Error> for BorrowedValue<'de> {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use serde_json::json;\n    use taos_macros::test;\n\n    #[test]\n    fn de_value_as_inner() {\n        use BorrowedValue::*;\n        macro_rules! _de_value {\n            ($($v:expr, $ty:ty, $tv:expr) *) => {\n                $(\n                    {\n                        let d = <$ty>::deserialize($v.into_deserializer()).expect(\"\");\n                        assert_eq!(d, $tv);\n                    }\n                )*\n            }\n        }\n\n        _de_value!(\n            Null, Option<u8>, None\n            TinyInt(-1), i8, -1\n            SmallInt(-1), i16, -1\n            Int(0x0fff_ffff), i32, 0x0fff_ffff\n            BigInt(0xffffffff), i64, 0xffffffff\n            UTinyInt(0xff), u8, 0xff\n            USmallInt(0xffff), u16, 0xffff\n            UInt(0x_ffff_ffff), u32, 0x_ffff_ffff\n            UBigInt(0x_ffff_ffff_ffff_ffff), u64, 0x_ffff_ffff_ffff_ffff\n            Float(1.0), f32, 1.0\n            Double(f64::MAX), f64, f64::MAX\n            VarChar(\"\"), String, \"\".to_string()\n            NChar(\"\".into()), String, \"\".to_string()\n            Timestamp(crate::Timestamp::Milliseconds(1)), crate::Timestamp, crate::Timestamp::Milliseconds(1)\n            VarBinary(&[0, 1,2]), Vec<u8>, vec![0, 1, 2]\n            Blob(&[0, 1,2]), Vec<u8>, vec![0, 1, 2]\n            MediumBlob(&[0, 1,2]), Vec<u8>, vec![0, 1, 2]\n        );\n    }\n\n    #[test]\n    fn de_borrowed_str() {\n        use serde_json::json;\n        use BorrowedValue::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) => {\n                assert!(<&str>::deserialize(($v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) => {\n                assert_eq!(<&str>::deserialize(($v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) => {\n                $(\n                    {\n                        assert!(<&str>::deserialize(($v).into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) => {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            Json(json!({ \"name\": \"abc\"}).to_string().into_bytes().into()), is_err\n            Json(json!(1).to_string().into_bytes().into()), is_err\n            Json(json!(null).to_string().into_bytes().into()), is_err\n            Json(json!(\"abc\").to_string().into_bytes().into()), is_err\n            Timestamp(crate::Timestamp::Milliseconds(0)), is_err\n            ;\n            Null, \"\"\n            VarChar(\"String\"), \"String\"\n            VarChar(\"你好，世界\"), \"你好，世界\"\n        };\n    }\n    #[test]\n    fn de_string() {\n        use serde_json::json;\n        use BorrowedValue::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) => {\n                assert!(String::deserialize(($v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) => {\n                assert_eq!(String::deserialize(($v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $tv:expr) *) => {\n                $(_de_str!($v, $tv);)*\n            };\n            ($($v2:expr, is_err) *; $($v:expr, $tv:expr) * ) => {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            ;\n\n            Null, \"\"\n            Timestamp(crate::Timestamp::Milliseconds(0)), \"1970-01-01T00:00:00\"\n            VarChar(\"String\"), \"String\"\n            VarChar(\"你好，世界\"), \"你好，世界\"\n            Json(json!(\"abc\").to_string().into_bytes().into()), json!(\"abc\").to_string()\n            Json(json!({ \"name\": \"abc\"}).to_string().into_bytes().into()), json!({ \"name\": \"abc\"}).to_string()\n            Json(json!(1).to_string().into_bytes().into()), json!(1).to_string()\n            Json(json!(null).to_string().into_bytes().into()), json!(null).to_string()\n        };\n    }\n\n    #[test]\n    fn de_json() {\n        use serde_json::json;\n        use BorrowedValue::*;\n\n        macro_rules! _de_json {\n            ($v:expr, $ty:ty, $tv:expr) => {{\n                let d = <$ty>::deserialize(\n                    Json($v.to_string().into_bytes().into()).into_deserializer(),\n                )\n                .expect(\"de json\");\n                assert_eq!(d, $tv);\n            }};\n        }\n\n        _de_json!(json!(\"string\"), String, json!(\"string\").to_string());\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Obj {\n            name: String,\n        }\n        _de_json!(\n            json!({ \"name\": \"string\" }),\n            Obj,\n            Obj {\n                name: \"string\".to_string()\n            }\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_json!(json!(\"string\"), JsonStr, JsonStr(\"string\".to_string()));\n    }\n\n    #[test]\n    fn de_newtype_struct() {\n        use serde_json::json;\n        use BorrowedValue::*;\n        macro_rules! _de_ty {\n            ($v:expr, $ty:ty, $tv:expr) => {{\n                let d = <$ty>::deserialize($v.into_deserializer()).expect(\"de type\");\n                assert_eq!(d, $tv);\n            }};\n        }\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_ty!(\n            Json(json!(\"string\").to_string().into_bytes().into()),\n            JsonStr,\n            JsonStr(\"string\".to_string())\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Primi<T>(T);\n        _de_ty!(\n            Json(json!(1).to_string().into_bytes().into()),\n            Primi<i32>,\n            Primi(1)\n        );\n        _de_ty!(TinyInt(1), Primi<i8>, Primi(1));\n        _de_ty!(SmallInt(1), Primi<i64>, Primi(1));\n        _de_ty!(Int(1), Primi<i64>, Primi(1));\n        _de_ty!(BigInt(1), Primi<i64>, Primi(1));\n\n        macro_rules! _de_prim {\n            ($v:ident, $ty:ty, $inner:literal) => {\n                println!(\n                    \"ty: {}, prim: {}\",\n                    stringify!($v),\n                    std::any::type_name::<$ty>()\n                );\n                _de_ty!($v($inner), Primi<$ty>, Primi($inner));\n            };\n        }\n\n        macro_rules! _de_prim_cross {\n            ($($vty:ident) +, $tt:ty) => {\n                $(\n                  _de_prim!($vty, $tt, 1);\n                )*\n            };\n            ($($ty:ty) +) => {\n                $(\n                    _de_prim_cross!(TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt, $ty);\n                )*\n            };\n            () => {\n                _de_prim_cross!(i8 i16 i32 i64 u8 u16 u32 u64);\n            };\n        }\n        _de_prim_cross!();\n    }\n}\n","traces":[{"line":13,"address":[2952792,2952592],"length":1,"stats":{"Line":0},"fn_name":"variant_seed<core::marker::PhantomData<taos_query::common::timestamp::_::{impl#0}::deserialize::__Field>>"},{"line":17,"address":[2952688,2952622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[2641200,2641211],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<core::marker::PhantomData<taos_query::common::timestamp::_::{impl#0}::deserialize::__Field>>"},{"line":37,"address":[2641556,2641232,2641583],"length":1,"stats":{"Line":0},"fn_name":"variant_seed<core::marker::PhantomData<taos_query::common::timestamp::_::{impl#0}::deserialize::__Field>>"},{"line":41,"address":[2641500,2641262,2641415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2641445,2641519,2641294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[2641600,2641624,2641453],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<core::marker::PhantomData<taos_query::common::timestamp::_::{impl#0}::deserialize::__Field>>"},{"line":50,"address":[2074704],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":51,"address":[2074708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[2641680],"length":1,"stats":{"Line":0},"fn_name":"newtype_variant_seed<core::marker::PhantomData<i64>>"},{"line":58,"address":[2641694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2641744,2643081],"length":1,"stats":{"Line":1},"fn_name":"variant_seed<core::marker::PhantomData<taos_query::common::timestamp::_::{impl#0}::deserialize::__Field>>"},{"line":92,"address":[2641766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[2642640,2642020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2642481,2642690,2642037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[2642629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2641946,2642927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[2641963,2642768,2642989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[2642916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[2642094,2642317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[2642110,2642376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[2642306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2958272,2955402,2972084,2952832,2978240,2989034,2972768,2983100,2975397,2985815,2970080,2986345,2986496,2991904,2960992,2969928,2980316,2966124,2991757,2983808,2957592,2975552,2963680,2958126,2969398,2972614,2974844,2977560,2963526,2955552,2980869,2967392,2978090,2981024,2962996,2960844,2960310,2988504,2989184,2991223,2993911,2994441,2967221,2983653,2954868],"length":1,"stats":{"Line":10},"fn_name":"deserialize_any<serde::de::impls::{impl#53}::deserialize::PrimitiveVisitor>"},{"line":117,"address":[2970436,2973124,2961159,2978489,2986745,2967559,2986852,2992260,2955801,2955908,2963937,2958521,2975574,2970102,2958294,2992153,2978262,2981191,2981380,2989540,2955574,2961014,2963840,2981046,2975719,2986663,2967641,2978407,2972790,2952999,2964062,2958628,2975908,2967748,2984057,2963695,2978596,2972935,2958439,2967414,2973017,2953188,2983830,2989433,2991926,2970329,2983975,2989206,2992071,2986518,2975801,2970247,2961348,2989351,2955719,2953081,2984164,2981273,2961241,2952854],"length":1,"stats":{"Line":30},"fn_name":null},{"line":120,"address":[2985097,2975864,2974109,2956904,2982427,2993224,2965327,2955864,2979581,2971431,2959593,2958584,2993193,2986808,2987847,2965293,2982365,2982396,2989496,2990567,2965259,2985128,2954184,2959624,2962312,2976872,2968712,2971400,2974171,2961304,2953144,2978552,2976903,2979612,2956873,2959655,2967704,2971369,2992216,2968743,2962343,2990536,2973080,2976841,2954153,2981336,2993255,2962281,2979643,2984120,2964009,2987816,2968681,2974140,2987785,2954215,2956935,2970392,2990505,2985159],"length":1,"stats":{"Line":10},"fn_name":null},{"line":121,"address":[2991679,2958048,2955324,2975319,2981570,2953378,2989730,2964265,2980791,2987042,2992450,2984354,2972536,2970626,2978786,2956098,2958818,2983575,2986267,2973314,2994363,2976098,2967121,2963448,2978012,2967938,2969850,2960766,2988956,2961538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2989758,2967966,2975314,2956126,2988951,2967084,2973346,2964311,2981602,2980786,2978818,2976126,2991674,2960761,2963443,2961566,2970654,2983570,2986262,2958043,2994358,2953406,2978007,2972531,2955319,2969845,2984382,2958846,2992478,2987070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[2969840,2988946,2956170,2964373,2989802,2967047,2978002,2981650,2963438,2986257,2972526,2994353,2973394,2978866,2960756,2953450,2980781,2987114,2968010,2984426,2991669,2961610,2976170,2970698,2975309,2958038,2958890,2955314,2983565,2992522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[2977997,2972521,2956216,2963433,2978912,2991664,2961652,2984468,2986252,2975304,2981696,2953496,2989848,2988941,2955309,2994348,2992564,2976212,2970740,2973440,2968052,2980776,2958033,2969835,2964433,2960751,2958936,2967010,2987156,2983560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[2964494,2968095,2984511,2956263,2958028,2969830,2994343,2960746,2976255,2966973,2963428,2973487,2992607,2981743,2975299,2953543,2958983,2988936,2989895,2980771,2978959,2970783,2977992,2986247,2991659,2983555,2987199,2972516,2961695,2955304],"length":1,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[2960741,2969825,2968133,2976293,2992645,2977987,2953585,2956305,2984549,2959025,2989937,2973529,2966936,2975294,2991654,2981785,2983550,2979001,2958023,2987237,2961733,2970821,2964550,2972511,2994338,2988931,2955299,2980766,2963423,2986242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[2964936,2969543,2982106,2988649,2980469,2991368,2992950,2956614,2976598,2984854,2959334,2971126,2960455,2968438,2983253,2994056,2957737,2977705,2985960,2979322,2973850,2963141,2955013,2990246,2966417,2974997,2953894,2987542,2962038,2972229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[2977700,2992992,2962080,2959380,2994051,2953940,2960450,2973896,2963136,2964996,2979368,2971168,2974992,2957732,2956660,2982152,2983248,2972224,2955008,2990292,2968480,2969538,2984896,2987584,2991363,2976640,2980464,2985955,2966380,2988644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[2968523,2965057,2979415,2960445,2959427,2988639,2953987,2982199,2973943,2987627,2957727,2980459,2974987,2983243,2976683,2985950,2962123,2990339,2955003,2969533,2971211,2966343,2977695,2963131,2956707,2984939,2993035,2994046,2972219,2991358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[2979457,2965113,2985945,2982241,2954998,2987665,2991353,2974982,2959469,2960440,2988634,2956749,2983238,2971249,2973985,2954029,2969528,2968561,2976721,2980454,2994041,2962161,2984977,2993073,2977690,2957722,2966306,2963126,2972214,2990381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[2953629,2992685,2970861,2959069,2963418,2983545,2979045,2988926,2991649,2966899,2989981,2960736,2980761,2987277,2956349,2973573,2984589,2981829,2986237,2976333,2994333,2964608,2968173,2975289,2969820,2958018,2955294,2972506,2977982,2961773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[2966862,2969815,2973619,2975284,2959111,2992727,2961815,2955289,2964668,2994328,2972501,2980756,2984631,2988921,2991644,2976375,2958013,2981875,2979091,2977977,2968215,2990023,2956391,2953671,2987319,2960731,2963413,2983540,2986232,2970903],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[2956433,2990065,2977972,2973665,2986227,2966825,2969810,2972496,2992769,2955284,2960726,2968257,2964728,2988916,2979137,2980751,2984673,2976417,2991639,2983535,2981921,2963408,2994323,2959153,2953713,2961857,2970945,2987361,2958008,2975279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2972234,2982040,2991373,2984788,2994061,2985965,2973784,2983258,2992884,2961972,2963146,2964872,2956548,2957742,2979256,2990180,2969548,2959268,2953828,2966438,2977710,2987476,2975002,2968372,2976532,2980474,2988654,2971060,2960460,2955018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[2988661,2957922,2986145,2991553,2994241,2980665,2966440,2994068,2966673,2985972,2983449,2972414,2988834,2960467,2957749,2975009,2980481,2983265,2991380,2963153,2963326,2960640,2969728,2975193,2977717,2977890,2955198,2955025,2972241,2969555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2983324,2957915,2980540,2963205,2969721,2972293,2975186,2977883,2986024,2988827,2991546,2983442,2994234,2955077,2988713,2986138,2969607,2975068,2994120,2966504,2963319,2966642,2991432,2972407,2977769,2980658,2960519,2957801,2955191,2960633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2965171,2968596,2976756,2954068,2957024,2962196,2987700,2959508,2987936,2959742,2974024,2974264,2971516,2968830,2985247,2985012,2979496,2956788,2954300,2979736,2993108,2965465,2962428,2993343,2976992,2990420,2990655,2982520,2971284,2982280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2954972,2960414,2962430,2991263,2993345,2957696,2985919,2974944,2954302,2976994,2980340,2954908,2966221,2980416,2965467,2968832,2957632,2990657,2974868,2983200,2982522,2971518,2988544,2966148,2959744,2963100,2977600,2983124,2988608,2991327,2985249,2969502,2993951,2994015,2979738,2957026,2972188,2963036,2985855,2960350,2987938,2974266,2969438,2972124,2977664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[2980332,2983116,2993927,2977576,2972100,2988520,2974860,2969414,2963012,2957608,2991239,2985831,2966140,2954884,2960326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[2980367,2974963,2960357,2969509,2969445,2966268,2960421,2966172,2983151,2985862,2994022,2957703,2983219,2993958,2972131,2972195,2988551,2991334,2954915,2954979,2991270,2985926,2957639,2977671,2963043,2977607,2963107,2980435,2988615,2974895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2980130,2974435,2954356,2957418,2965866,2969352,2977386,2965931,2980246,2985769,2985418,2971687,2993737,2974320,2988330,2962484,2957195,2960136,2965648,2985303,2969224,2959798,2985641,2971910,2962822,2979792,2974774,2974658,2987992,2983030,2991177,2965521,2977048,2979907,2959913,2968886,2990826,2991049,2990711,2988107,2954822,2993399,2957546,2977163,2977514,2971572,2982691,2982914,2966029,2960264,2969001,2982576,2962950,2993865,2972038,2988458,2954471,2954694,2962599,2957080,2993514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[2954662,2993705,2971878,2965834,2982882,2960104,2991017,2977354,2985609,2957386,2974626,2969192,2988298,2980098,2962790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2969328,2972014,2957522,2954798,2980238,2966021,2983022,2993841,2962926,2991153,2977490,2960240,2985745,2974766,2988434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[2974825,2960150,2969238,2974381,2957432,2985364,2983081,2988485,2962836,2966105,2965588,2977109,2985655,2991063,2993892,2962545,2954417,2962977,2959859,2968947,2972065,2977541,2980148,2990772,2993751,2985796,2977400,2991204,2971633,2980297,2982932,2988344,2957141,2957573,2960291,2969379,2982637,2954849,2974676,2988053,2965947,2954708,2965894,2971924,2979853,2993460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2973716,2992816,2955200,2970992,2977892,2979188,2961904,2983451,2994243,2968304,2986147,2972416,2956480,2959200,2987408,2988836,2960642,2963328,2976464,2980667,2953760,2957924,2964798,2966691,2990112,2981972,2991555,2975195,2984720,2969730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[2990543,2985214,2990622,2979588,2979557,2982372,2962395,2993231,2956880,2965235,2956849,2954160,2956911,2971345,2982403,2959600,2976959,2993169,2990512,2974227,2990481,2982341,2971376,2974085,2976817,2979699,2959569,2968719,2956991,2976848,2962288,2968657,2976879,2954129,2965380,2974147,2985104,2954191,2982483,2962257,2993310,2954267,2968688,2979619,2985135,2987823,2959631,2987903,2971407,2965303,2987761,2985073,2993200,2968797,2959709,2987792,2965269,2971483,2974116,2962319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[2968760,2964223,2990584,2976920,2985176,2961497,2958777,2956952,2981529,2956057,2974188,2984313,2987001,2962360,2978745,2979660,2953337,2971448,2976057,2982444,2992409,2989689,2965345,2987864,2959672,2967897,2954232,2993272,2970585,2973273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[3001395,2999520,2998991,2994592,2996901,3001766,2997056,2999366,2996526],"length":1,"stats":{"Line":3},"fn_name":"deserialize_str<chrono::naive::datetime::serde::NaiveDateTimeVisitor>"},{"line":168,"address":[2999777,2994956,2997313,2999542,2999695,2994849,2994614,2997078,2997231,2997420,2994767,2999884],"length":1,"stats":{"Line":9},"fn_name":null},{"line":170,"address":[2997376,2994912,2999840],"length":1,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[3001689,3000074,2997610,2995146,2996824,2999289],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[2997653,3000113,2995189,2999284,2996819,3001684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3001679,2997701,2995237,3000157,2999279,2996814],"length":1,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[3000199,2997747,3001674,2995283,2996809,2999274],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[3000242,3001669,2997794,2996804,2995330,2999269],"length":1,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[2999264,2997836,3000280,3001664,2996799,2995372],"length":1,"stats":{"Line":4},"fn_name":null},{"line":177,"address":[3000588,2998736,3001148,2995696,2996271,2998160],"length":1,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[2996266,3000630,2998206,2995742,3001143,2998731],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[2996261,3000673,2995789,2998726,3001138,2998253],"length":1,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[2996256,3001133,3000711,2998721,2995831,2998295],"length":1,"stats":{"Line":4},"fn_name":null},{"line":181,"address":[2999259,3000320,2996794,2997880,2995416,3001659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[3000362,3001654,2997926,2996789,2999254,2995462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2998432,3000746,2995967,2995870,2998334,3000844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[2995969,2998712,2996199,2996247,2998434,2998664,3000846,3001076,3001124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2643168,2643120,2643142,2643190,2643238,2643216],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<chrono::naive::datetime::serde::NaiveDateTimeVisitor>"},{"line":187,"address":[2996137,3001062,2996023,3001014,3000900,2998602,2998488,2998650,2996185],"length":1,"stats":{"Line":6},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2643264,2643328,2643275,2643339,2643392,2643403],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}<serde::de::impls::StringVisitor>"},{"line":191,"address":[2999249,2997972,3000404,2996784,3001649,2995508],"length":1,"stats":{"Line":4},"fn_name":null},{"line":192,"address":[2998094,3001153,3000522,2998741,2996276,2995630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[2998748,3001160,2999034,2996569,2996283,3001438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[3001210,2996337,2998802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3001589,2996720,2995559,2998023,2999185,3000451],"length":1,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[2995615,2999077,3000507,3001481,2998079,2996612],"length":1,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[2995934,2995105,2997569,3000033,3000810,2998398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[3002373,3001920,3002400],"length":1,"stats":{"Line":2},"fn_name":"deserialize_string<serde::de::impls::StringVisitor>"},{"line":211,"address":[3002051,3001942,3002249,3002130],"length":1,"stats":{"Line":6},"fn_name":null},{"line":212,"address":[3002183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[3004071,3003568,3004098,3004144,3002919,3002416,3002992,3003522,3004647,3002946,3004674,3003495],"length":1,"stats":{"Line":1},"fn_name":"deserialize_option<serde::de::impls::OptionVisitor<chrono::naive::datetime::NaiveDateTime>>"},{"line":219,"address":[3004166,3002626,3004354,3003014,3002438,3004275,3003202,3003590,3003123,3004413,3002547,3003699,3003837,3003778,3002685,3003261],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[3003826,3002783,3003935,3004511,3003359,3004402,3002674,3003250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[3004022,3002870,3003446,3004598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[3002799,3003375,3003951,3004055,3004527,3003479,3002903,3004631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[3039139,3040560,3043140,3016720,3011136,3008559,3019140,3031140,3012557,3024720,3007138,3028557,3008720,3028720,3040720,3024560,3036720,3023139,3012720,3044561,3004720,3016559,3027136,3020720,3032561,3015138,3020561,3036561,3032720,3035140],"length":1,"stats":{"Line":10},"fn_name":"deserialize_newtype_struct<taos_query::common::value::de::borrowed::tests::de_newtype_struct::de_newtype_struct::_::{impl#0}::deserialize::__Visitor<u16>>"},{"line":235,"address":[3005230,3016767,3008767,3025016,3029016,3013113,3012767,3004767,3021230,3032767,3033113,3037113,3024767,3020767,3029113,3033016,3037016,3041016,3041230,3009016,3013016,3009113,3037230,3009230,3029230,3033230,3005113,3036767,3025230,3017113,3021113,3041113,3005016,3025113,3040767,3021016,3013230,3017016,3017230,3028767],"length":1,"stats":{"Line":30},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[3022418,3026418,3026384,3022384,3026452,3010384,3030452,3034418,3006452,3018418,3038418,3042418,3042384,3009185,3006418,3037185,3030418,3021185,3033185,3010418,3010452,3018384,3025185,3014418,3029185,3034384,3034452,3038452,3042452,3030384,3041185,3005185,3014452,3014384,3038384,3013185,3018452,3006384,3022452,3017185],"length":1,"stats":{"Line":10},"fn_name":null},{"line":244,"address":[3040476,3036477,3037441,3029441,3012473,3028473,3033441,3025441,3013441,3044477,3008475,3032477,3021441,3020477,3017441,3024476,3016475,3009441,3005441,3041441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[3008387,3044389,3040388,3032389,3028385,3021467,3024388,3037467,3005467,3033467,3012385,3029467,3013467,3017467,3016387,3009467,3020389,3025467,3036389,3041467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[3017521,3036304,3033521,3041521,3029521,3025521,3009521,3008302,3024303,3037521,3013521,3040303,3028300,3005521,3016302,3021521,3032304,3012300,3044304,3020304],"length":1,"stats":{"Line":8},"fn_name":null},{"line":247,"address":[3005573,3021573,3009573,3032218,3044218,3037573,3024217,3016216,3017573,3025573,3013573,3008216,3041573,3012214,3040217,3033573,3028214,3029573,3020218,3036218],"length":1,"stats":{"Line":8},"fn_name":null},{"line":248,"address":[3032136,3025627,3033627,3024135,3041627,3040135,3009627,3029627,3005627,3021627,3012132,3017627,3013627,3016134,3036136,3037627,3008134,3020136,3028132,3044136],"length":1,"stats":{"Line":8},"fn_name":null},{"line":249,"address":[3036053,3008051,3009675,3016051,3017675,3005675,3013675,3028049,3020053,3033675,3037675,3044053,3029675,3025675,3012049,3024052,3040052,3021675,3041675,3032053],"length":1,"stats":{"Line":8},"fn_name":null},{"line":250,"address":[3042091,3014091,3015541,3031543,3011539,3006091,3026091,3027539,3038091,3039542,3035543,3034091,3010091,3018091,3007541,3019543,3023542,3030091,3022091,3043543],"length":1,"stats":{"Line":8},"fn_name":null},{"line":251,"address":[3039456,3027453,3043457,3019457,3042143,3011453,3034143,3035457,3022143,3023456,3018143,3010143,3014143,3030143,3031457,3007455,3006143,3026143,3015455,3038143],"length":1,"stats":{"Line":8},"fn_name":null},{"line":252,"address":[3007373,3011371,3014197,3030197,3010197,3031375,3022197,3038197,3019375,3018197,3027371,3034197,3023374,3006197,3035375,3039374,3042197,3026197,3015373,3043375],"length":1,"stats":{"Line":8},"fn_name":null},{"line":253,"address":[3023291,3019292,3030245,3026245,3027288,3031292,3015290,3006245,3010245,3007290,3034245,3039291,3038245,3011288,3014245,3042245,3018245,3035292,3043292,3022245],"length":1,"stats":{"Line":8},"fn_name":null},{"line":254,"address":[3025726,3019969,3031969,3033726,3021726,3023968,3009726,3007967,3013726,3017726,3015967,3035969,3039968,3037726,3043969,3029726,3027965,3005726,3041726,3011965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[3029780,3027881,3023884,3039884,3025780,3043885,3033780,3041780,3007883,3005780,3019885,3017780,3011881,3031885,3037780,3021780,3013780,3035885,3009780,3015883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[3037834,3027793,3029834,3043797,3007795,3013834,3005834,3019797,3039796,3015795,3009834,3017834,3041834,3035797,3021834,3025834,3011793,3023796,3033834,3031797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[3039627,3041977,3009977,3033977,3037977,3007626,3017977,3043628,3023627,3029977,3021977,3011624,3025977,3031628,3015626,3035628,3019628,3013977,3005977,3027624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[3042547,3010296,3034296,3030547,3038296,3026296,3006545,3034547,3026543,3022546,3010543,3042296,3018547,3006296,3022296,3030296,3014296,3014545,3018296,3038546],"length":1,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[3019263,3026545,3011259,3007261,3007194,3014547,3023195,3031196,3039262,3018549,3042549,3027259,3022548,3023262,3011192,3027192,3034549,3006547,3010545,3031263,3015261,3035196,3035263,3043196,3015194,3019196,3043263,3039195,3030549,3038548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[3023155,3007154,3027152,3035156,3019156,3039155,3043156,3015154,3011152,3031156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[3007268,3027199,3023202,3031203,3031270,3035203,3015201,3011266,3019203,3019270,3023269,3007201,3035270,3027266,3039269,3039202,3011199,3015268,3043203,3043270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[3006601,3039090,3010714,3038602,3034718,3018603,3011087,3038717,3042603,3018944,3018718,3014601,3015089,3006716,3038943,3010599,3027087,3007089,3023090,3022717,3026714,3022602,3026599,3006942,3042718,3014716,3034944,3043091,3014942,3031091,3030718,3019091,3030944,3034603,3035091,3042944,3022943,3030603,3010940,3026940],"length":1,"stats":{"Line":9},"fn_name":null},{"line":263,"address":[3018912,3010908,3030912,3026908,3022911,3006910,3042912,3034912,3038911,3014910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[3015049,3035051,3007049,3031051,3039050,3011047,3027047,3043051,3023050,3019051],"length":1,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[3015119,3014956,3022663,3027117,3034664,3023120,3035121,3031121,3019121,3010954,3043121,3039120,3018664,3030958,3042958,3006956,3038957,3018958,3006662,3026954,3042664,3011117,3010660,3030664,3007119,3022957,3038663,3034958,3014662,3026660],"length":1,"stats":{"Line":3},"fn_name":null},{"line":268,"address":[3019714,3029906,3027710,3005906,3007712,3021906,3033906,3023713,3025906,3041906,3011710,3015712,3031714,3017906,3037906,3013906,3043714,3035714,3039713,3009906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[3006394,3014512,3006512,3038428,3010360,3010510,3014360,3042394,3022513,3034514,3026510,3038513,3006428,3010428,3022394,3018428,3034360,3014394,3026394,3026428,3038360,3022360,3042360,3034428,3006360,3042428,3030394,3026360,3018394,3018360,3038394,3042514,3022428,3010394,3014428,3030360,3030428,3034394,3030514,3018514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3038472,3037397,3009397,3017397,3030472,3025397,3033397,3042472,3041397,3013397,3021397,3005397,3026472,3010472,3022472,3029397,3018472,3014472,3034472,3006472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3044720,3045825,3046225],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq<serde::de::impls::{impl#19}::deserialize::VecVisitor<u8>>"},{"line":288,"address":[3044879,3044961,3044742,3045059],"length":1,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[3045543,3045024,3045574,3045512],"length":1,"stats":{"Line":4},"fn_name":null},{"line":291,"address":[3045198,3046179,3046151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[3046163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3045679,3045419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[3046060,3046123,3045225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[3046107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[3045350,3046021,3045958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[3046028,3046005,3045836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[3045488,3045519,3045550],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[3045578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[3047412,3047439,3046304],"length":1,"stats":{"Line":1},"fn_name":"deserialize_enum<taos_query::common::timestamp::_::{impl#0}::deserialize::__Visitor>"},{"line":322,"address":[3046467,3046549,3046352,3046637],"length":1,"stats":{"Line":3},"fn_name":null},{"line":324,"address":[3046607,3046874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[3046983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[3046943,3047116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[3047274,3047325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[3047282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[3047195,3047393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[3048363,3048524,3047456],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct<taos_query::common::value::de::borrowed::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor>"},{"line":346,"address":[3047530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[3047753,3047576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[3048481,3047755,3048420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3048399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[3048488,3048427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[3047912,3047803,3048135,3048317],"length":1,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[3048103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[3048293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[3048344,3047858,3048149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[3047625,3047732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[1945264],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":390,"address":[1945272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":401,"address":[2411801,2411792],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":402,"address":[2896060,2892768,2896087],"length":1,"stats":{"Line":1},"fn_name":"de_value_as_inner"},{"line":415,"address":[2897843,2893242,2892783,2894012,2895046,2895615,2896306,2896661,2897036,2895784,2897388,2896877,2895327,2897946,2892991,2894782,2896071,2897128,2893753,2893496,2894525,2897491,2897583,2898038,2894267,2896199],"length":1,"stats":{"Line":21},"fn_name":null},{"line":416,"address":[2892775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[2892975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[2893224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[2893477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[2893732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[2893996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[2894249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[2894506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[2894762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[2895021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[2895302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[2895580,2895758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[2896102,2896280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[2896597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[2897085,2896842,2897024],"length":1,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[2897540,2897479,2897353],"length":1,"stats":{"Line":3},"fn_name":null},{"line":432,"address":[2897808,2897934,2897995],"length":1,"stats":{"Line":3},"fn_name":null},{"line":436,"address":[2411840,2411849],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":437,"address":[2898416,2898558],"length":1,"stats":{"Line":1},"fn_name":"de_borrowed_str"},{"line":464,"address":[2898588,2899349,2900844,2898447,2898612,2899720,2899901,2900449,2900609,2901391,2901917,2898797,2898983,2899534,2901150,2902167,2901005,2901306,2902698,2901541,2901743,2900694,2899165,2898423,2902441,2900299],"length":1,"stats":{"Line":18},"fn_name":null},{"line":465,"address":[2898431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[2898594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[2898778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[2898963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[2899149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[2899331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[2899515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[2899700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[2900359,2899931,2899886],"length":1,"stats":{"Line":3},"fn_name":null},{"line":474,"address":[2900639,2900754,2900587],"length":1,"stats":{"Line":3},"fn_name":null},{"line":475,"address":[2901035,2900982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":476,"address":[2901336,2901451,2901284],"length":1,"stats":{"Line":3},"fn_name":null},{"line":477,"address":[2901679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[2901909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[2902132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[2902406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[2411897,2411888],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":485,"address":[2902896,2903067],"length":1,"stats":{"Line":1},"fn_name":"de_string"},{"line":508,"address":[2904896,2907134,2903124,2904106,2908016,2903713,2906194,2903321,2908166,2903519,2908260,2905582,2907221,2907630,2905950,2903100,2902903,2908805,2908361,2906295,2906100,2904304,2908913,2902935,2905242,2904490,2906984,2903909],"length":1,"stats":{"Line":18},"fn_name":null},{"line":510,"address":[2902919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[2903106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[2903302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[2903499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[2903697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[2903891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[2904087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[2904284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[2904482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[2904832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[2905207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[2905547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[2905875,2906010,2906172,2906238],"length":1,"stats":{"Line":4},"fn_name":null},{"line":525,"address":[2907214,2906603,2907044,2907265],"length":1,"stats":{"Line":4},"fn_name":null},{"line":526,"address":[2908076,2908238,2907941,2908304],"length":1,"stats":{"Line":4},"fn_name":null},{"line":527,"address":[2908887,2908669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[2411945,2411936],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":532,"address":[2909666,2909344],"length":1,"stats":{"Line":1},"fn_name":"de_json"},{"line":546,"address":[2909351,2909692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[2910448,2910823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":553,"address":[2910094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[2910783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[2910756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[2911035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[2420752,2420761],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":566,"address":[2912512,2912841],"length":1,"stats":{"Line":1},"fn_name":"de_newtype_struct"},{"line":577,"address":[2912750,2912971,2912600,2912875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[2912525,2912660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":580,"address":[2912904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[2913425,2913683,2913275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[2913200,2913335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[2913948,2913628,2913727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":591,"address":[2914215,2913891,2913992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":592,"address":[2914259,2914157,2914483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":593,"address":[2914739,2914527,2914424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[2914783,2914692,2944490],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":156,"coverable":248},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","mod.rs"],"content":"//! Value de-serialization.\n//!\n//! All values queried from TDengine sql could be deserialized to a Rust type.\n//! Commonly, you can deserialize a value directly into a [crate::common::Value].\n//!\nuse serde::de::value::Error;\nuse serde::{de, forward_to_deserialize_any};\n\nconst TIMESTAMP_VARIANTS: [&str; 3] = [\"Milliseconds\", \"Microseconds\", \"Nanoseconds\"];\nconst VALUE_VARIANTS: [&str; 20] = [\n    \"Null\",\n    \"Bool\",\n    \"TinyInt\",\n    \"SmallInt\",\n    \"Int\",\n    \"BigInt\",\n    \"Float\",\n    \"Double\",\n    \"VarChar\",\n    \"Timestamp\",\n    \"NChar\",\n    \"UTinyInt\",\n    \"USmallInt\",\n    \"UInt\",\n    \"UBigInt\",\n    \"Json\",\n    \"VarBinary\",\n    \"Decimal\",\n    \"Blob\",\n    \"MediumBlob\",\n];\n\npub struct UnitOnly;\n\nimpl<'de> de::VariantAccess<'de> for UnitOnly {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        Err(de::Error::invalid_type(\n            de::Unexpected::UnitVariant,\n            &\"newtype variant\",\n        ))\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            de::Unexpected::UnitVariant,\n            &\"tuple variant\",\n        ))\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            de::Unexpected::UnitVariant,\n            &\"struct variant\",\n        ))\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct VariantTimestampDeserializer {\n    value: i64,\n}\nimpl<'de> de::Deserializer<'de> for VariantTimestampDeserializer {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_i64(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\n\nimpl<'de> de::VariantAccess<'de> for VariantTimestampDeserializer {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(self)\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        todo!()\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        todo!()\n    }\n}\n\nmod borrowed;\nmod ref_value;\n\nmod value;\n","traces":[{"line":38,"address":[2770144],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":39,"address":[2770148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2396667,2395723,2395360,2396304,2396410,2395867,2396267,2396976,2395591,2395904,2396811,2396704,2396848,2396432,2397120,2397225,2395232,2395338,2396135,2396954,2396560,2397355,2397248,2395488,2395616,2396010,2397083,2396160,2396032,2396535,2395465,2395760],"length":1,"stats":{"Line":0},"fn_name":"newtype_variant_seed<core::marker::PhantomData<u32>>"},{"line":46,"address":[2396122,2396522,2396322,2395506,2396650,2395250,2396994,2395578,2395994,2395322,2396450,2395450,2396938,2396050,2395706,2395378,2396578,2395634,2395922,2396178,2397066,2397338,2395778,2397210,2396794,2395850,2396866,2397266,2396722,2396250,2396394,2397138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2397133,2396861,2395773,2396045,2396717,2396173,2395373,2396573,2397261,2396317,2395629,2396989,2396445,2395245,2395501,2395917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2397424,2397648,2397520,2397552,2397456,2397680,2397872,2397840,2397392,2397744,2397712,2397616,2397776,2397808,2397584,2397488],"length":1,"stats":{"Line":1},"fn_name":"deserialize_any<serde::de::impls::BoolVisitor>"},{"line":88,"address":[2397728,2397824,2397568,2397472,2397664,2397696,2397440,2397792,2397856,2397888,2397536,2397600,2397632,2397504,2397408,2397760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[2770176],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":102,"address":[2770185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2398384,2398064,2397968,2398160,2398352,2397936,2398224,2398256,2398000,2398032,2398128,2398192,2398096,2397904,2398288,2398320],"length":1,"stats":{"Line":1},"fn_name":"newtype_variant_seed<core::marker::PhantomData<u64>>"},{"line":109,"address":[2397920,2398400,2398304,2398176,2397952,2397984,2398368,2398048,2398144,2398112,2398336,2398272,2398208,2398016,2398240,2398080],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":18},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","ref_value.rs"],"content":"use super::super::*;\nuse super::*;\nuse serde::{\n    de::{self, value::Error, DeserializeSeed, IntoDeserializer, Visitor},\n    forward_to_deserialize_any,\n};\n\nimpl<'de, 'v> serde::de::EnumAccess<'de> for &'v Value {\n    type Error = Error;\n\n    type Variant = UnitOnly;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let s = self.strict_as_str();\n        return Ok((\n            seed.deserialize(StringDeserializer {\n                input: s.to_string(),\n            })?,\n            UnitOnly,\n        ));\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumTimestampDeserializer<'v> {\n    value: &'v Value,\n}\n\nimpl<'v, 'de> serde::de::EnumAccess<'de> for EnumTimestampDeserializer<'v> {\n    type Error = Error;\n\n    type Variant = VariantTimestampDeserializer;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        // let variant = self.value.ty().as_variant_str();\n        // use BorrowedValue::*;\n        match self.value {\n            Value::Timestamp(Timestamp::Microseconds(v)) => Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Microseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: *v },\n            )),\n            Value::Timestamp(Timestamp::Milliseconds(v)) => Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Milliseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: *v },\n            )),\n            Value::Timestamp(Timestamp::Nanoseconds(v)) => Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Nanoseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: *v },\n            )),\n            _ => todo!(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumValueDeserializer<'v> {\n    value: &'v Value,\n}\n\n#[derive(Clone)]\nstruct StringDeserializer {\n    input: String,\n}\n\nimpl<'de> de::Deserializer<'de> for StringDeserializer {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_string(self.input)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\nimpl<'de, 'v: 'de> serde::de::EnumAccess<'de> for EnumValueDeserializer<'v> {\n    type Error = Error;\n\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        let variant = self.value.ty().as_variant_str();\n\n        Ok((\n            seed.deserialize(StringDeserializer {\n                input: variant.to_string(),\n            })\n            .expect(\"\"),\n            self,\n        ))\n    }\n}\n\nimpl<'de, 'v: 'de> de::VariantAccess<'de> for EnumValueDeserializer<'v> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        seed.deserialize(self.value)\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        todo!()\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        todo!()\n    }\n}\n\nimpl<'de, 'v: 'de> serde::de::Deserializer<'de> for &'v Value {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_any: {self:?}\");\n        use Value::*;\n        // todo!()\n        match self {\n            Null => visitor.visit_none(),\n            Bool(v) => visitor.visit_bool(*v),\n            TinyInt(v) => visitor.visit_i8(*v),\n            SmallInt(v) => visitor.visit_i16(*v),\n            Int(v) => visitor.visit_i32(*v),\n            BigInt(v) => visitor.visit_i64(*v),\n            UTinyInt(v) => visitor.visit_u8(*v),\n            USmallInt(v) => visitor.visit_u16(*v),\n            UInt(v) => visitor.visit_u32(*v),\n            UBigInt(v) => visitor.visit_u64(*v),\n            Float(v) => visitor.visit_f32(*v),\n            Double(v) => visitor.visit_f64(*v),\n            VarChar(v) => visitor.visit_borrowed_str(v),\n            NChar(v) => visitor.visit_borrowed_str(v),\n            Json(v) => v\n                .clone()\n                .into_deserializer()\n                .deserialize_any(visitor)\n                .map_err(<Self::Error as de::Error>::custom),\n            Timestamp(v) => visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) => visitor.visit_borrowed_bytes(v),\n            _ => Err(<Self::Error as de::Error>::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    serde::forward_to_deserialize_any! {bool i8 u8 i16 u16 i32 u32 i64 u64 f32 f64 char}\n\n    serde::forward_to_deserialize_any! {\n        unit\n        bytes byte_buf unit_struct\n        tuple_struct tuple identifier ignored_any\n    }\n\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_str\");\n        use Value::*;\n        match self {\n            Null => visitor.visit_borrowed_str(\"\"), // todo: empty string or error?\n            Bool(v) => visitor.visit_bool(*v),\n            TinyInt(v) => visitor.visit_i8(*v),\n            SmallInt(v) => visitor.visit_i16(*v),\n            Int(v) => visitor.visit_i32(*v),\n            BigInt(v) => visitor.visit_i64(*v),\n            UTinyInt(v) => visitor.visit_u8(*v),\n            USmallInt(v) => visitor.visit_u16(*v),\n            UInt(v) => visitor.visit_u32(*v),\n            UBigInt(v) => visitor.visit_u64(*v),\n            Float(v) => visitor.visit_f32(*v),\n            Double(v) => visitor.visit_f64(*v),\n            VarChar(v) | NChar(v) => visitor.visit_borrowed_str(v),\n            Json(v) => visitor.visit_string(v.to_string()),\n            Timestamp(v) => visitor.visit_string(\n                v.to_naive_datetime()\n                    .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                    .to_string(),\n            ),\n            _ => Err(<Self::Error as de::Error>::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_string\");\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_option\");\n        if self.is_null() {\n            visitor.visit_none()\n        } else {\n            visitor.visit_some(self)\n        }\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::trace!(\"deserialize_newtype_struct: {_name}\");\n        use Value::*;\n        macro_rules! _v_ {\n            ($v:expr) => {\n                visitor.visit_newtype_struct($v.into_deserializer())\n            };\n        }\n        match self {\n            Null => visitor.visit_none(),\n            Bool(v) => _v_!(v),\n            TinyInt(v) => _v_!(v),\n            SmallInt(v) => _v_!(v),\n            Int(v) => _v_!(v),\n            BigInt(v) => _v_!(v),\n            UTinyInt(v) => _v_!(v),\n            USmallInt(v) => _v_!(v),\n            UInt(v) => _v_!(v),\n            UBigInt(v) => _v_!(v),\n            Float(v) => _v_!(v),\n            Double(v) => _v_!(v),\n            VarChar(v) | NChar(v) => visitor.visit_newtype_struct(v.as_str().into_deserializer()),\n            Json(v) => visitor\n                .visit_newtype_struct(v.clone().into_deserializer())\n                .map_err(<Self::Error as de::Error>::custom),\n            Timestamp(v) => _v_!(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) => {\n                visitor.visit_newtype_struct(v.as_slice().into_deserializer())\n            }\n            _ => Err(<Self::Error as de::Error>::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_map\");\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize seq by value\");\n        use Value::*;\n        match self {\n            Null => Vec::<u8>::new()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            Json(v) => v\n                .clone()\n                .into_deserializer()\n                .deserialize_seq(visitor)\n                .map_err(<Self::Error as de::Error>::custom),\n            VarChar(v) | NChar(v) => v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            VarBinary(v) | Blob(v) | MediumBlob(v) => {\n                v.clone().into_deserializer().deserialize_any(visitor)\n            }\n            _ => self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::trace!(\"name: {name}, variants: {variants:?}\");\n\n        if name == \"Timestamp\" && variants == TIMESTAMP_VARIANTS {\n            return visitor.visit_enum(EnumTimestampDeserializer { value: self });\n        }\n        if name == \"Value\" && variants == VALUE_VARIANTS {\n            return visitor.visit_enum(EnumValueDeserializer {\n                // variants,\n                value: self,\n            });\n        }\n\n        visitor.visit_enum(self)\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Json(json) => json\n                .clone()\n                .into_deserializer()\n                .deserialize_struct(name, fields, visitor)\n                .map_err(<Self::Error as serde::de::Error>::custom),\n            _ => self.deserialize_any(visitor),\n        }\n    }\n}\n\nimpl<'de, 'b: 'de> serde::de::IntoDeserializer<'de, Error> for &'b Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use serde_json::json;\n    use taos_macros::test;\n\n    #[test]\n    fn value_de_value_ref() {\n        use std::cmp::PartialEq;\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr) *) => {\n                $(\n                    {\n                        let v = &$v;\n                        let d = Value::deserialize(v.into_deserializer()).expect(\"\");\n                        assert!(dbg!(d).eq(&$v));\n                    }\n                )*\n            }\n        }\n        _de_value!(\n            Null Bool(true) TinyInt(0xf) SmallInt(0xfff) Int(0xffff) BigInt(-1) Float(1.0) Double(1.0)\n            UTinyInt(0xf) USmallInt(0xfff) UInt(0xffff) UBigInt(0xffffffff)\n            Timestamp(crate::common::timestamp::Timestamp::Milliseconds(0)) VarChar(\"anything\".to_string())\n            NChar(\"你好，世界\".to_string()) VarBinary(vec![1,2,3]) Blob(vec![1,2, 3]) MediumBlob(vec![1,2,3])\n            Json(serde_json::json!({\"name\": \"ABC\"}))\n        );\n    }\n\n    #[test]\n    fn de_value_as_inner() {\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr, $ty:ty, $tv:expr) *) => {\n                $(\n                    {\n                        let v = &$v;\n                        let d = <$ty>::deserialize(v.into_deserializer()).expect(\"\");\n                        assert_eq!(d, $tv);\n                    }\n                )*\n            }\n        }\n\n        _de_value!(\n            Null, Option<u8>, None\n            TinyInt(-1), i8, -1\n            SmallInt(-1), i16, -1\n            Int(0x0fff_ffff), i32, 0x0fff_ffff\n            BigInt(0xffffffff), i64, 0xffffffff\n            UTinyInt(0xff), u8, 0xff\n            USmallInt(0xffff), u16, 0xffff\n            UInt(0x_ffff_ffff), u32, 0x_ffff_ffff\n            UBigInt(0x_ffff_ffff_ffff_ffff), u64, 0x_ffff_ffff_ffff_ffff\n            Float(1.0), f32, 1.0\n            Double(f64::MAX), f64, f64::MAX\n            VarChar(\"\".to_string()), String, \"\".to_string()\n            NChar(\"\".to_string()), String, \"\".to_string()\n            Timestamp(crate::Timestamp::Milliseconds(1)), crate::Timestamp, crate::Timestamp::Milliseconds(1)\n            VarBinary(vec![0, 1,2]), Vec<u8>, vec![0, 1, 2]\n            Blob(vec![0, 1,2]), Vec<u8>, vec![0, 1, 2]\n            MediumBlob(vec![0, 1,2]), Vec<u8>, vec![0, 1, 2]\n        );\n    }\n\n    #[test]\n    fn de_borrowed_str() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) => {\n                assert!(<&str>::deserialize((&$v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) => {\n                assert_eq!(<&str>::deserialize((&$v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) => {\n                $(\n                    {\n                        assert!(<&str>::deserialize(($v).into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) => {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            Json(json!({ \"name\": \"abc\"})), is_err\n            Json(json!(1)), is_err\n            Json(json!(null)), is_err\n            Json(json!(\"abc\")), is_err\n            Timestamp(crate::Timestamp::Milliseconds(0)), is_err\n            ;\n            Null, \"\"\n            VarChar(\"String\".to_string()), \"String\"\n            VarChar(\"你好，世界\".to_string()), \"你好，世界\"\n        };\n    }\n    #[test]\n    fn de_string() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) => {\n                assert!(String::deserialize((&$v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) => {\n                assert_eq!(String::deserialize((&$v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) => {\n                $(\n                    {\n                        assert!(String::deserialize(($v).into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) => {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            ;\n\n            Null, \"\"\n            Timestamp(crate::Timestamp::Milliseconds(0)), \"1970-01-01T00:00:00\"\n            VarChar(\"String\".to_string()), \"String\"\n            VarChar(\"你好，世界\".to_string()), \"你好，世界\"\n            Json(json!(\"abc\")), json!(\"abc\").to_string()\n            Json(json!({ \"name\": \"abc\"})), json!({ \"name\": \"abc\"}).to_string()\n            Json(json!(1)), json!(1).to_string()\n            Json(json!(null)), json!(null).to_string()\n        };\n    }\n\n    #[test(log_level = \"trace\")]\n    fn de_json() {\n        use Value::*;\n\n        macro_rules! _de_json {\n            ($v:expr, $ty:ty, $tv:expr) => {{\n                let v = &Json($v);\n                let d = <$ty>::deserialize(v.into_deserializer()).expect(\"de json\");\n                assert_eq!(d, $tv);\n            }};\n        }\n\n        _de_json!(\n            serde_json::json!(\"string\"),\n            String,\n            \"\\\"string\\\"\".to_string()\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Obj {\n            name: String,\n        }\n        _de_json!(\n            serde_json::json!({ \"name\": \"string\" }),\n            Obj,\n            Obj {\n                name: \"string\".to_string()\n            }\n        );\n    }\n\n    #[test(log_level = \"trace\")]\n    fn de_newtype_struct() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_ty {\n            ($v:expr, $ty:ty, $tv:expr) => {{\n                let d = <$ty>::deserialize((&$v).into_deserializer()).expect(\"de type\");\n                assert_eq!(d, $tv);\n            }};\n        }\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_ty!(\n            Json(json!(\"string\")),\n            JsonStr,\n            JsonStr(\"string\".to_string())\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Primi<T>(T);\n        _de_ty!(Json(json!(1)), Primi<i32>, Primi(1));\n        _de_ty!(TinyInt(1), Primi<i8>, Primi(1));\n        _de_ty!(SmallInt(1), Primi<i64>, Primi(1));\n        _de_ty!(Int(1), Primi<i64>, Primi(1));\n        _de_ty!(BigInt(1), Primi<i64>, Primi(1));\n\n        macro_rules! _de_prim {\n            ($v:ident, $ty:ty, $inner:literal) => {\n                log::info!(\n                    \"ty: {}, prim: {}\",\n                    stringify!($v),\n                    std::any::type_name::<$ty>()\n                );\n                _de_ty!($v($inner), Primi<$ty>, Primi($inner));\n            };\n        }\n\n        macro_rules! _de_prim_cross {\n            ($($vty:ident) +, $tt:ty) => {\n                $(\n                  _de_prim!($vty, $tt, 1);\n                )*\n            };\n            ($($ty:ty) +) => {\n                $(\n                    _de_prim_cross!(TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt, $ty);\n                )*\n            };\n            () => {\n                _de_prim_cross!(i8 i16 i32 i64 u8 u16 u32 u64);\n            };\n        }\n        _de_prim_cross!();\n    }\n}\n","traces":[{"line":13,"address":[3049019,3049056,3048608,3049467],"length":1,"stats":{"Line":0},"fn_name":"variant_seed<core::marker::PhantomData<taos_query::common::value::_::{impl#0}::deserialize::__Field>>"},{"line":17,"address":[3048736,3049092,3049184,3048644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3049377,3048929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[3048898,3049017,3049334,3048976,3049424,3049465,3048886,3048817,3049200,3049346,3049265,3048752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3049224,3048776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[2733444,2733472,2732352,2734564],"length":1,"stats":{"Line":2},"fn_name":"variant_seed<core::marker::PhantomData<taos_query::common::timestamp::_::{impl#0}::deserialize::__Field>>"},{"line":43,"address":[2733502,2732382],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[2733708,2734283,2732588,2733163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2732605,2734157,2733725,2734219,2733099,2733037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2732621,2733741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2734272,2733152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2733640,2732520,2733387,2734507],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[2733657,2734369,2733249,2734440,2733320,2732537],"length":1,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[2732553,2733673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2734496,2733376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[2732656,2733776,2734055,2732935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[2732673,2733793,2733917,2732797,2733988,2732868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2732689,2733809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2734044,2732924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2734656,2734592],"length":1,"stats":{"Line":3},"fn_name":"deserialize_any<taos_query::common::timestamp::_::{impl#0}::deserialize::__FieldVisitor>"},{"line":87,"address":[2734667,2734603],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[2734720,2735136,2735529,2735113],"length":1,"stats":{"Line":1},"fn_name":"variant_seed<core::marker::PhantomData<taos_query::common::value::_::{impl#0}::deserialize::__Field>>"},{"line":105,"address":[2734758,2735174,2734838,2735254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[2735070,2735486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[2734890,2734955,2735011,2735371,2735306,2735427],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2734911,2735327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2833104],"length":1,"stats":{"Line":1},"fn_name":"unit_variant"},{"line":121,"address":[2833113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[2735776,2735552,2735648,2735584,2735712,2735680,2735744,2735616,2735904,2735808,2735872,2735968,2735936,2736000,2736032,2735840],"length":1,"stats":{"Line":15},"fn_name":"newtype_variant_seed<core::marker::PhantomData<i8>>"},{"line":128,"address":[2735568,2735664,2735824,2735696,2735600,2735920,2735760,2735888,2735952,2735856,2736016,2736048,2735792,2735984,2735632,2735728],"length":1,"stats":{"Line":15},"fn_name":null},{"line":153,"address":[3080402,3049504,3055629,3065910,3067964,3070096,3061730,3063786,3051568,3068000,3059776,3053581,3070049,3072096,3078302,3072055,3061776,3074142,3074192,3055664,3057674,3051518,3059726,3078352,3053616,3057712,3065952,3076240,3063824,3076288],"length":1,"stats":{"Line":12},"fn_name":"deserialize_any<taos_query::common::value::de::ref_value::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor>"},{"line":157,"address":[3064074,3074555,3051736,3068363,3072127,3076456,3070261,3063855,3059804,3072264,3060136,3068168,3049867,3055695,3055914,3066315,3066120,3068031,3051931,3053866,3049754,3063992,3057880,3064187,3078602,3074360,3076538,3049535,3066202,3053647,3061807,3051818,3055832,3072346,3074223,3062026,3070343,3056027,3070456,3053784,3076319,3059941,3076651,3078520,3072459,3070124,3078715,3062139,3057962,3078383,3074442,3068250,3058075,3061944,3051599,3060023,3049672,3057743,3065983,3053979],"length":1,"stats":{"Line":36},"fn_name":null},{"line":160,"address":[3050926,3059090,3069432,3060081,3073528,3050882,3057064,3067374,3075646,3052968,3079806,3061159,3077688,3057086,3073550,3073506,3074500,3077666,3072404,3069454,3067330,3052946,3055972,3063198,3065250,3070401,3059112,3052990,3058020,3065294,3079762,3076596,3050904,3065272,3077710,3064132,3059134,3057042,3078660,3061137,3075624,3063154,3067352,3071457,3054994,3063176,3062084,3051876,3053924,3055016,3055038,3068308,3049812,3069410,3075602,3061115,3066260,3071435,3079784,3071479],"length":1,"stats":{"Line":12},"fn_name":null},{"line":161,"address":[3074137,3076235,3057669,3051513,3056220,3064380,3066508,3061725,3072050,3053576,3065905,3067959,3059721,3058268,3080397,3054172,3068556,3050060,3078297,3062332,3072652,3074748,3052124,3078908,3063781,3070044,3055624,3060326,3070646,3076844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3057664,3050086,3078292,3051508,3052150,3072045,3064410,3067954,3053571,3060349,3055619,3068582,3059716,3070039,3061720,3072678,3078934,3058294,3056246,3080392,3074132,3066534,3063776,3054198,3062358,3070669,3076230,3065900,3076870,3074774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3056299,3050139,3064467,3054251,3058347,3065895,3057659,3078287,3080387,3074127,3078987,3072040,3076225,3053566,3059711,3060399,3055614,3066587,3061715,3051503,3062411,3074827,3070034,3076923,3072731,3063771,3070719,3052203,3068635,3067949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[3080382,3070769,3059706,3070029,3068692,3078282,3061710,3065890,3055609,3062464,3067944,3074122,3054304,3050192,3057654,3060449,3072035,3076220,3052256,3064524,3053561,3076976,3066640,3058400,3051498,3072788,3079044,3074884,3063766,3056352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3074117,3056405,3072845,3072030,3062517,3074941,3070024,3055604,3066693,3052309,3063761,3065885,3078277,3060499,3064581,3053556,3079101,3050245,3051493,3054357,3057649,3058453,3067939,3061705,3068749,3080377,3076215,3059701,3077029,3070819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[3072901,3072025,3056457,3068805,3061700,3079157,3059696,3077081,3070868,3078272,3058505,3057644,3066745,3067934,3070019,3054409,3055599,3051488,3050297,3062569,3064637,3074112,3063756,3060548,3052361,3065880,3076210,3053551,3074997,3080372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[3071760,3067660,3077405,3059422,3067069,3065594,3077998,3054733,3075325,3079485,3073229,3061435,3055325,3057370,3050621,3073834,3064973,3063482,3080094,3056781,3069741,3058829,3052685,3053277,3060863,3069133,3062893,3071183,3051214,3075932],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[3052738,3060913,3077458,3080089,3071233,3073286,3067122,3073829,3051209,3053272,3057365,3075382,3071755,3058882,3069736,3050674,3054786,3056834,3062946,3065030,3069190,3075927,3077993,3061430,3065589,3059417,3063477,3055320,3067655,3079542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[3067175,3069731,3059412,3069247,3051204,3071750,3077988,3061425,3079599,3052791,3056887,3054839,3063472,3075439,3067650,3073824,3050727,3073343,3065087,3075922,3080084,3057360,3077511,3065584,3058935,3062999,3071283,3053267,3055315,3060963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[3077983,3075495,3065143,3075917,3057355,3067227,3079655,3056939,3063467,3058987,3061012,3069726,3065579,3073399,3073819,3067645,3053262,3050779,3069303,3080079,3054891,3059407,3061420,3077563,3051199,3055310,3052843,3063051,3071332,3071745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[3063751,3050350,3055594,3062622,3053546,3074107,3054462,3059691,3078267,3060598,3065875,3067929,3057639,3064694,3072020,3051483,3058558,3070918,3061695,3077134,3079214,3070014,3056510,3072958,3066798,3076205,3075054,3080367,3052414,3068862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[3076200,3074102,3065870,3051478,3068916,3073012,3079268,3064752,3054516,3050404,3063746,3062676,3072015,3075108,3077188,3080362,3059686,3061690,3060649,3055589,3056564,3053541,3057634,3058612,3066852,3070969,3067924,3070009,3052468,3078262],"length":1,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[3059598,3065778,3071015,3067836,3057546,3052514,3080274,3056610,3077234,3050450,3062722,3078174,3074014,3061605,3071930,3066898,3076112,3060695,3073058,3064802,3053453,3058658,3068962,3063658,3051390,3075154,3069921,3054562,3055501,3079314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[3079421,3062829,3055330,3065599,3058765,3073165,3057375,3053282,3063487,3073839,3061440,3060802,3078003,3054669,3075261,3051219,3080099,3069746,3064909,3069069,3052621,3067665,3077341,3059427,3056717,3067005,3071122,3071765,3075937,3050557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[3054936,3050824,3063381,3067610,3069691,3073733,3051164,3057320,3063096,3067559,3063432,3059372,3069352,3069640,3073784,3079704,3080044,3059032,3057269,3065192,3052888,3065485,3067272,3059321,3071377,3071658,3073448,3075882,3077897,3051113,3077608,3079993,3055275,3056984,3061057,3077948,3071709,3075831,3075544,3061337,3065520,3061388,3055224,3053227,3053176],"length":1,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[3077924,3073760,3057296,3075858,3051140,3067586,3071685,3053203,3080020,3059348,3055251,3061364,3063408,3065512,3069667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[3063575,3065691,3055418,3051307,3054618,3050506,3075210,3056666,3066954,3078091,3077290,3069018,3060751,3073114,3064858,3067753,3062778,3069834,3080187,3061525,3073927,3059515,3076025,3057463,3052570,3053370,3058714,3079370,3071850,3071071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3054996,3057136,3065252,3077646,3079764,3069412,3065348,3071437,3077764,3077690,3073600,3063134,3057044,3050862,3071415,3059114,3075626,3052926,3054974,3079786,3063156,3050980,3052948,3059070,3053043,3073486,3073508,3075604,3071459,3055018,3073530,3052970,3067354,3071530,3069507,3075698,3061117,3077668,3075582,3050906,3057066,3059092,3063178,3055091,3069390,3069434,3079860,3063248,3057022,3067426,3079742,3067332,3061139,3065230,3059188,3065274,3050884,3061095,3061209,3067310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[3054128,3078864,3070605,3074704,3050946,3075666,3057106,3059154,3060285,3052080,3063218,3069474,3068512,3073570,3065314,3053010,3061176,3064336,3062288,3058224,3067394,3071496,3056176,3050016,3055058,3076800,3072608,3079826,3077730,3066464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3080448,3082120,3082160,3081966,3083734,3083892],"length":1,"stats":{"Line":2},"fn_name":"deserialize_str<serde::de::impls::StrVisitor>"},{"line":200,"address":[3082307,3080595,3082386,3082469,3080674,3080478,3080757,3082190],"length":1,"stats":{"Line":6},"fn_name":null},{"line":202,"address":[3081350,3080722,3083021,3082434,3081277,3083094],"length":1,"stats":{"Line":5},"fn_name":null},{"line":203,"address":[3082613,3083887,3082115,3080901],"length":1,"stats":{"Line":4},"fn_name":null},{"line":204,"address":[3082110,3080940,3082656,3083882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[3080987,3082105,3083877,3082707],"length":1,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[3081034,3083872,3082100,3082758],"length":1,"stats":{"Line":4},"fn_name":null},{"line":207,"address":[3083867,3081081,3082095,3082809],"length":1,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[3081127,3083862,3082090,3082859],"length":1,"stats":{"Line":4},"fn_name":null},{"line":209,"address":[3083109,3083493,3081365,3081729],"length":1,"stats":{"Line":4},"fn_name":null},{"line":210,"address":[3081412,3083160,3083491,3081727],"length":1,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[3081459,3081725,3083211,3083489],"length":1,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[3081723,3083261,3083487,3081505],"length":1,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[3081174,3082085,3082910,3083857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3082080,3081222,3083852,3082962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[3083009,3081995,3083763,3083082,3081731,3083495,3081265,3081338],"length":1,"stats":{"Line":5},"fn_name":null},{"line":216,"address":[3083307,3081547,3083403,3081643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[3081287,3083688,3083031,3081924],"length":1,"stats":{"Line":4},"fn_name":null},{"line":218,"address":[3081323,3083580,3081816,3083067],"length":1,"stats":{"Line":4},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[3081609,3082572,3083369,3080860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[3083936,3084313],"length":1,"stats":{"Line":1},"fn_name":"deserialize_string<serde::de::impls::StringVisitor>"},{"line":232,"address":[3083966,3084206,3084059,3084138],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[3084191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[3084336,3084767],"length":1,"stats":{"Line":1},"fn_name":"deserialize_option<serde::de::impls::OptionVisitor<u8>>"},{"line":240,"address":[3084597,3084459,3084366,3084538],"length":1,"stats":{"Line":3},"fn_name":null},{"line":241,"address":[3084586,3084695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[3084731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[3084765,3084711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[3107145,3091141,3097584,3103945,3110384,3087984,3107184,3100784,3100744,3084784,3094384,3094341,3103984,3087943,3091184,3113543,3097545,3110344],"length":1,"stats":{"Line":9},"fn_name":"deserialize_newtype_struct<taos_query::common::value::de::ref_value::tests::de_newtype_struct::de_newtype_struct::_::{impl#0}::deserialize::__Visitor<u16>>"},{"line":256,"address":[3097864,3088264,3097961,3107678,3104478,3085064,3088039,3088361,3094761,3091678,3097639,3101161,3107239,3084839,3110439,3104361,3107561,3110761,3091464,3091561,3091239,3094878,3101278,3094439,3094664,3110664,3110878,3100839,3098078,3101064,3107464,3085278,3104039,3085161,3104264,3088478],"length":1,"stats":{"Line":27},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[3098757,3101957,3089233,3092741,3108763,3105585,3111633,3095985,3099185,3102385,3086385,3088433,3099141,3108741,3111963,3086363,3102033,3107633,3111985,3089541,3089563,3110833,3101233,3104433,3111557,3091633,3099163,3094833,3102341,3092763,3102363,3089157,3085957,3105157,3105233,3105563,3108357,3108785,3092785,3086033,3095633,3108433,3111941,3089585,3092357,3095557,3095941,3092433,3105541,3086341,3085233,3098033,3098833,3095963],"length":1,"stats":{"Line":9},"fn_name":null},{"line":264,"address":[3095101,3100739,3094336,3107901,3085501,3091901,3107140,3098301,3104701,3087938,3097540,3110339,3091136,3101501,3088701,3103940,3113538,3111101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[3095127,3091927,3085527,3113447,3104727,3111127,3091045,3101527,3087847,3088727,3110248,3107049,3107927,3100648,3098327,3094245,3103849,3097449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[3103761,3097361,3085587,3107987,3088787,3104787,3095187,3100560,3091987,3101587,3110160,3111187,3113359,3090957,3094157,3087759,3106961,3098387],"length":1,"stats":{"Line":8},"fn_name":null},{"line":267,"address":[3087670,3111247,3113270,3110071,3101647,3095247,3106872,3085647,3097272,3094068,3090868,3088847,3104847,3103672,3108047,3100471,3092047,3098447],"length":1,"stats":{"Line":8},"fn_name":null},{"line":268,"address":[3085708,3095308,3111308,3093983,3101708,3088908,3097187,3109986,3104908,3100386,3106787,3087585,3108108,3113185,3092108,3090783,3098508,3103587],"length":1,"stats":{"Line":8},"fn_name":null},{"line":269,"address":[3095367,3100303,3087502,3106704,3085767,3103504,3104967,3111367,3108167,3109903,3093900,3098567,3088967,3113102,3101767,3092167,3097104,3090700],"length":1,"stats":{"Line":8},"fn_name":null},{"line":270,"address":[3099787,3102988,3089246,3105246,3098846,3090184,3096588,3109387,3086986,3086046,3111646,3112586,3092446,3108446,3093384,3102046,3106188,3095646],"length":1,"stats":{"Line":8},"fn_name":null},{"line":271,"address":[3102902,3112500,3111703,3093298,3099701,3089303,3096502,3106102,3095703,3092503,3086900,3109301,3086103,3108503,3098903,3102103,3090098,3105303],"length":1,"stats":{"Line":8},"fn_name":null},{"line":272,"address":[3090016,3112418,3108561,3092561,3102820,3089361,3095761,3109219,3111761,3106020,3105361,3099619,3102161,3086818,3093216,3096420,3098961,3086161],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[3102217,3089933,3099536,3105417,3093133,3105937,3109136,3095817,3102737,3108617,3111817,3086735,3089417,3092617,3086217,3112335,3099017,3096337],"length":1,"stats":{"Line":8},"fn_name":null},{"line":274,"address":[3100219,3089025,3101825,3105025,3090616,3109819,3098625,3103420,3106620,3087418,3092225,3097020,3095425,3108225,3111425,3113018,3085825,3093816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[3111485,3089085,3090532,3092285,3108285,3085885,3100135,3109735,3096936,3093732,3105085,3103336,3095485,3106536,3087334,3098685,3101885,3112934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[3093469,3100016,3095545,3102021,3105145,3106273,3090269,3092345,3101945,3085945,3108421,3109472,3093613,3090413,3089221,3096673,3106417,3109616,3112671,3087071,3105221,3095621,3099872,3098745,3086021,3096817,3098821,3112815,3087215,3089145,3103217,3108345,3092421,3111545,3103073,3111621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[3095875,3096265,3096332,3093128,3105475,3086730,3093061,3105932,3089928,3093116,3086718,3099075,3105920,3112318,3109131,3089916,3089475,3109064,3089861,3102720,3099464,3086275,3102665,3105865,3112263,3092675,3099519,3099531,3102275,3111875,3102732,3096320,3108675,3109119,3112330,3086663],"length":1,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[3086311,3102601,3112199,3086702,3089923,3111911,3112302,3092997,3093123,3099111,3105801,3096201,3102727,3108711,3109126,3105511,3089511,3109103,3105927,3099400,3109000,3093100,3099526,3096304,3112325,3089900,3102311,3096327,3092711,3086599,3099503,3105904,3102704,3086725,3089797,3095911],"length":1,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[3111570,3092370,3098770,3106317,3103117,3109516,3099916,3089170,3087115,3090313,3093513,3085970,3096717,3101970,3105170,3095570,3108370,3112715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3105551,3108729,3108773,3105573,3095929,3089573,3099129,3108751,3111973,3092751,3092773,3092729,3086351,3089551,3086329,3099151,3095951,3102373,3089529,3105529,3111951,3095973,3099173,3102329,3102351,3086373,3111929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[3096045,3105796,3086443,3099244,3108844,3102445,3089792,3099395,3102596,3086594,3112043,3108995,3105645,3089641,3096196,3112194,3092992,3092841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3092811,3108811,3095051,3096011,3088651,3111051,3089611,3112011,3101451,3085451,3099211,3104651,3086411,3098251,3091851,3102411,3107851,3105611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[3114494,3113584],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq<serde::de::impls::{impl#19}::deserialize::VecVisitor<u8>>"},{"line":302,"address":[3113614,3113869,3113707,3113786],"length":1,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[3113834,3114033,3114112,3114131,3114150,3114055],"length":1,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[3114482,3113994,3114454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[3114466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[3114065,3114298,3114247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3114274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[3114426,3114021,3114330,3114043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[3114410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[3114100,3114138,3114119],"length":1,"stats":{"Line":3},"fn_name":null},{"line":319,"address":[3114167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[3113976,3114152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[3116274,3115378,3115408,3114512],"length":1,"stats":{"Line":2},"fn_name":"deserialize_enum<taos_query::common::timestamp::_::{impl#0}::deserialize::__Visitor>"},{"line":334,"address":[3114571,3115566,3114840,3115467,3115648,3115736,3114670,3114752],"length":1,"stats":{"Line":6},"fn_name":null},{"line":336,"address":[3115706,3114810,3115077,3115973],"length":1,"stats":{"Line":5},"fn_name":null},{"line":337,"address":[3116079,3115183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[3116042,3115146,3116129,3115233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[3115337,3116233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[3115312,3116208,3116269,3115373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3116304,3116601],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct<taos_query::common::value::de::ref_value::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor>"},{"line":358,"address":[3116385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[3116517,3116415,3116575],"length":1,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[3116557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[3116449,3116502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[1945296],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[2545140,2545136],"length":1,"stats":{"Line":4},"fn_name":"value_de_value_ref"},{"line":385,"address":[2545280,2546131],"length":1,"stats":{"Line":1},"fn_name":"value_de_value_ref"},{"line":399,"address":[2557573,2565241,2562220,2563351,2559699,2558521,2561231,2563482,2564815,2560827,2545293,2562089,2558751,2559611,2564045,2558433,2546165,2557495,2559969,2560958,2562493],"length":1,"stats":{"Line":13},"fn_name":null},{"line":402,"address":[2557525,2558398,2558465,2557468],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[2562129,2561119,2562381,2559643,2559857,2562066,2560867,2558678,2559576,2563328,2560804,2563391],"length":1,"stats":{"Line":12},"fn_name":null},{"line":404,"address":[2563643,2564800,2564847],"length":1,"stats":{"Line":3},"fn_name":null},{"line":408,"address":[2565408,2565412],"length":1,"stats":{"Line":4},"fn_name":"de_value_as_inner"},{"line":409,"address":[2568921,2565552,2568876],"length":1,"stats":{"Line":1},"fn_name":"de_value_as_inner"},{"line":423,"address":[2569848,2568887,2569008,2569715,2568600,2571257,2570089,2569997,2570673,2568447,2565559,2570438,2569158,2571165,2571022,2570581,2568355],"length":1,"stats":{"Line":10},"fn_name":null},{"line":435,"address":[2568313,2568399,2568574],"length":1,"stats":{"Line":3},"fn_name":null},{"line":436,"address":[2569132,2568936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[2569985,2569767,2569674,2570046],"length":1,"stats":{"Line":4},"fn_name":null},{"line":439,"address":[2570332,2570569,2570630],"length":1,"stats":{"Line":3},"fn_name":null},{"line":440,"address":[2571214,2571153,2570916],"length":1,"stats":{"Line":3},"fn_name":null},{"line":444,"address":[2571520,2571524],"length":1,"stats":{"Line":4},"fn_name":"de_borrowed_str"},{"line":445,"address":[2571664,2571810],"length":1,"stats":{"Line":1},"fn_name":"de_borrowed_str"},{"line":472,"address":[2571671,2571843,2574343,2573738,2574959,2575051,2573522,2575435,2573103,2573844,2574237],"length":1,"stats":{"Line":7},"fn_name":null},{"line":481,"address":[2573088,2573133],"length":1,"stats":{"Line":2},"fn_name":null},{"line":482,"address":[2573768,2573716],"length":1,"stats":{"Line":2},"fn_name":null},{"line":484,"address":[2574267,2574215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[2575003,2574922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":489,"address":[2575362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[2575764,2575760],"length":1,"stats":{"Line":4},"fn_name":"de_string"},{"line":493,"address":[2576058,2575904],"length":1,"stats":{"Line":1},"fn_name":"de_string"},{"line":520,"address":[2580849,2580985,2578959,2579905,2581086,2579196,2578060,2580443,2581494,2579095,2580034,2576091,2578498,2575911],"length":1,"stats":{"Line":7},"fn_name":null},{"line":534,"address":[2577987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[2578425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[2579139,2578863,2579073],"length":1,"stats":{"Line":3},"fn_name":null},{"line":537,"address":[2580027,2580078,2579503],"length":1,"stats":{"Line":3},"fn_name":null},{"line":538,"address":[2580963,2580753,2581029],"length":1,"stats":{"Line":3},"fn_name":null},{"line":539,"address":[2581468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[2581780,2581776],"length":1,"stats":{"Line":4},"fn_name":"de_json"},{"line":544,"address":[2582472,2581936,2582430],"length":1,"stats":{"Line":1},"fn_name":"de_json"},{"line":555,"address":[2582441,2582172,2581996,2581943],"length":1,"stats":{"Line":3},"fn_name":null},{"line":556,"address":[2581951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[2582145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[2582838,2583043,2583115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[2582487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[2583075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[2583008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[2583744,2583748],"length":1,"stats":{"Line":4},"fn_name":"de_newtype_struct"},{"line":575,"address":[2584145,2583904],"length":1,"stats":{"Line":1},"fn_name":"de_newtype_struct"},{"line":587,"address":[2584013,2584179,2584275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[2583917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[2584208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[2584504,2584888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[2584940,2585134,2584850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":597,"address":[2585096,2585186,2585381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":598,"address":[2585628,2585343,2585433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":599,"address":[2585590,2585894,2585680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":627,"address":[2593334,2598667,2601997,2608665,2617997,2620661,2599333,2589335,2621327,2609331,2618663,2599999,2625326,2627952,2628421,2588669,2607999,2606666,2607333,2611995,2612661,2615329,2626660,2616663,2619329,2594668,2604665,2617330,2586671,2591333,2592000,2601331,2603331,2622659,2596669,2613328,2624659,2590667,2585837,2613995,2602664,2594001,2585945,2609997,2625993,2627327,2587337,2588003,2619995,2596002,2623325,2600665,2590001,2592667,2614662,2615996,2621993,2605999,2605332,2598001,2595335,2610663,2603998,2597335,2586005,2623992,2611329],"length":1,"stats":{"Line":66},"fn_name":null}],"covered":136,"coverable":200},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","value.rs"],"content":"use super::super::*;\nuse super::*;\nuse serde::{\n    de::{self, value::Error, DeserializeSeed, IntoDeserializer, Visitor},\n    forward_to_deserialize_any,\n};\n\nimpl<'de, 'b> serde::de::EnumAccess<'de> for Value {\n    type Error = Error;\n\n    type Variant = UnitOnly;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let s = self.strict_as_str();\n        return Ok((\n            seed.deserialize(StringDeserializer {\n                input: s.to_string(),\n            })?,\n            UnitOnly,\n        ));\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumTimestampDeserializer {\n    value: Value,\n}\n\nimpl<'b, 'de> serde::de::EnumAccess<'de> for EnumTimestampDeserializer {\n    type Error = Error;\n\n    type Variant = VariantTimestampDeserializer;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        // let variant = self.value.ty().as_variant_str();\n        // use BorrowedValue::*;\n        match self.value {\n            Value::Timestamp(Timestamp::Microseconds(v)) => Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Microseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: v },\n            )),\n            Value::Timestamp(Timestamp::Milliseconds(v)) => Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Milliseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: v },\n            )),\n            Value::Timestamp(Timestamp::Nanoseconds(v)) => Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Nanoseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: v },\n            )),\n            _ => todo!(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumValueDeserializer {\n    value: Value,\n}\n\n#[derive(Clone)]\nstruct StringDeserializer {\n    input: String,\n}\n\nimpl<'de> de::Deserializer<'de> for StringDeserializer {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_string(self.input)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\nimpl<'de, 'b: 'de> serde::de::EnumAccess<'de> for EnumValueDeserializer {\n    type Error = Error;\n\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        let variant = self.value.ty().as_variant_str();\n\n        Ok((\n            seed.deserialize(StringDeserializer {\n                input: variant.to_string(),\n            })\n            .expect(\"\"),\n            self,\n        ))\n    }\n}\n\nimpl<'de, 'b: 'de> de::VariantAccess<'de> for EnumValueDeserializer {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        seed.deserialize(self.value)\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        todo!()\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        todo!()\n    }\n}\n\nimpl<'de, 'b: 'de> serde::de::Deserializer<'de> for Value {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_any: {self:?}\");\n        use Value::*;\n        // todo!()\n        match self {\n            Null => visitor.visit_none(),\n            Bool(v) => visitor.visit_bool(v),\n            TinyInt(v) => visitor.visit_i8(v),\n            SmallInt(v) => visitor.visit_i16(v),\n            Int(v) => visitor.visit_i32(v),\n            BigInt(v) => visitor.visit_i64(v),\n            UTinyInt(v) => visitor.visit_u8(v),\n            USmallInt(v) => visitor.visit_u16(v),\n            UInt(v) => visitor.visit_u32(v),\n            UBigInt(v) => visitor.visit_u64(v),\n            Float(v) => visitor.visit_f32(v),\n            Double(v) => visitor.visit_f64(v),\n            VarChar(v) => visitor.visit_string(v),\n            NChar(v) => visitor.visit_string(v),\n            Json(v) => v\n                .into_deserializer()\n                .deserialize_any(visitor)\n                .map_err(<Self::Error as de::Error>::custom),\n            Timestamp(v) => visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) => {\n                v.into_deserializer().deserialize_any(visitor)\n            }\n            _ => Err(<Self::Error as de::Error>::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    serde::forward_to_deserialize_any! {bool i8 u8 i16 u16 i32 u32 i64 u64 f32 f64 char}\n\n    serde::forward_to_deserialize_any! {\n        unit\n        bytes byte_buf unit_struct\n        tuple_struct tuple identifier ignored_any\n    }\n\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_str\");\n        use Value::*;\n        match self {\n            Null => visitor.visit_str(\"\"), // todo: empty string or error?\n            // Null => Err(Self::Error::from_string(\n            // \"expect non-optional String, but value is null\",\n            // )),\n            Bool(v) => visitor.visit_bool(v),\n            TinyInt(v) => visitor.visit_i8(v),\n            SmallInt(v) => visitor.visit_i16(v),\n            Int(v) => visitor.visit_i32(v),\n            BigInt(v) => visitor.visit_i64(v),\n            UTinyInt(v) => visitor.visit_u8(v),\n            USmallInt(v) => visitor.visit_u16(v),\n            UInt(v) => visitor.visit_u32(v),\n            UBigInt(v) => visitor.visit_u64(v),\n            Float(v) => visitor.visit_f32(v),\n            Double(v) => visitor.visit_f64(v),\n            VarChar(v) | NChar(v) => visitor.visit_string(v),\n            Json(v) => visitor.visit_string(v.to_string()),\n            Timestamp(v) => visitor.visit_string(\n                v.to_naive_datetime()\n                    .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                    .to_string(),\n            ),\n            _ => Err(<Self::Error as de::Error>::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_string\");\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_option\");\n        if self.is_null() {\n            visitor.visit_none()\n        } else {\n            visitor.visit_some(self)\n        }\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::trace!(\"deserialize_newtype_struct: {_name}\");\n        use Value::*;\n        macro_rules! _v_ {\n            ($v:expr) => {\n                visitor.visit_newtype_struct($v.into_deserializer())\n            };\n        }\n        match self {\n            Null => visitor.visit_none(),\n            Bool(v) => _v_!(v),\n            TinyInt(v) => _v_!(v),\n            SmallInt(v) => _v_!(v),\n            Int(v) => _v_!(v),\n            BigInt(v) => _v_!(v),\n            UTinyInt(v) => _v_!(v),\n            USmallInt(v) => _v_!(v),\n            UInt(v) => _v_!(v),\n            UBigInt(v) => _v_!(v),\n            Float(v) => _v_!(v),\n            Double(v) => _v_!(v),\n            VarChar(v) | NChar(v) => visitor.visit_newtype_struct(v.as_str().into_deserializer()),\n            Json(v) => visitor\n                .visit_newtype_struct(v.into_deserializer())\n                .map_err(<Self::Error as de::Error>::custom),\n            Timestamp(v) => _v_!(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) => {\n                visitor.visit_newtype_struct(v.as_slice().into_deserializer())\n            }\n            _ => Err(<Self::Error as de::Error>::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_map\");\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        log::trace!(\"call deserialize seq by value\");\n        use Value::*;\n        match self {\n            Null => Vec::<u8>::new()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            Json(v) => v\n                .into_deserializer()\n                .deserialize_seq(visitor)\n                .map_err(<Self::Error as de::Error>::custom),\n            VarChar(v) | NChar(v) => v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            VarBinary(v) | Blob(v) | MediumBlob(v) => {\n                v.into_deserializer().deserialize_seq(visitor)\n            }\n            _ => todo!(),\n        }\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::trace!(\"name: {name}, variants: {variants:?}\");\n\n        if name == \"Timestamp\" && variants == TIMESTAMP_VARIANTS {\n            return visitor.visit_enum(EnumTimestampDeserializer { value: self });\n        }\n        if name == \"Value\" && variants == VALUE_VARIANTS {\n            return visitor.visit_enum(EnumValueDeserializer {\n                // variants,\n                value: self,\n            });\n        }\n\n        visitor.visit_enum(self)\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Json(json) => json\n                .into_deserializer()\n                .deserialize_struct(name, fields, visitor)\n                .map_err(<Self::Error as serde::de::Error>::custom),\n            _ => self.deserialize_any(visitor),\n        }\n    }\n}\n\nimpl<'de, 'b: 'de> serde::de::IntoDeserializer<'de, Error> for Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use serde_json::json;\n    use taos_macros::test;\n\n    #[test]\n    fn value_de_value() {\n        use std::cmp::PartialEq;\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr) *) => {\n                $(\n                    {\n                        let v = $v;\n                        let d = Value::deserialize(v.clone().into_deserializer()).expect(\"\");\n                        assert!(v.eq(&d));\n                    }\n                )*\n            }\n        }\n        _de_value!(\n                Null Bool(true) TinyInt(0xf) SmallInt(0xfff) Int(0xffff) BigInt(-1) Float(1.0) Double(1.0)\n                UTinyInt(0xf) USmallInt(0xfff) UInt(0xffff) UBigInt(0xffffffff)\n                Timestamp(crate::common::timestamp::Timestamp::Milliseconds(0)) VarChar(\"anything\".to_string())\n                NChar(\"你好，世界\".to_string()) VarBinary(vec![1,2,3]) Blob(vec![1,2, 3]) MediumBlob(vec![1,2,3])\n                Json(serde_json::json!({\"name\": \"ABC\"}))\n        );\n    }\n\n    #[test]\n    fn de_value_as_inner() {\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr, $ty:ty, $tv:expr) *) => {\n                $(\n                    {\n                        let d = <$ty>::deserialize($v.into_deserializer()).expect(\"\");\n                        assert_eq!(d, $tv);\n                    }\n                )*\n            }\n        }\n\n        _de_value!(\n            Null, Option<u8>, None\n            TinyInt(-1), i8, -1\n            SmallInt(-1), i16, -1\n            Int(0x0fff_ffff), i32, 0x0fff_ffff\n            BigInt(0xffffffff), i64, 0xffffffff\n            UTinyInt(0xff), u8, 0xff\n            USmallInt(0xffff), u16, 0xffff\n            UInt(0x_ffff_ffff), u32, 0x_ffff_ffff\n            UBigInt(0x_ffff_ffff_ffff_ffff), u64, 0x_ffff_ffff_ffff_ffff\n            Float(1.0), f32, 1.0\n            Double(f64::MAX), f64, f64::MAX\n            VarChar(\"\".to_string()), String, \"\".to_string()\n            NChar(\"\".to_string()), String, \"\".to_string()\n            Timestamp(crate::Timestamp::Milliseconds(1)), crate::Timestamp, crate::Timestamp::Milliseconds(1)\n            VarBinary(vec![0, 1,2]), Vec<u8>, vec![0, 1, 2]\n            Blob(vec![0, 1,2]), Vec<u8>, vec![0, 1, 2]\n            MediumBlob(vec![0, 1,2]), Vec<u8>, vec![0, 1, 2]\n        );\n    }\n\n    #[test]\n    fn de_str() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) => {\n                assert!(String::deserialize($v.into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) => {\n                assert_eq!(String::deserialize($v.into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) => {\n                $(\n                    {\n                        assert!(String::deserialize($v.into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) => {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            ;\n\n            Null, \"\"\n            Timestamp(crate::Timestamp::Milliseconds(0)), \"1970-01-01T00:00:00\"\n            VarChar(\"String\".to_string()), \"String\"\n            VarChar(\"你好，世界\".to_string()), \"你好，世界\"\n            Json(json!(\"abc\")), json!(\"abc\").to_string()\n            Json(json!({ \"name\": \"abc\"})), json!({ \"name\": \"abc\"}).to_string()\n            Json(json!(1)), json!(1).to_string()\n            Json(json!(null)), json!(null).to_string()\n        };\n    }\n\n    #[test]\n    fn de_json() {\n        use Value::*;\n\n        macro_rules! _de_json {\n            ($v:expr, $ty:ty, $tv:expr) => {{\n                let v = Json($v);\n                let d = <$ty>::deserialize(v.clone().into_deserializer()).expect(\"de json\");\n                assert_eq!(d, $tv);\n            }};\n        }\n\n        _de_json!(\n            serde_json::json!(\"string\"),\n            String,\n            \"\\\"string\\\"\".to_string()\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Obj {\n            name: String,\n        }\n        _de_json!(\n            serde_json::json!({ \"name\": \"string\" }),\n            Obj,\n            Obj {\n                name: \"string\".to_string()\n            }\n        );\n    }\n\n    #[test]\n    fn de_newtype_struct() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_ty {\n            ($v:expr, $ty:ty, $tv:expr) => {{\n                let d = <$ty>::deserialize($v.into_deserializer()).expect(\"de type\");\n                assert_eq!(d, $tv);\n            }};\n        }\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_ty!(\n            Json(json!(\"string\")),\n            JsonStr,\n            JsonStr(\"string\".to_string())\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Primi<T>(T);\n        _de_ty!(Json(json!(1)), Primi<i32>, Primi(1));\n        _de_ty!(TinyInt(1), Primi<i8>, Primi(1));\n        _de_ty!(SmallInt(1), Primi<i64>, Primi(1));\n        _de_ty!(Int(1), Primi<i64>, Primi(1));\n        _de_ty!(BigInt(1), Primi<i64>, Primi(1));\n\n        macro_rules! _de_prim {\n            ($v:ident, $ty:ty, $inner:literal) => {\n                log::debug!(\n                    \"ty: {}, prim: {}\",\n                    stringify!($v),\n                    std::any::type_name::<$ty>()\n                );\n                _de_ty!($v($inner), Primi<$ty>, Primi($inner));\n            };\n        }\n\n        macro_rules! _de_prim_cross {\n            ($($vty:ident) +, $tt:ty) => {\n                $(\n                  _de_prim!($vty, $tt, 1);\n                )*\n            };\n            ($($ty:ty) +) => {\n                $(\n                    _de_prim_cross!(TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt, $ty);\n                )*\n            };\n            () => {\n                _de_prim_cross!(i8 i16 i32 i64 u8 u16 u32 u64);\n            };\n        }\n        _de_prim_cross!();\n    }\n}\n","traces":[{"line":13,"address":[3117498,3117088,3116624,3117034],"length":1,"stats":{"Line":0},"fn_name":"variant_seed<core::marker::PhantomData<taos_query::common::timestamp::_::{impl#0}::deserialize::__Field>>"},{"line":17,"address":[3116652,3117116,3117208,3116744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3116931,3117395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[3116900,3117352,3116760,3117224,3117286,3116888,3117442,3116822,3117483,3117364,3117019,3116978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3117245,3116781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1960672,1961808,1961757,1962893],"length":1,"stats":{"Line":1},"fn_name":"variant_seed<core::marker::PhantomData<taos_query::common::timestamp::_::{impl#0}::deserialize::__Field>>"},{"line":43,"address":[1960694,1961830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1960934,1962070,1962601,1961465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1961404,1962540,1962087,1960951,1961342,1962478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1962103,1960967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1962593,1961457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1962002,1961686,1962822,1960866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1962019,1962687,1961622,1962758,1961551,1960883],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[1960899,1962035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1961678,1962814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[1961238,1962138,1962374,1961002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[1962155,1961019,1962239,1962310,1961103,1961174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[1961035,1962171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1961230,1962366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1963008,1962944],"length":1,"stats":{"Line":2},"fn_name":"deserialize_any<taos_query::common::timestamp::_::{impl#0}::deserialize::__FieldVisitor>"},{"line":87,"address":[1962955,1963019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[1964030,1963534,1963072,1963568],"length":1,"stats":{"Line":1},"fn_name":"variant_seed<core::marker::PhantomData<taos_query::common::timestamp::_::{impl#0}::deserialize::__Field>>"},{"line":105,"address":[1963598,1963182,1963102,1963678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[1963936,1963440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1963234,1963306,1963802,1963730,1963870,1963374],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[1963754,1963258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1963418,1963914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[2711072],"length":1,"stats":{"Line":1},"fn_name":"unit_variant"},{"line":121,"address":[2711076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[1964448,1964128,1964256,1964320,1964832,1964896,1964512,1964640,1964704,1964768,1964064,1964384,1964576,1965024,1964960,1964192],"length":1,"stats":{"Line":15},"fn_name":"newtype_variant_seed<core::marker::PhantomData<u64>>"},{"line":128,"address":[1964782,1964910,1964526,1964718,1964846,1964398,1964654,1964974,1964142,1964334,1965038,1964590,1964462,1964206,1964078,1964270],"length":1,"stats":{"Line":15},"fn_name":null},{"line":153,"address":[3146986,3136933,3117552,3132118,3142384,3144516,3141929,3120096,3149383,3122229,3129509,3122116,3127154,3127488,3129952,3132005,3144403,3151954,3124580,3147328,3151841,3137376,3122560,3139432,3119754,3134912,3134581,3127041,3125024,3137046,3129622,3134468,3132448,3139545,3142042,3146873,3139872,3149824,3149496,3124693,3119641,3144848],"length":1,"stats":{"Line":12},"fn_name":"deserialize_any<serde::de::impls::{impl#49}::deserialize::PrimitiveVisitor>"},{"line":157,"address":[3137677,3135317,3142406,3122965,3130171,3127893,3120397,3132470,3125429,3125325,3137595,3127707,3142603,3147547,3129974,3140277,3150043,3125243,3127510,3130357,3134934,3144870,3127789,3137398,3132667,3139894,3122582,3145149,3147629,3147733,3147350,3120315,3145067,3132749,3122861,3130253,3117574,3135131,3145253,3149846,3135213,3150125,3140173,3120118,3117771,3142685,3120501,3132853,3137781,3142789,3150229,3122779,3125046,3117957,3140091,3117853],"length":1,"stats":{"Line":36},"fn_name":null},{"line":160,"address":[3121630,3138993,3121681,3141489,3145209,3146382,3150185,3151358,3128968,3143969,3119088,3132809,3130313,3136497,3148945,3143864,3129022,3126504,3117913,3136392,3136446,3124145,3138888,3138942,3141384,3121576,3126558,3129073,3133928,3141438,3125385,3127849,3143918,3119142,3140233,3119193,3120457,3124094,3131464,3134033,3142745,3146433,3147689,3148894,3151304,3151409,3131569,3146328,3148840,3122921,3133982,3124040,3126609,3135273,3137737,3131518],"length":1,"stats":{"Line":12},"fn_name":null},{"line":161,"address":[3144304,3139333,3118144,3145440,3123152,3140464,3134369,3129410,3141830,3142976,3133040,3150416,3136834,3125616,3120688,3135504,3146774,3119542,3128080,3130544,3122017,3131906,3137968,3151742,3149284,3124481,3126942,3147920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3134364,3137996,3133068,3124476,3139328,3135532,3119537,3130572,3140492,3145468,3147948,3126937,3143004,3151737,3146769,3128108,3123180,3141825,3129405,3122012,3144299,3149279,3125644,3150444,3118176,3120716,3136829,3131901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3146764,3141820,3133112,3123224,3118224,3134359,3136824,3144294,3126932,3128152,3131896,3149274,3135576,3139323,3138040,3140536,3130616,3124471,3120760,3145512,3150488,3119532,3129400,3147992,3151732,3122007,3125688,3143048],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[3148038,3123266,3124466,3151727,3144289,3146759,3149269,3120802,3131891,3119527,3126927,3133154,3118270,3130662,3135618,3145554,3134354,3128194,3138086,3136819,3122002,3139318,3140582,3125730,3141815,3129395,3143090,3150530],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3125773,3138133,3123309,3146754,3149264,3150573,3141810,3151722,3129390,3135661,3145597,3126922,3140629,3121997,3128237,3143133,3119522,3124461,3133197,3118317,3148085,3120845,3134349,3130709,3144284,3131886,3136814,3139313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[3125811,3151717,3146749,3140671,3144279,3120883,3118359,3130751,3135699,3123347,3136809,3141805,3119517,3131881,3124456,3128275,3145635,3148127,3139308,3129385,3138175,3121992,3126917,3133235,3134344,3149259,3150611,3143171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[3123739,3146027,3148523,3151003,3121887,3151612,3143563,3118771,3131772,3144174,3121275,3129280,3136091,3128667,3124351,3133627,3149150,3146644,3126203,3139199,3119408,3126812,3131147,3134239,3138571,3141067,3141696,3136704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[3123781,3141113,3146639,3148569,3136699,3138617,3149145,3119403,3121882,3151607,3143605,3134234,3124346,3121317,3126807,3129275,3126245,3133669,3144169,3146069,3131193,3139194,3131767,3141691,3136133,3128709,3151045,3118817],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[3146634,3129270,3131762,3136176,3121877,3139189,3134229,3121360,3123824,3124341,3136694,3133712,3141686,3144164,3126802,3146112,3151088,3118864,3138664,3143648,3151602,3126288,3131240,3141160,3148616,3149140,3119398,3128752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[3141681,3148658,3118906,3121872,3124336,3129265,3143686,3133750,3121398,3131282,3146629,3151126,3138706,3151597,3126797,3126326,3134224,3119393,3136214,3136689,3139184,3128790,3123862,3131757,3144159,3146150,3149135,3141202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[3125851,3135739,3139303,3141800,3121987,3138219,3144274,3128315,3146744,3148171,3129380,3124451,3131876,3149254,3120923,3143211,3119512,3136804,3118403,3126912,3140715,3151712,3134339,3123387,3130795,3145675,3133275,3150651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[3119507,3125893,3131871,3136799,3130837,3143253,3144269,3146739,3124446,3148213,3149249,3150693,3151707,3145717,3121982,3118449,3123429,3129375,3133317,3120965,3126907,3128357,3134334,3140757,3135781,3138261,3139298,3141795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[3145759,3121007,3125935,3133359,3124441,3139293,3121977,3118495,3140799,3144264,3136794,3138303,3130879,3129370,3143295,3131866,3148255,3149244,3119502,3126902,3150735,3141790,3128399,3146734,3151702,3123471,3134329,3135823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[3121892,3146649,3143463,3148423,3149155,3134244,3151617,3140967,3131777,3150903,3124356,3141701,3121175,3135991,3131047,3136709,3138471,3118667,3126103,3119413,3123639,3126817,3128567,3129285,3133527,3139204,3144179,3145927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[3119337,3146593,3148697,3151161,3126765,3146185,3131725,3138745,3129233,3141649,3139152,3118945,3134192,3131321,3121840,3133785,3136249,3144127,3149103,3151565,3126361,3123897,3124304,3136657,3121433,3143721,3141241,3128825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[3119329,3124280,3131701,3146569,3149079,3126741,3139128,3144103,3121816,3129209,3136633,3141625,3151541,3134168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[3121102,3129290,3135918,3140894,3123566,3130974,3121897,3133454,3141706,3145854,3146654,3139209,3131782,3126822,3118594,3128494,3136714,3119418,3124361,3134249,3138398,3126030,3143390,3148350,3149160,3150830,3151622,3144184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[3124050,3151314,3133989,3146389,3131525,3146284,3121532,3121637,3136402,3128978,3131420,3141340,3151260,3143820,3126514,3136453,3141445,3148901,3136348,3138844,3129029,3151365,3141394,3119098,3133884,3143874,3119044,3128924,3146338,3138898,3148796,3131474,3121586,3148850,3143925,3123996,3126565,3119149,3133938,3138949,3126460,3124101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3141540,3126656,3119244,3139043,3144018,3136548,3121731,3124195,3151456,3148994,3146484,3129124,3134083,3131616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[3135463,3136514,3140423,3141506,3121698,3145399,3150375,3131586,3123111,3129090,3151426,3124162,3134050,3132999,3137927,3146450,3143986,3119210,3139010,3125575,3126626,3118103,3142935,3120647,3147879,3130503,3148962,3128039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[3152288,3153723,3154232],"length":1,"stats":{"Line":1},"fn_name":"deserialize_str<serde::de::impls::StringVisitor>"},{"line":201,"address":[3152310,3152546,3152467,3152629],"length":1,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[3152594,3153168,3153293],"length":1,"stats":{"Line":4},"fn_name":null},{"line":204,"address":[3152767,3154074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[3154069,3152810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[3152858,3154064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[3152904,3154059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[3152951,3154054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[3152993,3154049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[3153308,3153749],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[3153744,3153354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[3153401,3153739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[3153443,3153734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[3153037,3154044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3153083,3154039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[3153249,3153124,3153759,3154034],"length":1,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[3153482,3153606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[3153178,3153970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[3153862,3153234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[3153572,3152726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3154432,3154885,3154912],"length":1,"stats":{"Line":1},"fn_name":"deserialize_string<serde::de::impls::StringVisitor>"},{"line":236,"address":[3154761,3154454,3154563,3154642],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[3154695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[3154928,3155431,3155458],"length":1,"stats":{"Line":1},"fn_name":"deserialize_option<serde::de::impls::OptionVisitor<u8>>"},{"line":244,"address":[3154950,3155059,3155138,3155197],"length":1,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[3155186,3155295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[3155382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[3155311,3155415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[3171341,3169873,3175904,3187660,3157631,3175421,3188144,3167744,3186192,3190269,3155504,3165793,3159584,3163664,3159099,3171824,3163180,3178031,3191737,3179499,3161712,3173953,3183577,3167261,3179984,3182109,3184064],"length":1,"stats":{"Line":9},"fn_name":"deserialize_newtype_struct<taos_query::common::value::de::value::tests::de_newtype_struct::de_newtype_struct::_::{impl#0}::deserialize::__Visitor<i16>>"},{"line":260,"address":[3176486,3188512,3159952,3160049,3155551,3155872,3172406,3176369,3155969,3167791,3168326,3180449,3188726,3164032,3188191,3180031,3160166,3176272,3180566,3156086,3172192,3172289,3175951,3168209,3184529,3180352,3164246,3184432,3188609,3164129,3159631,3171871,3163711,3168112,3184111,3184646],"length":1,"stats":{"Line":27},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[3188681,3169129,3156041,3176441,3189401,3189909,3157326,3160841,3172361,3177780,3173646,3184601,3169566,3177669,3161406,3173700,3161460,3177161,3181749,3185829,3169620,3185321,3164201,3189529,3189966,3156889,3168281,3169509,3169001,3157269,3181806,3160969,3165429,3156761,3181241,3160121,3177726,3181860,3161349,3164921,3185886,3173081,3190020,3165049,3177289,3165540,3157380,3185449,3180521,3173209,3165486,3185940,3181369,3173589],"length":1,"stats":{"Line":9},"fn_name":null},{"line":268,"address":[3167156,3179394,3183472,3172629,3163075,3180789,3188949,3191632,3158994,3164469,3187555,3171236,3176709,3160389,3156309,3168549,3184869,3175316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[3158903,3191541,3184895,3164495,3168575,3188975,3167065,3162984,3180815,3187464,3156335,3176735,3160415,3171145,3175225,3179303,3172655,3183381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3191453,3179215,3176792,3162896,3160472,3180872,3171057,3164552,3166977,3184952,3183293,3156392,3172712,3187376,3158815,3168632,3189032,3175137],"length":1,"stats":{"Line":8},"fn_name":null},{"line":271,"address":[3176847,3183204,3175048,3158726,3185007,3156447,3160527,3162807,3172767,3187287,3179126,3166888,3191364,3189087,3170968,3168687,3180927,3164607],"length":1,"stats":{"Line":8},"fn_name":null},{"line":272,"address":[3160584,3158641,3185064,3176904,3187202,3189144,3156504,3164664,3179041,3168744,3183119,3166803,3191279,3162722,3172824,3174963,3170883,3180984],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[3172875,3189195,3164715,3176955,3158555,3181035,3166717,3191193,3156555,3178955,3160635,3170797,3187116,3168795,3185115,3162636,3183033,3174877],"length":1,"stats":{"Line":8},"fn_name":null},{"line":274,"address":[3190640,3158002,3182480,3165062,3169142,3173222,3174324,3166164,3170244,3178402,3177302,3181382,3185462,3189542,3160982,3186563,3156902,3162083],"length":1,"stats":{"Line":8},"fn_name":null},{"line":275,"address":[3161034,3190554,3156954,3174238,3185514,3165114,3161997,3166078,3189594,3178316,3157916,3181434,3173274,3170158,3169194,3186477,3182394,3177354],"length":1,"stats":{"Line":8},"fn_name":null},{"line":276,"address":[3173328,3182312,3169248,3178234,3157008,3177408,3165996,3174156,3181488,3189648,3190472,3161915,3165168,3157834,3161088,3170076,3185568,3186395],"length":1,"stats":{"Line":8},"fn_name":null},{"line":277,"address":[3177456,3174073,3165216,3181536,3173376,3169296,3157056,3186312,3161832,3182229,3189696,3161136,3169993,3157751,3178151,3185616,3165913,3190389],"length":1,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[3162552,3187032,3158471,3182949,3160689,3191109,3156609,3178871,3189249,3177009,3174793,3172929,3164769,3181089,3185169,3168849,3166633,3170713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[3186948,3168903,3191025,3182865,3156663,3189303,3174709,3164823,3170629,3160743,3162468,3158387,3177063,3181143,3166549,3178787,3185223,3172983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[3168957,3158087,3177245,3190869,3166249,3185405,3174409,3174553,3177117,3164877,3160797,3181197,3186792,3160925,3170473,3165005,3166393,3185277,3189357,3186648,3156717,3182565,3170329,3173165,3182709,3158231,3173037,3162312,3189485,3162168,3156845,3190725,3178631,3169085,3181325,3178487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3186295,3178134,3178146,3157679,3161187,3186307,3178079,3165841,3161760,3173427,3157746,3182224,3182212,3190317,3169988,3174001,3169347,3157734,3161827,3169921,3165267,3189747,3157107,3165908,3174068,3185667,3186240,3165896,3190372,3174056,3161815,3169976,3181587,3190384,3182157,3177507],"length":1,"stats":{"Line":8},"fn_name":null},{"line":282,"address":[3161235,3174063,3190356,3165880,3173475,3169983,3182219,3161723,3169395,3169884,3165804,3161822,3157718,3182120,3157155,3186279,3190280,3182196,3157642,3186302,3178118,3181635,3173964,3161799,3190379,3165315,3189795,3186203,3157741,3165903,3169960,3185715,3174040,3177555,3178042,3178141],"length":1,"stats":{"Line":4},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3156774,3164934,3158131,3169014,3166293,3177174,3185334,3182609,3189414,3170373,3174453,3181254,3160854,3162212,3178531,3173094,3186692,3190769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3189976,3189922,3173545,3173602,3157336,3161362,3165385,3165442,3165496,3157225,3169465,3169522,3181705,3169576,3181762,3181816,3185842,3161305,3173656,3157282,3189865,3185785,3161416,3177625,3177682,3177736,3185896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[3165600,3178029,3173760,3165791,3185999,3190076,3169680,3157629,3169871,3182107,3161519,3157438,3190267,3161710,3177838,3186190,3173951,3181916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[3177806,3164419,3173726,3165566,3156259,3176659,3172579,3185966,3168499,3160339,3181886,3161486,3169646,3157406,3180739,3184819,3188899,3190046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[3193433,3192224,3193544],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq<serde::de::impls::{impl#19}::deserialize::VecVisitor<u8>>"},{"line":306,"address":[3192246,3192435,3192597,3192514],"length":1,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[3192798,3193056,3193005,3193107,3192852,3192562],"length":1,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[3193488,3192727,3193460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3193472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[3192862,3193233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[3193209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3193341,3192754,3192808,3193270,3193404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[3193287,3193411,3193388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[3193063,3192961,3193012],"length":1,"stats":{"Line":3},"fn_name":null},{"line":322,"address":[3193111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[3196036,3194928,3193776,3196063,3194911,3194884],"length":1,"stats":{"Line":2},"fn_name":"deserialize_enum<taos_query::common::timestamp::_::{impl#0}::deserialize::__Visitor>"},{"line":337,"address":[3194021,3195261,3194109,3194976,3195091,3193939,3193824,3195173],"length":1,"stats":{"Line":6},"fn_name":null},{"line":339,"address":[3194079,3195231,3194346,3195498],"length":1,"stats":{"Line":4},"fn_name":null},{"line":340,"address":[3194455,3195607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[3194415,3195567,3194588,3195740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[3194746,3195898,3194797,3195949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[3195906,3194754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[3194865,3194667,3196017,3195819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[3196527,3196080,3196486],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct<taos_query::common::value::de::value::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor>"},{"line":361,"address":[3196154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[3196200,3196446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[3196425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3196284,3196384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[1945312],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":375,"address":[1945320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":386,"address":[2102512,2102516],"length":1,"stats":{"Line":4},"fn_name":"value_de_value"},{"line":387,"address":[2102935,2102958,2102656],"length":1,"stats":{"Line":1},"fn_name":"value_de_value"},{"line":401,"address":[2108972,2102946,2105765,2104534,2103005,2105458,2107904,2103612,2106426,2104227,2105152,2107518,2103306,2102695,2104848,2106074,2103919,2102669,2106779,2107132,2108290],"length":1,"stats":{"Line":21},"fn_name":null},{"line":402,"address":[2102973,2103884,2104499,2103274,2104191,2104816,2103578,2102677],"length":1,"stats":{"Line":8},"fn_name":null},{"line":403,"address":[2105730,2106042,2105120,2105424],"length":1,"stats":{"Line":4},"fn_name":null},{"line":404,"address":[2106698,2106346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":405,"address":[2108176,2107051,2107404,2107790],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[2108562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[2109268,2109264],"length":1,"stats":{"Line":4},"fn_name":"de_value_as_inner"},{"line":411,"address":[2112751,2112778,2109408],"length":1,"stats":{"Line":1},"fn_name":"de_value_as_inner"},{"line":424,"address":[2109429,2112268,2114875,2113899,2112873,2114341,2114967,2110658,2112475,2109637,2110913,2111171,2110142,2113704,2113807,2111428,2110399,2112980,2109888,2114238,2111973,2112368,2113335,2111692,2112762,2113566,2114433,2114772],"length":1,"stats":{"Line":21},"fn_name":null},{"line":425,"address":[2109421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[2109621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[2109870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[2110123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[2110378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[2110642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[2110895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[2111152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[2111408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[2111667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[2111948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[2112226,2112312,2112449],"length":1,"stats":{"Line":3},"fn_name":null},{"line":437,"address":[2112793,2112954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[2113271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[2113528,2113856,2113795,2113615],"length":1,"stats":{"Line":4},"fn_name":null},{"line":440,"address":[2114124,2114329,2114390],"length":1,"stats":{"Line":3},"fn_name":null},{"line":441,"address":[2114658,2114863,2114924],"length":1,"stats":{"Line":3},"fn_name":null},{"line":445,"address":[2115200,2115204],"length":1,"stats":{"Line":4},"fn_name":"de_str"},{"line":446,"address":[2115344,2115515],"length":1,"stats":{"Line":1},"fn_name":"de_str"},{"line":473,"address":[2115572,2116357,2119493,2119590,2115383,2120411,2116938,2116161,2117344,2115967,2118128,2115769,2115548,2120515,2120985,2116752,2121093,2118541,2118645,2119999,2115351,2116554,2118746,2120616,2117736],"length":1,"stats":{"Line":18},"fn_name":null},{"line":474,"address":[2115367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[2115554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[2115750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[2115947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[2116145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[2116339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[2116535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[2116732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[2116930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[2117280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[2117655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[2118047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[2118623,2118689,2118421],"length":1,"stats":{"Line":3},"fn_name":null},{"line":489,"address":[2119035,2119634,2119583],"length":1,"stats":{"Line":3},"fn_name":null},{"line":490,"address":[2120291,2120559,2120493],"length":1,"stats":{"Line":3},"fn_name":null},{"line":491,"address":[2120905,2121067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":495,"address":[2121376,2121380],"length":1,"stats":{"Line":4},"fn_name":"de_json"},{"line":496,"address":[2122071,2121520,2122029],"length":1,"stats":{"Line":1},"fn_name":"de_json"},{"line":507,"address":[2121771,2121527,2121574,2122040],"length":1,"stats":{"Line":3},"fn_name":null},{"line":508,"address":[2121535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[2121744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[2122663,2122735,2122437],"length":1,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[2122086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[2122695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[2122628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[2123364,2123360],"length":1,"stats":{"Line":4},"fn_name":"de_newtype_struct"},{"line":527,"address":[2123504,2124042,2124068],"length":1,"stats":{"Line":1},"fn_name":"de_newtype_struct"},{"line":539,"address":[2124053,2123637,2123826,2123754],"length":1,"stats":{"Line":3},"fn_name":null},{"line":540,"address":[2123517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[2123719,2123786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":547,"address":[2124443,2124083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[2124708,2124487,2124388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[2124752,2124651,2124975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[2125019,2124917,2125243],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[2125287,2125184,2125509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":579,"address":[2141387,2129044,2131102,2148932,2138646,2147564,2142074,2129729,2131786,2145503,2167447,2150305,2139333,2128361,2126988,2133847,2137960,2144819,2150988,2125452,2155791,2156475,2159904,2153730,2157161,2137275,2142758,2166763,2163331,2125560,2127674,2149618,2164018,2153046,2155103,2132472,2161277,2126303,2135904,2136592,2154416,2164702,2165388,2166075,2140701,2169254,2125620,2146189,2158536,2135217,2143444,2133159,2152359,2161960,2162645,2168127,2146876,2168760,2130415,2148247,2140016,2151673,2160590,2144131,2159219,2134531,2157848],"length":1,"stats":{"Line":66},"fn_name":null}],"covered":155,"coverable":216},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value.rs"],"content":"use std::{borrow::Cow, fmt::Display, str::Utf8Error};\n\nuse rust_decimal::prelude::*;\nuse serde::{Deserialize, Serialize};\n\nuse super::{Timestamp, Ty};\n\n#[derive(Debug, Clone)]\npub enum BorrowedValue<'b> {\n    Null,        // 0\n    Bool(bool),  // 1\n    TinyInt(i8), // 2\n    SmallInt(i16),\n    Int(i32),\n    BigInt(i64),\n    Float(f32),\n    Double(f64),\n    VarChar(&'b str),\n    Timestamp(Timestamp),\n    NChar(Cow<'b, str>),\n    UTinyInt(u8),\n    USmallInt(u16),\n    UInt(u32),\n    UBigInt(u64), // 14\n    Json(Cow<'b, [u8]>),\n    VarBinary(&'b [u8]),\n    Decimal(Decimal),\n    Blob(&'b [u8]),\n    MediumBlob(&'b [u8]),\n}\n\nimpl<'b> BorrowedValue<'b> {\n    /// The data type of this value.\n    pub const fn ty(&self) -> Ty {\n        use BorrowedValue::*;\n        match self {\n            Null => Ty::Null,\n            Bool(_) => Ty::Bool,\n            TinyInt(_) => Ty::TinyInt,\n            SmallInt(_) => Ty::SmallInt,\n            Int(_) => Ty::Int,\n            BigInt(_) => Ty::BigInt,\n            UTinyInt(_) => Ty::UTinyInt,\n            USmallInt(_) => Ty::USmallInt,\n            UInt(_) => Ty::UInt,\n            UBigInt(_) => Ty::UBigInt,\n            Float(_) => Ty::Float,\n            Double(_) => Ty::Double,\n            VarChar(_) => Ty::VarChar,\n            Timestamp(_) => Ty::Timestamp,\n            Json(_) => Ty::Json,\n            NChar(_) => Ty::NChar,\n            VarBinary(_) => Ty::VarBinary,\n            Decimal(_) => Ty::Decimal,\n            Blob(_) => Ty::Blob,\n            MediumBlob(_) => Ty::MediumBlob,\n        }\n    }\n\n    /// Check if the value is null.\n    pub const fn is_null(&self) -> bool {\n        matches!(self, BorrowedValue::Null)\n    }\n    /// Only VarChar, NChar, Json could be treated as [&str].\n    fn strict_as_str(&self) -> &str {\n        use BorrowedValue::*;\n        match self {\n            VarChar(v) => *v,\n            NChar(v) => &v,\n            Null => panic!(\"expect str but value is null\"),\n            Timestamp(_) => panic!(\"expect str but value is timestamp\"),\n            _ => panic!(\"expect str but only varchar/binary/nchar is supported\"),\n        }\n    }\n    pub fn to_string(&self) -> Result<String, Utf8Error> {\n        use BorrowedValue::*;\n        match self {\n            Null => Ok(String::new()),\n            VarChar(v) => Ok(v.to_string()),\n            Json(v) => Ok(unsafe { std::str::from_utf8_unchecked(v) }.to_string()),\n            NChar(v) => Ok(v.to_string()),\n            TinyInt(v) => Ok(format!(\"{v}\")),\n            SmallInt(v) => Ok(format!(\"{v}\")),\n            Int(v) => Ok(format!(\"{v}\")),\n            BigInt(v) => Ok(format!(\"{v}\")),\n            UTinyInt(v) => Ok(format!(\"{v}\")),\n            USmallInt(v) => Ok(format!(\"{v}\")),\n            UInt(v) => Ok(format!(\"{v}\")),\n            UBigInt(v) => Ok(format!(\"{v}\")),\n            Float(v) => Ok(format!(\"{v}\")),\n            Double(v) => Ok(format!(\"{v}\")),\n            Timestamp(v) => Ok(v\n                .to_naive_datetime()\n                .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                .to_string()),\n            _ => unreachable!(\"un supported type to string\"),\n        }\n    }\n\n    pub fn to_value(&self) -> Value {\n        use BorrowedValue::*;\n        match self {\n            Null => Value::Null,\n            Bool(v) => Value::Bool(*v),\n            TinyInt(v) => Value::TinyInt(*v),\n            SmallInt(v) => Value::SmallInt(*v),\n            Int(v) => Value::Int(*v),\n            BigInt(v) => Value::BigInt(*v),\n            UTinyInt(v) => Value::UTinyInt(*v),\n            USmallInt(v) => Value::USmallInt(*v),\n            UInt(v) => Value::UInt(*v),\n            UBigInt(v) => Value::UBigInt(*v),\n            Float(v) => Value::Float(*v),\n            Double(v) => Value::Double(*v),\n            VarChar(v) => Value::VarChar(v.to_string()),\n            Timestamp(v) => Value::Timestamp(*v),\n            Json(v) => {\n                Value::Json(serde_json::from_slice(v).expect(\"json should always be deserialized\"))\n            }\n            NChar(str) => Value::NChar(str.to_string()),\n            VarBinary(_) => todo!(),\n            Decimal(_) => todo!(),\n            Blob(_) => todo!(),\n            MediumBlob(_) => todo!(),\n        }\n    }\n\n    #[inline]\n    pub fn into_value(self) -> Value {\n        use BorrowedValue::*;\n        match self {\n            Null => Value::Null,\n            Bool(v) => Value::Bool(v),\n            TinyInt(v) => Value::TinyInt(v),\n            SmallInt(v) => Value::SmallInt(v),\n            Int(v) => Value::Int(v),\n            BigInt(v) => Value::BigInt(v),\n            UTinyInt(v) => Value::UTinyInt(v),\n            USmallInt(v) => Value::USmallInt(v),\n            UInt(v) => Value::UInt(v),\n            UBigInt(v) => Value::UBigInt(v),\n            Float(v) => Value::Float(v),\n            Double(v) => Value::Double(v),\n            VarChar(v) => Value::VarChar(v.to_string()),\n            Timestamp(v) => Value::Timestamp(v),\n            Json(v) => {\n                Value::Json(serde_json::from_slice(&v).expect(\"json should always be deserialized\"))\n            }\n            NChar(str) => Value::NChar(str.to_string()),\n            VarBinary(_) => todo!(),\n            Decimal(_) => todo!(),\n            Blob(_) => todo!(),\n            MediumBlob(_) => todo!(),\n        }\n    }\n}\n\nunsafe impl<'b> Send for BorrowedValue<'b> {}\n\n// #[derive(Debug, Clone)]\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]\npub enum Value {\n    Null,        // 0\n    Bool(bool),  // 1\n    TinyInt(i8), // 2\n    SmallInt(i16),\n    Int(i32),\n    BigInt(i64),\n    Float(f32),\n    Double(f64),\n    VarChar(String),\n    Timestamp(Timestamp),\n    NChar(String),\n    UTinyInt(u8),\n    USmallInt(u16),\n    UInt(u32),\n    UBigInt(u64), // 14\n    Json(serde_json::Value),\n    VarBinary(Vec<u8>),\n    Decimal(Decimal),\n    Blob(Vec<u8>),\n    MediumBlob(Vec<u8>),\n}\n\nimpl Display for Value {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        todo!()\n    }\n}\n\nimpl Value {\n    /// The data type of this value.\n    pub const fn ty(&self) -> Ty {\n        use Value::*;\n        match self {\n            Null => Ty::Null,\n            Bool(_) => Ty::Bool,\n            TinyInt(_) => Ty::TinyInt,\n            SmallInt(_) => Ty::SmallInt,\n            Int(_) => Ty::Int,\n            BigInt(_) => Ty::BigInt,\n            UTinyInt(_) => Ty::UTinyInt,\n            USmallInt(_) => Ty::USmallInt,\n            UInt(_) => Ty::UInt,\n            UBigInt(_) => Ty::UBigInt,\n            Float(_) => Ty::Float,\n            Double(_) => Ty::Double,\n            VarChar(_) => Ty::VarChar,\n            Timestamp(_) => Ty::Timestamp,\n            Json(_) => Ty::Json,\n            NChar(_) => Ty::NChar,\n            VarBinary(_) => Ty::VarBinary,\n            Decimal(_) => Ty::Decimal,\n            Blob(_) => Ty::Blob,\n            MediumBlob(_) => Ty::MediumBlob,\n        }\n    }\n\n    pub fn to_borrowed_value(&self) -> BorrowedValue {\n        use Value::*;\n        match self {\n            Null => BorrowedValue::Null,\n            Bool(v) => BorrowedValue::Bool(*v),\n            TinyInt(v) => BorrowedValue::TinyInt(*v),\n            SmallInt(v) => BorrowedValue::SmallInt(*v),\n            Int(v) => BorrowedValue::Int(*v),\n            BigInt(v) => BorrowedValue::BigInt(*v),\n            UTinyInt(v) => BorrowedValue::UTinyInt(*v),\n            USmallInt(v) => BorrowedValue::USmallInt(*v),\n            UInt(v) => BorrowedValue::UInt(*v),\n            UBigInt(v) => BorrowedValue::UBigInt(*v),\n            Float(v) => BorrowedValue::Float(*v),\n            Double(v) => BorrowedValue::Double(*v),\n            VarChar(v) => BorrowedValue::VarChar(v),\n            Timestamp(v) => BorrowedValue::Timestamp(*v),\n            Json(j) => BorrowedValue::Json(j.to_string().into_bytes().into()),\n            NChar(v) => BorrowedValue::NChar(v.as_str().into()),\n            VarBinary(v) => BorrowedValue::VarBinary(v),\n            Decimal(v) => BorrowedValue::Decimal(*v),\n            Blob(v) => BorrowedValue::Blob(v),\n            MediumBlob(v) => BorrowedValue::MediumBlob(v),\n        }\n    }\n\n    /// Check if the value is null.\n    pub const fn is_null(&self) -> bool {\n        matches!(self, Value::Null)\n    }\n    /// Only VarChar, NChar, Json could be treated as [&str].\n    pub fn strict_as_str(&self) -> &str {\n        use Value::*;\n        match self {\n            VarChar(v) => v.as_str(),\n            NChar(v) => v.as_str(),\n            Json(v) => v.as_str().expect(\"invalid str type\"),\n            Null => \"Null\",\n            Timestamp(_) => panic!(\"expect str but value is timestamp\"),\n            _ => panic!(\"expect str but only varchar/binary/json/nchar is supported\"),\n        }\n    }\n\n    pub fn to_sql_value(&self) -> String {\n        use Value::*;\n        match self {\n            Null => \"NULL\".to_string(),\n            Bool(v) => format!(\"{v}\"),\n            TinyInt(v) => format!(\"{v}\"),\n            SmallInt(v) => format!(\"{v}\"),\n            Int(v) => format!(\"{v}\"),\n            BigInt(v) => format!(\"{v}\"),\n            Float(v) => format!(\"{v}\"),\n            Double(v) => format!(\"{v}\"),\n            VarChar(v) => format!(\"\\\"{}\\\"\", v.escape_debug()),\n            Timestamp(v) => format!(\"{}\", v.as_raw_i64()),\n            NChar(v) => format!(\"\\\"{}\\\"\", v.escape_debug()),\n            UTinyInt(v) => format!(\"{v}\"),\n            USmallInt(v) => format!(\"{v}\"),\n            UInt(v) => format!(\"{v}\"),\n            UBigInt(v) => format!(\"{v}\"),\n            Json(v) => format!(\"\\\"{}\\\"\", v),\n            VarBinary(_) => todo!(),\n            Decimal(_) => todo!(),\n            Blob(_) => todo!(),\n            MediumBlob(_) => todo!(),\n        }\n    }\n\n    pub fn to_string(&self) -> Result<String, Utf8Error> {\n        use Value::*;\n        match self {\n            Null => Ok(String::new()),\n            VarChar(v) => Ok(v.to_string()),\n            Json(v) => Ok(v.to_string()),\n            NChar(v) => Ok(v.to_string()),\n            TinyInt(v) => Ok(format!(\"{v}\")),\n            SmallInt(v) => Ok(format!(\"{v}\")),\n            Int(v) => Ok(format!(\"{v}\")),\n            BigInt(v) => Ok(format!(\"{v}\")),\n            UTinyInt(v) => Ok(format!(\"{v}\")),\n            USmallInt(v) => Ok(format!(\"{v}\")),\n            UInt(v) => Ok(format!(\"{v}\")),\n            UBigInt(v) => Ok(format!(\"{v}\")),\n            Float(v) => Ok(format!(\"{v}\")),\n            Double(v) => Ok(format!(\"{v}\")),\n            Timestamp(v) => Ok(v\n                .to_naive_datetime()\n                .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                .to_string()),\n            _ => unreachable!(\"un supported type to string\"),\n        }\n    }\n}\n\nmod de;\n","traces":[{"line":34,"address":[1930880],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":36,"address":[1930889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1930918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1930928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[1930935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[1930942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1930949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1930956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1930998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1931005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1931012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1931019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1930963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1930970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1930977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1930984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1931026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1930991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1931033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[1931040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[1931047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1931054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[1931072],"length":1,"stats":{"Line":1},"fn_name":"is_null"},{"line":62,"address":[1931081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1931120],"length":1,"stats":{"Line":0},"fn_name":"strict_as_str"},{"line":67,"address":[1931351,1931140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1931261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1931337,1931403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1931454,1931217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1931296,1931431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1931175,1931368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1933506,1931488],"length":1,"stats":{"Line":0},"fn_name":"to_string"},{"line":77,"address":[1931527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1931610,1934754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1933540,1931960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1932424,1932271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1932037,1933287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1934568,1931636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1934374,1931691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1931746,1934180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1933986,1931801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[1932075,1933101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1932124,1932913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1932173,1932725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1932222,1932537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1933792,1931856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1931911,1933598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1931999,1933335,1933444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1933487,1933395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[1934816],"length":1,"stats":{"Line":0},"fn_name":"to_value"},{"line":102,"address":[1934846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[1934882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1934900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1934942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1934981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1935022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1935061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1935305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1935344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1935385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1935424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1935102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1935145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[1935772,1935183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1935221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[1935460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1935618,1935472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[1935265,1935726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1935808,1936747],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":131,"address":[1935830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1935866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1935884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1935923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1935954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1935988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[1936019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1936276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[1936307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1936341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1936372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1936053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[1936090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1936122,1936892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1936171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1936401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1936619,1936419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1936786,1936216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1936928],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":193,"address":[1936976],"length":1,"stats":{"Line":1},"fn_name":"ty"},{"line":195,"address":[1936985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1937014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[1937024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1937031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1937038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1937045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1937052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[1937094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1937101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1937108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1937115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1937059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[1937066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1937073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1937080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1937122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1937087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1937129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1937136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[1937143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[1937150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1937168],"length":1,"stats":{"Line":0},"fn_name":"to_borrowed_value"},{"line":221,"address":[1937198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1937234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1937252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[1937294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1937333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1937374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1937413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1937663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1937702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[1937743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1937782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[1937454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1937497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[1937535,1938326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1937577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1938128,1937818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[1937621,1938236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[1938115,1937854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[1937897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[1937970,1938087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[1938005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1938352],"length":1,"stats":{"Line":1},"fn_name":"is_null"},{"line":247,"address":[1938361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[1938400],"length":1,"stats":{"Line":0},"fn_name":"strict_as_str"},{"line":252,"address":[1938420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[1938835,1938528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[1938790,1938604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[1938707,1938641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[1938497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1938802,1938560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1938671,1938455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[1938848],"length":1,"stats":{"Line":0},"fn_name":"to_sql_value"},{"line":264,"address":[1938887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1938932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[1941886,1938962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[1939017,1941748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1939072,1941610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[1939127,1941472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[1941334,1939182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[1939237,1941196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1939292,1941058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1940870,1939347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1939393,1940698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1939431,1940526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[1939477,1940388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[1940253,1939529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1940121,1939578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1939989,1939627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1939676,1939844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1943971,1942016],"length":1,"stats":{"Line":0},"fn_name":"to_string"},{"line":290,"address":[1942055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1942138,1945207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[1942476,1944005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[1942933,1942786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[1942552,1943752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[1942164,1945021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[1942219,1944827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1944633,1942274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[1944439,1942329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[1942590,1943566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[1942639,1943378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[1942688,1943190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[1943002,1942737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[1942378,1944251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[1944063,1942427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[1943909,1942514,1943800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[1943860,1943952],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":25,"coverable":180},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","de","mod.rs"],"content":"use std::any::type_name;\nuse std::marker::PhantomData;\n\nuse serde::de::{DeserializeSeed, IntoDeserializer, MapAccess, SeqAccess, Visitor};\nuse serde::Deserializer;\n\nuse serde::de::value::Error;\n\nuse crate::common::BorrowedValue;\nuse crate::Field;\n\n/// Row-based deserializer helper.\n///\n/// 'b: field lifetime may go across the whole query.\npub(crate) struct RecordDeserializer<'b, R>\nwhere\n    R: IntoIterator<Item = (&'b Field, BorrowedValue<'b>)>,\n{\n    inner: <R as IntoIterator>::IntoIter,\n    value: Option<BorrowedValue<'b>>,\n    _marker: PhantomData<&'b u8>,\n}\n\nimpl<'b, R> From<R> for RecordDeserializer<'b, R>\nwhere\n    R: IntoIterator<Item = (&'b Field, BorrowedValue<'b>)>,\n{\n    fn from(input: R) -> Self {\n        Self {\n            inner: input.into_iter(),\n            value: None,\n            _marker: PhantomData,\n        }\n    }\n}\n\nimpl<'b, R> RecordDeserializer<'b, R>\nwhere\n    R: IntoIterator<Item = (&'b Field, BorrowedValue<'b>)>,\n{\n    fn next_value(&mut self) -> Option<BorrowedValue<'b>> {\n        self.inner.next().map(|(_, v)| v)\n    }\n}\n\nimpl<'de, 'b: 'de, R> MapAccess<'de> for RecordDeserializer<'b, R>\nwhere\n    R: IntoIterator<Item = (&'b Field, BorrowedValue<'b>)>,\n{\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n    where\n        K: DeserializeSeed<'de>,\n    {\n        match self.inner.next() {\n            Some((field, value)) => {\n                self.value = Some(value);\n                let field = &*field;\n                seed.deserialize(field.name().into_deserializer()).map(Some)\n            }\n            _ => Ok(None),\n        }\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        let value = self.value.take().unwrap(); // always be here, so it's safe to unwrap\n\n        log::trace!(\"target value: {:?}\", type_name::<V::Value>());\n        seed.deserialize(value)\n            .map_err(<Self::Error as serde::de::Error>::custom)\n    }\n}\n\nimpl<'de, 'b: 'de, R> SeqAccess<'de> for RecordDeserializer<'b, R>\nwhere\n    R: IntoIterator<Item = (&'b Field, BorrowedValue<'b>)>,\n{\n    type Error = Error;\n\n    fn next_element_seed<S>(&mut self, seed: S) -> Result<Option<S::Value>, Self::Error>\n    where\n        S: DeserializeSeed<'de>,\n    {\n        match self.inner.next() {\n            Some((_, v)) => seed\n                .deserialize(v)\n                .map_err(<Self::Error as serde::de::Error>::custom)\n                .map(Some),\n            None => Ok(None),\n        }\n    }\n}\n\nimpl<'de, 'b: 'de, R> Deserializer<'de> for RecordDeserializer<'b, R>\nwhere\n    R: IntoIterator<Item = (&'b Field, BorrowedValue<'b>)>,\n{\n    type Error = Error;\n\n    // Look at the input data to decide what Serde data model type to\n    // deserialize as. Not all data formats are able to support this operation.\n    // Formats that support `deserialize_any` are known as self-describing.\n    fn deserialize_any<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::trace!(\"call deserialize any for <{}>\", type_name::<V>());\n        match self.next_value() {\n            Some(v) => v\n                .deserialize_any(visitor)\n                .map_err(<Self::Error as serde::de::Error>::custom),\n            None => Err(<Self::Error as serde::de::Error>::custom(\n                \"expect value, not none\",\n            )),\n        }\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char bytes byte_buf enum\n        identifier ignored_any\n    }\n\n    // Refer to the \"Understanding deserializer lifetimes\" page for information\n    // about the three deserialization flavors of strings in Serde.\n    fn deserialize_str<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::trace!(\"call deserialize_str for <{}>\", type_name::<V>());\n        match self.next_value() {\n            Some(v) => v\n                .deserialize_str(visitor)\n                .map_err(<Self::Error as serde::de::Error>::custom),\n            None => Err(<Self::Error as serde::de::Error>::custom(\n                \"expect value, not none\",\n            )),\n        }\n    }\n\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::debug!(\"call deserialize_option for <{}>\", type_name::<V>());\n        match self.next_value() {\n            Some(v) => {\n                if v.is_null() {\n                    visitor.visit_none()\n                } else {\n                    visitor\n                        .visit_some(v)\n                        .map_err(<Self::Error as serde::de::Error>::custom)\n                }\n            }\n            _ => Err(<Self::Error as serde::de::Error>::custom(\n                \"expect next value\",\n            )),\n        }\n    }\n\n    // In Serde, unit means an anonymous value containing no data.\n    fn deserialize_unit<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.next_value() {\n            Some(_v) => visitor.visit_unit(),\n            _ => Err(<Self::Error as serde::de::Error>::custom(\n                \"there's no enough value\",\n            )),\n        }\n    }\n\n    // Unit struct means a named value containing no data.\n    fn deserialize_unit_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_unit(visitor)\n    }\n\n    // As is done here, serializers are encouraged to treat newtype structs as\n    // insignificant wrappers around the data they contain. That means not\n    // parsing anything other than the contained value.\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::debug!(\"deserialize_newtype_struct: {}\", _name);\n        visitor.visit_newtype_struct(self)\n    }\n\n    // Deserialization of compound types like sequences and maps happens by\n    // passing the visitor an \"Access\" object that gives it the ability to\n    // iterate through the data contained in the sequence.\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_seq(self)\n    }\n\n    // Tuples look just like sequences.\n    fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        // self.deserialize_any(visitor)\n        visitor.visit_seq(self)\n    }\n\n    // Tuple structs look just like sequences.\n    fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    // Much like `deserialize_seq` but calls the visitors `visit_map` method\n    // with a `MapAccess` implementation, rather than the visitor's `visit_seq`\n    // method with a `SeqAccess` implementation.\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        // let value = visitor.visit_map(self);\n        // unimplemented!();\n        log::trace!(\"visit map for {}\", type_name::<V::Value>());\n        visitor.visit_map(self)\n    }\n\n    // Structs look just like maps in JSON.\n    //\n    // Notice the `fields` parameter - a \"struct\" in the Serde data model means\n    // that the `Deserialize` implementation is required to know what the fields\n    // are before even looking at the input data. Any key-value pairing in which\n    // the fields cannot be known ahead of time is probably a map.\n    fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        log::debug!(\"name: {_name}, fields: {_fields:?}\");\n        self.deserialize_map(visitor)\n    }\n}\n","traces":[{"line":28,"address":[2189120,2189216],"length":1,"stats":{"Line":2},"fn_name":"from<&taos_query::iter::QueryRowIter<taos_query::tests::Block>>"},{"line":30,"address":[3800066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[3788259,3789104,3789059,3789904,3787504,3788304],"length":1,"stats":{"Line":0},"fn_name":"next_key_seed<&taos_query::iter::QueryRowIter<taos::impls::SyncBlock>, core::marker::PhantomData<taos_query::helpers::describe::{impl#4}::deserialize::Meta>>"},{"line":56,"address":[3788423,3789134,3789223,3788334,3787534,3787623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[3787667,3789267,3788467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3787729,3787904,3788704,3788529,3789549,3789329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3788796,3787996,3789641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3788846,3788004,3789649,3789691,3788046,3788804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2190429,2191242,2189658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[2197601,2197632,2193894,2193168,2196896,2192377,2191680,2192416,2194633,2195424,2196160,2198337,2196865,2194672,2193936,2195388,2196129,2193132],"length":1,"stats":{"Line":0},"fn_name":"next_value_seed<&taos_query::iter::QueryRowIter<taos_query::tests::Block>, core::marker::PhantomData<taos_query::common::ty::Ty>>"},{"line":70,"address":[2192441,2196266,2192525,2191786,2191705,2194781,2196921,2195530,2193961,2196185,2195449,2197002,2197657,2193186,2193270,2197738,2194042,2194697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2193614,2194981,2197770,2193305,2192725,2195863,2192560,2198071,2195120,2197850,2194074,2196599,2197034,2194375,2195642,2194236,2194154,2192119,2191980,2194816,2197196,2195562,2192643,2192864,2195724,2197335,2193470,2197932,2191898,2194899,2191818,2193388,2196298,2197114,2196378,2196460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2192334,2194590,2195782,2192038,2193832,2193528,2196810,2192783,2196074,2196518,2195333,2193077,2197546,2197990,2194294,2198282,2195039,2197254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2200032,2200762,2198718,2199632,2201172,2199557,2198800,2199232,2198368,2199150,2199957,2200356,2200432,2200848],"length":1,"stats":{"Line":5},"fn_name":"next_element_seed<&taos_query::iter::QueryRowIter<taos_query::tests::Block>, core::marker::PhantomData<alloc::string::String>>"},{"line":88,"address":[2200872,2200456,2199256,2199656,2200125,2200941,2199325,2198824,2198893,2200525,2198461,2198392,2199725,2200056],"length":1,"stats":{"Line":12},"fn_name":null},{"line":89,"address":[2199528,2198977,2198672,2199104,2199481,2199070,2200737,2201147,2199388,2201100,2200331,2198545,2198638,2199788,2200597,2200690,2199881,2200284,2199928,2201007,2200191],"length":1,"stats":{"Line":18},"fn_name":null},{"line":90,"address":[2199015,2199826,2199426,2201045,2200229,2198583,2200635],"length":1,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[2199349,2200149,2200549,2198485,2200965,2199749,2198917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[2201248,2201376,2201312],"length":1,"stats":{"Line":2},"fn_name":"deserialize_tuple<taos_query::iter::RowInBlock<taos_query::tests::Block>, serde::de::impls::{impl#173}::deserialize::TupleVisitor<alloc::string::String, &str, u8>>"},{"line":228,"address":[2201395,2201331,2201267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2202004,2202031,2202656,2202612,2203220,2203247,2202048,2201440,2202639],"length":1,"stats":{"Line":0},"fn_name":"deserialize_map<&taos_query::iter::QueryRowIter<taos_query::tests::Block>, taos_query::helpers::describe::{impl#4}::deserialize::MetaVisitor>"},{"line":253,"address":[2201784,2201650,2202070,2202678,2202787,2203000,2202392,2202258,2202866,2201462,2202179,2201571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[2202919,2201703,2202311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[2203264,2203937,2203952,2204598,2204625,2203910],"length":1,"stats":{"Line":0},"fn_name":"deserialize_struct<&taos_query::iter::QueryRowIter<taos_query::tests::Block>, taos_query::helpers::topic::_::{impl#0}::deserialize::__Visitor>"},{"line":272,"address":[2203997,2203424,2204343,2203506,2204194,2204112,2203309,2203655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[2203574,2204262],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":65},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","database.rs"],"content":"use chrono::NaiveDateTime;\nuse paste::paste;\nuse serde::{Deserialize, Serialize};\n\nuse std::{fmt::Display, str::FromStr};\n\nuse crate::common::Precision;\n\n#[derive(Debug, Default, PartialEq, Eq, Serialize, Deserialize)]\npub struct DatabaseProperties {\n    pub vgroups: Option<u64>,\n    pub replica: Option<u16>,\n    pub quorum: Option<u16>,\n    pub days: Option<u16>,\n    pub keep: Option<String>,\n    #[serde(rename = \"cache(MB)\")]\n    pub cache: Option<u32>,\n    pub blocks: Option<u32>,\n    pub minrows: Option<u32>,\n    pub maxrows: Option<u32>,\n    #[serde(rename = \"wallevel\")]\n    pub wal: Option<u8>,\n    pub fsync: Option<u32>,\n    pub comp: Option<u8>,\n    pub cachelast: Option<u8>,\n    pub precision: Option<Precision>,\n    pub update: Option<u8>,\n}\n\nmacro_rules! _prop_builder {\n    ($($f:ident)*, $ty:ty) => {\n        $(pub fn $f(mut self, $f: $ty) -> Self {\n            self.$f = Some($f);\n            self\n        })*\n    };\n}\nimpl DatabaseProperties {\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    _prop_builder!(vgroups, u64);\n    _prop_builder!(cache blocks minrows maxrows fsync, u32);\n    _prop_builder!(replica quorum days, u16);\n    _prop_builder!(wal comp cachelast update, u8);\n    _prop_builder!(precision, Precision);\n    _prop_builder!(keep, String);\n}\n\nimpl Display for DatabaseProperties {\n    #[inline]\n    #[allow(unused_assignments)]\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let mut has_wrote = false;\n\n        macro_rules! _write_if {\n            ($($f:ident) *) => {\n                $(if let Some($f) = &self.$f {\n                    if has_wrote {\n                        write!(f, \" {} {}\", paste!(stringify!([<$f:upper>])), $f)?;\n                    } else {\n                        write!(f, \"{} {}\", paste!(stringify!([<$f:upper>])), $f)?;\n                        has_wrote = true;\n                    }\n                })*\n            };\n            ('str $($s:ident) *) => {\n                $(if let Some($s) = &self.$s {\n                    if has_wrote {\n                        write!(f, \" {} '{}'\", paste!(stringify!([<$s:upper>])), $s)?;\n                    } else {\n                        write!(f, \"{} '{}'\", paste!(stringify!([<$s:upper>])), $s)?;\n                        has_wrote = true;\n                    }\n                })*\n            };\n            ($($f:ident) *; 'str $($s:ident) *) => {\n                _write_if!($($f) *);\n                _write_if!('str $($s) *)\n            };\n            ($($f:ident) *; 'str $($s:ident) *; $($f2:ident) *) => {\n                _write_if!($($f) *; 'str $($s) *);\n                _write_if!($($f2) *)\n            };\n        }\n\n        // todo: keep now may fail\n        _write_if!(vgroups replica quorum days keep cache blocks minrows\n                   maxrows wal fsync comp cachelast; 'str precision; update);\n        Ok(())\n    }\n}\n\nimpl FromStr for DatabaseProperties {\n    type Err = anyhow::Error;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        // CREATE DATABASE log REPLICA 1 QUORUM 1 DAYS 10 KEEP 30 CACHE 1 BLOCKS 3 MINROWS 100 MAXROWS 4096 WAL 1 FSYNC 3000 COMP 2 CACHELAST 0 PRECISION 'us' UPDATE 0\n        use nom::branch::alt;\n        use nom::character::complete::*;\n        use nom::character::complete::{multispace0, multispace1};\n        use nom::character::streaming;\n        use nom::multi::many0;\n        use nom::sequence::*;\n        use nom::{bytes::complete::tag, IResult};\n\n        let mut repr = Self::new();\n\n        fn parse_name(s: &str) -> IResult<&str, &str> {\n            preceded(\n                tuple((multispace0, tag(\"CREATE DATABASE\"), multispace1)),\n                alphanumeric1,\n            )(s)\n        }\n\n        let s = parse_name(s).map(|s| s.0).unwrap_or(s);\n\n        fn parse_props(s: &str) -> IResult<&str, Vec<(&str, &str)>> {\n            many0(separated_pair(\n                preceded(multispace0, alphanumeric1),\n                streaming::char(' '),\n                alt((\n                    alphanumeric1,\n                    delimited(char('\\''), alphanumeric1, char('\\'')),\n                )),\n            ))(s)\n        }\n\n        if let Ok((_s, props)) = dbg!(parse_props(s)) {\n            for (prop, value) in props {\n                macro_rules! _parse {\n                    ($($($f:ident) +, $t:ident);*) => {\n                        paste::paste! {\n                            match prop.to_lowercase() {\n                                $($(s if s == stringify!($f) => {\n                                    repr = repr.$f($t::from_str(value)?);\n                                },)*)*\n                                _ => (),\n                            }\n                        }\n                    }\n                }\n                _parse!(vgroups, u64;\n                        cache blocks minrows maxrows fsync, u32;\n                        replica quorum days, u16;\n                        wal comp cachelast  update, u8;\n                        keep, String;\n                        precision, Precision);\n            }\n            Ok(repr)\n        } else {\n            Ok(repr)\n        }\n    }\n}\n\n#[test]\nfn db_prop_from_str() {\n    let s = \"REPLICA 1 QUORUM 1 DAYS 10 KEEP 30 CACHE 1 BLOCKS 3 MINROWS 100 MAXROWS 4096 WAL 1 FSYNC 3000 COMP 2 CACHELAST 0 PRECISION 'us' UPDATE 0\";\n\n    let db = DatabaseProperties::from_str(s).unwrap();\n\n    let t = db.to_string();\n\n    dbg!(db);\n\n    assert_eq!(s, t);\n}\n\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct DatabaseRepr {\n    pub name: String,\n    #[serde(flatten)]\n    pub props: DatabaseProperties,\n}\n\n/// A show database representation struct.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct ShowDatabase {\n    pub name: String,\n    pub created_time: Option<NaiveDateTime>,\n    pub ntables: Option<usize>,\n    #[serde(flatten)]\n    pub props: DatabaseProperties,\n    pub status: Option<String>,\n}\n\nunsafe impl Send for ShowDatabase {}\n","traces":[{"line":32,"address":[8412512,8412736,8413306,8412880,8413120,8412256,8412576,8412384,8412656,8412944,8412176,8413072,8413008,8412320,8412816,8412448],"length":1,"stats":{"Line":14},"fn_name":"vgroups"},{"line":33,"address":[8413259,8412399,8412527,8412756,8412898,8412271,8412596,8412676,8412962,8412335,8412834,8412193,8413026,8413147,8412463,8413088],"length":1,"stats":{"Line":15},"fn_name":null},{"line":34,"address":[2380569,2380834,2380432,2380761,2380994,2381132,2380633,2380697,2381196,2381307,2381068,2380505,2380914,2381260,2381490],"length":1,"stats":{"Line":14},"fn_name":null},{"line":35,"address":[8412503,8413222,8413067,8412939,8412311,8412375,8412239,8412641,8412439,8413301,8412721,8412567,8412875,8413114,8412801,8413003],"length":1,"stats":{"Line":14},"fn_name":null},{"line":39,"address":[8383552],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":40,"address":[8383560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[8383584],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":55,"address":[8383629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[8383637,8384055,8392735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2361216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[2361744,2362354],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":108,"address":[2361805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[8406464],"length":1,"stats":{"Line":1},"fn_name":"parse_name"},{"line":117,"address":[8393499,8393550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[8406672],"length":1,"stats":{"Line":1},"fn_name":"parse_props"},{"line":130,"address":[2362155,2362380,2362914,2374611],"length":1,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[2362986,2363196,2374508,2364089],"length":1,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[8394975,8395640,8406074,8406281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[2374532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[2363048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[2224752,2224757],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":160,"address":[2381543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[2381578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[2381659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[2381707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[2382669,2382553],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":48},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","describe.rs"],"content":"use std::{\n    fmt,\n    ops::{Deref, DerefMut},\n    str::FromStr,\n};\n\nuse serde::{\n    de::{self, MapAccess, SeqAccess, Visitor},\n    Deserialize, Deserializer, Serialize,\n};\n\nuse crate::common::Ty;\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]\npub struct Described {\n    pub field: String,\n    #[serde(rename = \"type\")]\n    pub ty: Ty,\n    pub length: usize,\n}\n\nimpl Described {\n    /// Represent the data type in sql.\n    ///\n    /// For example: \"INT\", \"VARCHAR(100)\".\n    pub fn sql_repr(&self) -> String {\n        let ty = self.ty;\n        if ty.is_var_type() {\n            format!(\"{} {}({})\", self.field, ty, self.length)\n        } else {\n            format!(\"{} {}\", self.field, self.ty)\n        }\n    }\n}\n#[derive(Debug, Serialize, PartialEq, Eq, Clone)]\n#[serde(tag = \"note\")]\npub enum ColumnMeta {\n    Column(Described),\n    Tag(Described),\n}\n\nimpl Deref for ColumnMeta {\n    type Target = Described;\n\n    fn deref(&self) -> &Self::Target {\n        match self {\n            ColumnMeta::Column(v) => v,\n            ColumnMeta::Tag(v) => v,\n        }\n    }\n}\n\nimpl DerefMut for ColumnMeta {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        match self {\n            ColumnMeta::Column(v) => v,\n            ColumnMeta::Tag(v) => v,\n        }\n    }\n}\nunsafe impl Send for ColumnMeta {}\nimpl<'de> Deserialize<'de> for ColumnMeta {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        enum Meta {\n            Field,\n            Type,\n            Length,\n            Note,\n        }\n\n        impl<'de> Deserialize<'de> for Meta {\n            fn deserialize<D>(deserializer: D) -> Result<Meta, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Meta;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"`field`, `type`, `length` or `note`\")\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Meta, E>\n                    where\n                        E: de::Error,\n                    {\n                        match value.to_lowercase().as_str() {\n                            \"field\" => Ok(Meta::Field),\n                            \"type\" => Ok(Meta::Type),\n                            \"length\" => Ok(Meta::Length),\n                            \"note\" => Ok(Meta::Note),\n                            _ => Err(de::Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct MetaVisitor;\n\n        impl<'de> Visitor<'de> for MetaVisitor {\n            type Value = ColumnMeta;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"struct ColumnMeta\")\n            }\n\n            fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                let field = dbg!(seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(0, &self))?);\n                let ty = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(1, &self))\n                    .and_then(|s| Ty::from_str(s).map_err(de::Error::custom))?;\n                let length = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(2, &self))?;\n                let note: String = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(3, &self))?;\n                let desc = Described { field, ty, length };\n                if note.is_empty() {\n                    Ok(ColumnMeta::Column(desc))\n                } else {\n                    Ok(ColumnMeta::Tag(desc))\n                }\n            }\n\n            fn visit_map<V>(self, mut map: V) -> Result<Self::Value, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                let mut field = None;\n                let mut ty = None;\n                let mut length = None;\n                let mut note = None;\n                while let Some(key) = map.next_key()? {\n                    match key {\n                        Meta::Field => {\n                            if field.is_some() {\n                                return Err(de::Error::duplicate_field(\"field\"));\n                            }\n                            field = Some(map.next_value()?);\n                        }\n                        Meta::Type => {\n                            if ty.is_some() {\n                                return Err(de::Error::duplicate_field(\"type\"));\n                            }\n                            let t: Ty = map.next_value()?;\n                            ty = Some(t);\n                        }\n                        Meta::Length => {\n                            if length.is_some() {\n                                return Err(de::Error::duplicate_field(\"length\"));\n                            }\n                            length = Some(map.next_value()?);\n                        }\n                        Meta::Note => {\n                            if note.is_some() {\n                                return Err(de::Error::duplicate_field(\"note\"));\n                            }\n                            let t: String = map.next_value()?;\n                            note = Some(t.is_empty() || t == \"Column\")\n                        }\n                    }\n                }\n                let field = field.ok_or_else(|| de::Error::missing_field(\"field\"))?;\n                let ty = ty.ok_or_else(|| de::Error::missing_field(\"type\"))?;\n                let length = length.ok_or_else(|| de::Error::missing_field(\"length\"))?;\n                let desc = Described { field, ty, length };\n                let note = note.ok_or_else(|| de::Error::missing_field(\"note\"))?;\n                if note {\n                    Ok(ColumnMeta::Column(desc))\n                } else {\n                    Ok(ColumnMeta::Tag(desc))\n                }\n            }\n        }\n\n        const FIELDS: &[&str] = &[\"field\", \"type\", \"length\", \"note\"];\n        deserializer.deserialize_struct(\"ColumnMeta\", FIELDS, MetaVisitor)\n    }\n}\nimpl ColumnMeta {\n    pub fn field(&self) -> &str {\n        match self {\n            ColumnMeta::Column(desc) | ColumnMeta::Tag(desc) => desc.field.as_str(),\n        }\n    }\n    pub fn ty(&self) -> Ty {\n        match self {\n            ColumnMeta::Column(desc) | ColumnMeta::Tag(desc) => desc.ty,\n        }\n    }\n    pub fn length(&self) -> usize {\n        match self {\n            ColumnMeta::Column(desc) | ColumnMeta::Tag(desc) => desc.length,\n        }\n    }\n    pub fn note(&self) -> &str {\n        match self {\n            ColumnMeta::Tag(_) => \"TAG\",\n            _ => \"\",\n        }\n    }\n    pub fn is_tag(&self) -> bool {\n        matches!(self, ColumnMeta::Tag(_))\n    }\n}\n\n#[test]\nfn serde_meta() {\n    let meta = ColumnMeta::Column(Described {\n        field: \"name\".to_string(),\n        ty: Ty::BigInt,\n        length: 8,\n    });\n\n    let a = serde_json::to_string(&meta).unwrap();\n\n    let d: ColumnMeta = serde_json::from_str(&a).unwrap();\n\n    assert_eq!(meta, d);\n}\n//erive(Debug, Clone, Deserialize)]\n// pub struct ColumnMeta {\n//     pub name: String,\n//     pub type_: Ty,\n//     pub bytes: i16,\n// }\n// #[derive(Debug)]\n// pub struct TaosQueryData {\n//     pub column_meta: Vec<ColumnMeta>,\n//     pub rows: Vec<Vec<Field>>,\n// }\n\n// #[derive(Debug)]\n// pub struct TaosDescribe {\n//     pub cols: Vec<ColumnMeta>,\n//     pub tags: Vec<ColumnMeta>,\n// }\n\n// impl TaosDescribe {\n//     pub fn names(&self) -> Vec<&String> {\n//         self.cols\n//             .iter()\n//             .chain(self.tags.iter())\n//             .map(|t| &t.name)\n//             .collect_vec()\n//     }\n\n//     pub fn col_names(&self) -> Vec<&String> {\n//         self.cols.iter().map(|t| &t.name).collect_vec()\n//     }\n//     pub fn tag_names(&self) -> Vec<&String> {\n//         self.tags.iter().map(|t| &t.name).collect_vec()\n//     }\n// }\n// impl FromStr for Ty {\n//     type Err = &'static str;\n//     fn from_str(s: &str) -> Result<Self, Self::Err> {\n//         match s.to_lowercase().as_str() {\n//             \"timestamp\" => Ok(Ty::Timestamp),\n//             \"bool\" => Ok(Ty::Bool),\n//             \"tinyint\" => Ok(Ty::TinyInt),\n//             \"smallint\" => Ok(Ty::SmallInt),\n//             \"int\" => Ok(Ty::Int),\n//             \"bigint\" => Ok(Ty::BigInt),\n//             \"tinyint unsigned\" => Ok(Ty::UTinyInt),\n//             \"smallint unsigned\" => Ok(Ty::USmallInt),\n//             \"int unsigned\" => Ok(Ty::UInt),\n//             \"bigint unsigned\" => Ok(Ty::UBigInt),\n//             \"float\" => Ok(Ty::Float),\n//             \"double\" => Ok(Ty::Double),\n//             \"binary\" => Ok(Ty::Binary),\n//             \"nchar\" => Ok(Ty::NChar),\n//             _ => Err(\"not a valid data type string\"),\n//         }\n//     }\n// }\n// impl From<TaosQueryData> for TaosDescribe {\n//     fn from(rhs: TaosQueryData) -> Self {\n//         let (cols, tags): (Vec<_>, Vec<_>) = rhs\n//             .rows\n//             .iter()\n//             .partition(|row| row[3] != Field::Binary(\"TAG\".into()));\n//         Self {\n//             cols: cols\n//                 .into_iter()\n//                 .map(|row| ColumnMeta {\n//                     name: row[0].to_string(),\n//                     type_: Ty::from_str(&row[1].to_string()).expect(\"from describe\"),\n//                     bytes: *row[2].as_int().unwrap() as _,\n//                 })\n//                 .collect_vec(),\n//             tags: tags\n//                 .into_iter()\n//                 .map(|row| ColumnMeta {\n//                     name: row[0].to_string(),\n//                     type_: Ty::from_str(&row[1].to_string()).expect(\"from describe\"),\n//                     bytes: *row[2].as_int().unwrap() as _,\n//                 })\n//                 .collect_vec(),\n//         }\n//     }\n// }\n// impl TaosQueryData {\n//     /// Total rows count of query result\n//     pub fn rows(&self) -> usize {\n//         self.rows.len()\n//     }\n// }\n\n// #[derive(Debug, PartialEq, Clone)]\n// pub enum Field {\n//     Null,        // 0\n//     Bool(bool),  // 1\n//     TinyInt(i8), // 2\n//     SmallInt(i16),\n//     Int(i32),\n//     BigInt(i64),\n//     Float(f32),\n//     Double(f64),\n//     Binary(BString),\n//     Timestamp(Timestamp),\n//     NChar(String),\n//     UTinyInt(u8),\n//     USmallInt(u16),\n//     UInt(u32),\n//     UBigInt(u64), // 14\n//     Json(serde_json::Value),\n// }\n\n// impl fmt::Display for Field {\n//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n//         match self {\n//             Field::Null => write!(f, \"NULL\"),\n//             Field::Bool(v) => write!(f, \"{}\", v),\n//             Field::TinyInt(v) => write!(f, \"{}\", v),\n//             Field::SmallInt(v) => write!(f, \"{}\", v),\n//             Field::Int(v) => write!(f, \"{}\", v),\n//             Field::BigInt(v) => write!(f, \"{}\", v),\n//             Field::Float(v) => write!(f, \"{}\", v),\n//             Field::Double(v) => write!(f, \"{}\", v),\n//             Field::Binary(v) => write!(f, \"{}\", v),\n//             Field::NChar(v) => write!(f, \"{}\", v),\n//             Field::Timestamp(v) => write!(f, \"{}\", v),\n//             Field::UTinyInt(v) => write!(f, \"{}\", v),\n//             Field::USmallInt(v) => write!(f, \"{}\", v),\n//             Field::UInt(v) => write!(f, \"{}\", v),\n//             Field::UBigInt(v) => write!(f, \"{}\", v),\n//             Field::Json(v) => write!(f, \"{}\", v),\n//         }\n//     }\n// }\n\n// impl Field {\n//     pub fn as_bool(&self) -> Option<&bool> {\n//         match self {\n//             Field::Bool(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_tiny_int(&self) -> Option<&i8> {\n//         match self {\n//             Field::TinyInt(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_small_int(&self) -> Option<&i16> {\n//         match self {\n//             Field::SmallInt(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_int(&self) -> Option<&i32> {\n//         match self {\n//             Field::Int(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_big_int(&self) -> Option<&i64> {\n//         match self {\n//             Field::BigInt(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_float(&self) -> Option<&f32> {\n//         match self {\n//             Field::Float(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_double(&self) -> Option<&f64> {\n//         match self {\n//             Field::Double(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_binary(&self) -> Option<&BStr> {\n//         match self {\n//             Field::Binary(v) => Some(v.as_ref()),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_nchar(&self) -> Option<&str> {\n//         match self {\n//             Field::NChar(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n\n//     /// BINARY or NCHAR typed string reference\n//     pub fn as_string(&self) -> Option<String> {\n//         match self {\n//             Field::Binary(v) => Some(v.to_string()),\n//             Field::NChar(v) => Some(v.to_string()),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_timestamp(&self) -> Option<&Timestamp> {\n//         match self {\n//             Field::Timestamp(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_raw_timestamp(&self) -> Option<i64> {\n//         match self {\n//             Field::Timestamp(v) => Some(v.as_raw_timestamp()),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_unsigned_tiny_int(&self) -> Option<&u8> {\n//         match self {\n//             Field::UTinyInt(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_unsigned_samll_int(&self) -> Option<&u16> {\n//         match self {\n//             Field::USmallInt(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_unsigned_int(&self) -> Option<&u32> {\n//         match self {\n//             Field::UInt(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n//     pub fn as_unsigned_big_int(&self) -> Option<&u64> {\n//         match self {\n//             Field::UBigInt(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n\n//     pub fn as_json(&self) -> Option<&serde_json::Value> {\n//         match self {\n//             Field::Json(v) => Some(v),\n//             _ => None,\n//         }\n//     }\n\n//     pub fn data_type(&self) -> Ty {\n//         match self {\n//             Field::Null => Ty::Null,\n//             Field::Bool(_v) => Ty::Bool,\n//             Field::TinyInt(_v) => Ty::TinyInt,\n//             Field::SmallInt(_v) => Ty::SmallInt,\n//             Field::Int(_v) => Ty::Int,\n//             Field::BigInt(_v) => Ty::BigInt,\n//             Field::Float(_v) => Ty::Float,\n//             Field::Double(_v) => Ty::Double,\n//             Field::Binary(_v) => Ty::Binary,\n//             Field::NChar(_v) => Ty::NChar,\n//             Field::Timestamp(_v) => Ty::Timestamp,\n//             Field::UTinyInt(_v) => Ty::UTinyInt,\n//             Field::USmallInt(_v) => Ty::USmallInt,\n//             Field::UInt(_v) => Ty::UInt,\n//             Field::UBigInt(_v) => Ty::UBigInt,\n//             Field::Json(_v) => Ty::Json,\n//         }\n//     }\n// }\n\n// pub trait IntoField {\n//     fn into_field(self) -> Field;\n// }\n\n// macro_rules! _impl_primitive_type {\n//     ($ty:ty, $target:ident, $v:expr) => {\n//         impl IntoField for $ty {\n//             fn into_field(self) -> Field {\n//                 Field::$target(self)\n//             }\n//         }\n//         paste! {\n//             #[test]\n//             fn [<test_ $ty:snake>]() {\n//                 let v: $ty = $v;\n//                 assert_eq!(v.clone().into_field(), Field::$target(v));\n//             }\n//         }\n//     };\n// }\n\n// _impl_primitive_type!(bool, Bool, true);\n// _impl_primitive_type!(i8, TinyInt, 0);\n// _impl_primitive_type!(i16, SmallInt, 0);\n// _impl_primitive_type!(i32, Int, 0);\n// _impl_primitive_type!(i64, BigInt, 0);\n// _impl_primitive_type!(u8, UTinyInt, 0);\n// _impl_primitive_type!(u16, USmallInt, 0);\n// _impl_primitive_type!(u32, UInt, 0);\n// _impl_primitive_type!(u64, UBigInt, 0);\n// _impl_primitive_type!(f32, Float, 0.);\n// _impl_primitive_type!(f64, Double, 0.);\n// _impl_primitive_type!(BString, Binary, \"A\".into());\n// _impl_primitive_type!(String, NChar, \"A\".into());\n// // _impl_primitive_type!(serde_json::Value, Json, );\n\n// impl IntoField for &BStr {\n//     fn into_field(self) -> Field {\n//         self.to_owned().into_field()\n//     }\n// }\n// impl IntoField for &str {\n//     fn into_field(self) -> Field {\n//         self.to_owned().into_field()\n//     }\n// }\n\n// #[cfg(test)]\n// mod test {\n//     use crate::test::taos;\n//     use crate::*;\n\n//     #[tokio::test]\n//     #[proc_test_catalog::test_catalogue]\n//     /// Test describe sql\n//     async fn test_describe() -> Result<(), Error> {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         println!(\"{}\", db);\n//         let taos = taos()?;\n//         let desc = taos.describe(\"log.dn\").await?;\n//         assert_eq!(desc.cols.len(), 15);\n//         assert_eq!(desc.tags.len(), 2);\n//         Ok(())\n//     }\n// }\n","traces":[{"line":26,"address":[3292352],"length":1,"stats":{"Line":0},"fn_name":"sql_repr"},{"line":27,"address":[3292382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3292389,3292859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[3292444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3292418,3292692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3292864],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":46,"address":[3292877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[3292895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[3292915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3292944],"length":1,"stats":{"Line":0},"fn_name":"deref_mut"},{"line":55,"address":[3293009,3292957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[3292975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[3292995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3341280,3341360],"length":1,"stats":{"Line":1},"fn_name":"deserialize<taos_query::de::RecordDeserializer<&taos_query::iter::QueryRowIter<taos_query::tests::Block>>>"},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[3341424,3341472],"length":1,"stats":{"Line":1},"fn_name":"deserialize<serde::de::value::StrDeserializer<serde::de::value::Error>>"},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3293024],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":85,"address":[3293051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3341991,3342507,3342032,3341504],"length":1,"stats":{"Line":1},"fn_name":"visit_str<serde::de::value::Error>"},{"line":92,"address":[3341547,3342159,3342075,3341631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[3341647,3341718,3342246,3342175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[3342218,3341753,3342325,3341797,3342281,3341690],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[3341769,3341862,3341818,3342346,3342390,3342297],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[3341941,3342414,3342465,3342362,3341834,3341886],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[3341975,3341902,3342430,3342495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3341445,3341489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3293088],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":112,"address":[3293115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3343707,3345387,3342560],"length":1,"stats":{"Line":0},"fn_name":"visit_seq<serde_json::de::SeqAccess<serde_json::read::StrRead>>"},{"line":119,"address":[3343194,3342782,3342837,3342878,3342602,3342676,3342901,3343253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3342821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3342851,3342774,3343208,3353584,3353596,3343178],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}<serde_json::de::SeqAccess<serde_json::read::StrRead>>"},{"line":122,"address":[3343775,3343700,3343896,3343937,3344080,3343960,3343849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3345420,3343841,3345408],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<serde_json::de::SeqAccess<serde_json::read::StrRead>>"},{"line":125,"address":[3345456,3345480,3344094,3344064,3343910],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}<serde_json::de::SeqAccess<serde_json::read::StrRead>>"},{"line":126,"address":[3344326,3344164,3344238,3344285,3344349,3344049,3344451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3344435,3344465,3345532,3344299,3344230,3345520],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}<serde_json::de::SeqAccess<serde_json::read::StrRead>>"},{"line":129,"address":[3344420,3344619,3344715,3344513,3344738,3344970,3344674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[3344688,3344611,3345580,3345568,3344954,3344984],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}<serde_json::de::SeqAccess<serde_json::read::StrRead>>"},{"line":132,"address":[3344840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3344935,3345073,3345218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[3345220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3345105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3350203,3345616,3352229,3348774,3348800,3346920],"length":1,"stats":{"Line":1},"fn_name":"visit_map<serde_json::de::MapAccess<serde_json::read::StrRead>>"},{"line":144,"address":[3348822,3345646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[3345679,3348855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[3345684,3348863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[3345696,3348875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[3351088,3349126,3345717,3348896,3345781,3345928,3347758,3348960],"length":1,"stats":{"Line":4},"fn_name":null},{"line":149,"address":[3347239,3350532,3349140,3345942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[3352205,3348750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[3347241,3350534,3351666,3348269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[3351692,3348295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[3352078,3348288,3348365,3351685,3351758,3348629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[3350565,3348033,3347269,3351397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[3348059,3351423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[3351584,3348203,3351416,3351507,3348129,3348052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[3348175,3351553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[3351305,3347957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[3351097,3347283,3350579,3347767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3351123,3347793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[3347786,3347967,3351116,3351191,3347863,3351315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[3350605,3347309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[3347362,3350658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3347355,3347432,3350860,3350651,3347546,3350726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[3347656,3347530,3350986,3351077,3347747,3350844],"length":1,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[3352256,3345976,3352260,3352304,3352308,3346172,3349174,3349383],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}<serde_json::de::MapAccess<serde_json::read::StrRead>>"},{"line":179,"address":[3346301,3352352,3352400,3349528,3352356,3349614,3346147,3346387,3352404,3349352],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}<taos_query::de::RecordDeserializer<&taos_query::iter::QueryRowIter<taos_query::tests::Block>>>"},{"line":180,"address":[3352500,3352496,3352448,3349708,3346351,3346481,3349578,3352452,3346653,3349900],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}<taos_query::de::RecordDeserializer<&taos_query::iter::QueryRowIter<taos_query::tests::Block>>>"},{"line":181,"address":[3346538,3349785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[3350112,3352592,3350018,3346625,3352596,3352544,3346845,3346771,3352548,3349872],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}<taos_query::de::RecordDeserializer<&taos_query::iter::QueryRowIter<taos_query::tests::Block>>>"},{"line":183,"address":[3350384,3350094,3346827,3347101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[3347103,3350386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[3346994,3350277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[3341294,3341377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[3293152],"length":1,"stats":{"Line":0},"fn_name":"field"},{"line":197,"address":[3293194,3293166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3293185,3293201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[3293248],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":202,"address":[3293261,3293288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[3293279,3293294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[3293328],"length":1,"stats":{"Line":0},"fn_name":"length"},{"line":207,"address":[3293341,3293368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3293374,3293359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[3293408],"length":1,"stats":{"Line":0},"fn_name":"note"},{"line":212,"address":[3293417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[3293423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3293445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[3293488],"length":1,"stats":{"Line":0},"fn_name":"is_tag"},{"line":218,"address":[3293497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[3295488,3296058,3296016],"length":1,"stats":{"Line":3},"fn_name":"serde_meta"},{"line":224,"address":[3295520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[3295495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[3295662,3295618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[3295776,3295700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[3295970,3295818,3295939],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":42,"coverable":102},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","mod.rs"],"content":"mod database;\nmod describe;\nmod topic;\n\npub use database::*;\npub use describe::*;\npub use topic::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","topic.rs"],"content":"use chrono::NaiveDateTime;\nuse paste::paste;\nuse serde::{Deserialize, Serialize};\n\nuse std::{fmt::Display, str::FromStr};\n\nuse crate::common::{Precision, Timestamp};\n\n/// Information for `show topics` record.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct Topic {\n    topic_name: String,\n    db_name: String,\n    create_time: Timestamp,\n    sql: String,\n}\n\nimpl Topic {\n    /// Topic name.\n    pub fn name(&self) -> &str {\n        &self.topic_name\n    }\n\n    /// Database name of the topic.\n    pub fn db_name(&self) -> &str {\n        &self.db_name\n    }\n\n    /// Created time of the topic\n    pub fn create_time(&self) -> NaiveDateTime {\n        self.create_time.to_naive_datetime()\n    }\n\n    /// The create sql for the topic\n    pub fn sql(&self) -> &str {\n        &self.sql\n    }\n\n    /// Check if the topic is a database-scope topic, otherwise is table-scope topic.\n    pub fn is_db_topic(&self) -> bool {\n        self.sql.contains(\"as database\")\n    }\n\n    pub fn is_stable_topic(&self) -> bool {\n        self.sql.contains(\"as stable\")\n    }\n}\n","traces":[{"line":20,"address":[2385296],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":21,"address":[2385305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[2385344],"length":1,"stats":{"Line":0},"fn_name":"db_name"},{"line":26,"address":[2385353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2385392],"length":1,"stats":{"Line":0},"fn_name":"create_time"},{"line":31,"address":[2385409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[2385440],"length":1,"stats":{"Line":0},"fn_name":"sql"},{"line":36,"address":[2385449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2385488],"length":1,"stats":{"Line":0},"fn_name":"is_db_topic"},{"line":41,"address":[2385497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[2385568],"length":1,"stats":{"Line":0},"fn_name":"is_stable_topic"},{"line":45,"address":[2385577],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","insert","mod.rs"],"content":"use std::fmt::Debug;\n\npub trait Insertable: Debug {\n    type Error;\n    fn insert(&self, sql: &str) -> Result<usize, Self::Error>;\n\n    fn insert_raw(&self, table: &str, raw: &[u8]) -> Result<usize, Self::Error>;\n\n    fn insert_named<'a>(&self, table: &str, fields: [&dyn IntoNamedField<'a>]);\n\n    // fn insert_many<T: Any>(&self, table: &str, records: &[dyn Any]) -> Result<usize, Self::Error>;\n\n    // fn insert_progressive(&self, stable: &str, ) -> Inserter;\n}\n\npub trait IntoField: Debug {}\n\nimpl IntoField for i32 {}\nimpl IntoField for f32 {}\nimpl IntoField for f64 {}\n\npub trait IntoNamedField<'a>: IntoField {\n    fn name(&'a self) -> &'a str;\n}\nimpl<T: IntoField> IntoField for (&str, T) {}\n\nimpl<'a, T: IntoField> IntoNamedField<'a> for (&str, T) {\n    fn name(&'a self) -> &'a str {\n        self.0\n    }\n}\n\n/// Insert macros.\n///\n/// insert! {\n///    \"ts\" => [\"2022-10-10T10:10:10.000\", \"2022-10-10T10:10:11\", \"2022-10-10T10:10:12\"],\n///    \"n\" => [0, 1, 2],\n///    \"f\" => [0.1, 0.2, 0.3],\n///    \"g\" => [\"abc\", \"def\", \"desc\"]: VarChar,\n/// }\n// macro_rules! {\n//     ($conn:expr, $sql:expr, $raw: )\n// }\n\n#[test]\nfn obj() {\n    fn t1(_fields: &[&dyn IntoField]) {}\n\n    let v = vec![&10 as _, &0.0 as _];\n    t1(&v);\n\n    fn insert_named<'a>(_fields: &[&dyn IntoNamedField<'a>]) {}\n\n    let v = vec![&(\"a\", 0) as _, &(\"b\", 0.0) as _];\n    insert_named(&v);\n\n    for e in v {\n        dbg!(e.name());\n    }\n}\n","traces":[{"line":28,"address":[2640688,2640704],"length":1,"stats":{"Line":2},"fn_name":"name<i32>"},{"line":29,"address":[2640693,2640709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[2209049,2207808,2209101],"length":1,"stats":{"Line":3},"fn_name":"obj"},{"line":47,"address":[2209149,2209136],"length":1,"stats":{"Line":2},"fn_name":"t1"},{"line":49,"address":[2207815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2208005,2207926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2209181,2209168],"length":1,"stats":{"Line":2},"fn_name":"insert_named"},{"line":54,"address":[2208022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2208124,2208204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[2209044,2208211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[2208516],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":11,"coverable":11},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","iter","mod.rs"],"content":"use super::*;\n\npub struct CellIter<'b, T: BlockExt> {\n    block: &'b T,\n    row: usize,\n    col: usize,\n}\n\nimpl<'b, T: BlockExt> Iterator for CellIter<'b, T> {\n    type Item = (&'b Field, BorrowedValue<'b>);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let col = self.col;\n        if col < self.block.field_count() {\n            self.col += 1;\n            Some(unsafe { self.block.cell_unchecked(self.row, col) })\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct RowInBlock<'b, T: BlockExt> {\n    block: &'b T,\n    row: usize,\n}\n\nimpl<'b, T> IntoIterator for RowInBlock<'b, T>\nwhere\n    T: BlockExt,\n{\n    type Item = (&'b Field, BorrowedValue<'b>);\n\n    type IntoIter = CellIter<'b, T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        CellIter {\n            block: self.block,\n            row: self.row,\n            col: 0,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct RowsIter<'b, T: BlockExt> {\n    block: &'b T,\n    row: usize,\n}\n\nimpl<'b, T> RowsIter<'b, T>\nwhere\n    T: BlockExt,\n{\n    pub(crate) fn new(block: &'b T) -> Self {\n        Self { block, row: 0 }\n    }\n}\n\nimpl<'b, T> Iterator for RowsIter<'b, T>\nwhere\n    T: BlockExt,\n{\n    type Item = RowInBlock<'b, T>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let row = self.row;\n\n        if row < self.block.num_of_rows() {\n            self.row += 1;\n            Some(RowInBlock {\n                block: self.block,\n                row,\n            })\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct IntoRowsIter<T: BlockExt> {\n    block: Rc<T>,\n    row: usize,\n}\n\nimpl<T> IntoRowsIter<T>\nwhere\n    T: BlockExt,\n{\n    pub(crate) fn new(block: T) -> Self {\n        Self {\n            block: Rc::new(block),\n            row: 0,\n        }\n    }\n}\n\npub struct QueryRowIter<T: BlockExt> {\n    block: Rc<T>,\n    row: usize,\n}\n\nimpl<'b, T> IntoIterator for &'b QueryRowIter<T>\nwhere\n    T: BlockExt,\n{\n    type Item = (&'b Field, BorrowedValue<'b>);\n\n    type IntoIter = CellIter<'b, T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        CellIter {\n            block: &self.block,\n            row: self.row,\n            col: 0,\n        }\n    }\n}\n\nimpl<T> Iterator for IntoRowsIter<T>\nwhere\n    T: BlockExt,\n{\n    type Item = QueryRowIter<T>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let row = self.row;\n\n        if row < self.block.num_of_rows() {\n            self.row += 1;\n            Some(QueryRowIter {\n                block: self.block.clone(),\n                row,\n            })\n        } else {\n            None\n        }\n    }\n}\n\npub struct ColsIter<'b, T: BlockExt> {\n    block: &'b T,\n    col: usize,\n}\nimpl<'b, T> ColsIter<'b, T>\nwhere\n    T: BlockExt,\n{\n    pub(crate) fn new(block: &'b T) -> Self {\n        Self { block, col: 0 }\n    }\n}\n\nimpl<'b, T> Iterator for ColsIter<'b, T>\nwhere\n    T: BlockExt,\n{\n    type Item = BorrowedColumn<'b>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.col >= self.block.field_count() {\n            return None;\n        }\n\n        let v = unsafe { self.block.get_col_unchecked(self.col) };\n        self.col += 1;\n        Some(v)\n    }\n}\n","traces":[{"line":12,"address":[3737888],"length":1,"stats":{"Line":2},"fn_name":"next<taos::impls::SyncBlock>"},{"line":13,"address":[3737912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[3737964,3737926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[3738030,3737971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[3738065,3738010],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[3737960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3738528],"length":1,"stats":{"Line":2},"fn_name":"into_iter<taos::impls::SyncBlock>"},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[3737152],"length":1,"stats":{"Line":2},"fn_name":"new<taos::impls::SyncBlock>"},{"line":67,"address":[3738096],"length":1,"stats":{"Line":2},"fn_name":"next<taos::impls::SyncBlock>"},{"line":68,"address":[2182110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[2182161,2182240,2182124],"length":1,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[2182168,2182242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[2182210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[2182207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3738153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[3737200],"length":1,"stats":{"Line":0},"fn_name":"new<taos::impls::SyncBlock>"},{"line":94,"address":[3737207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2182336],"length":1,"stats":{"Line":0},"fn_name":"into_iter<taos_query::tests::Block>"},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[3737066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[2182448],"length":1,"stats":{"Line":0},"fn_name":"next<taos_query::tests::Block>"},{"line":129,"address":[2182462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2182539,2182505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[2182546,2182592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2182632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2182580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2182530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[2182688],"length":1,"stats":{"Line":0},"fn_name":"new<taos_query::tests::Block>"},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":38},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","lib.rs"],"content":"//! This is the common query traits/types for TDengine connectors.\n//!\n#![cfg_attr(nightly, feature(const_slice_from_raw_parts))]\n#![cfg_attr(nightly, feature(const_slice_index))]\n\nuse futures::stream::TryStreamExt;\nuse itertools::Itertools;\nuse mdsn::IntoDsn;\npub use mdsn::{Address, Dsn, DsnError};\nuse serde::de::{value::Error as DeError, DeserializeOwned};\nuse std::{fmt::Debug, marker::PhantomData, rc::Rc};\n\npub mod common;\nmod de;\npub mod helpers;\nmod insert;\n\nmod iter;\npub(crate) mod util;\n\npub use iter::*;\n\nuse async_trait::async_trait;\nuse common::*;\nuse helpers::*;\n\npub enum CodecOpts {\n    Raw,\n    Parquet,\n}\n\npub trait BlockCodec {\n    fn encode(&self, _codec: CodecOpts) -> Vec<u8>;\n    fn decode(from: &[u8], _codec: CodecOpts) -> Self;\n}\n\ntype DeserializeIter<'b, B, T> =\n    std::iter::Map<RowsIter<'b, B>, fn(RowInBlock<'b, B>) -> Result<T, DeError>>;\n\n/// Trait to define a data `Block` to fetch records bulky.\n///\n/// If query performance is not your main concern, you can just use the deserialize method from result set.\npub trait BlockExt: Debug + Sized {\n    /// A block should container number of rows.\n    fn num_of_rows(&self) -> usize;\n\n    /// Fields can be queried from a block.\n    fn fields(&self) -> &[Field];\n\n    /// Number of fields.\n    fn field_count(&self) -> usize {\n        self.fields().len()\n    }\n\n    fn precision(&self) -> Precision;\n\n    fn is_null(&self, row: usize, col: usize) -> bool;\n\n    /// Get field without column index check.\n    ///\n    /// # Safety\n    ///\n    /// This should not be called manually, please use [get_field](#method.get_field).\n    unsafe fn get_field_unchecked(&self, col: usize) -> &Field {\n        self.fields().get_unchecked(col)\n    }\n\n    /// Get field of one column.\n    fn get_field(&self, col: usize) -> Option<&Field> {\n        self.fields().get(col)\n    }\n\n    /// # Safety\n    ///\n    /// **DO NOT** call it directly.\n    unsafe fn cell_unchecked(&self, row: usize, col: usize) -> (&Field, BorrowedValue);\n\n    unsafe fn get_col_unchecked(&self, col: usize) -> BorrowedColumn;\n\n    /// Query by rows.\n    fn iter_rows(&self) -> RowsIter<'_, Self> {\n        RowsIter::new(self)\n    }\n\n    /// Consume self into rows.\n    fn into_iter_rows(self) -> IntoRowsIter<Self> {\n        IntoRowsIter::new(self)\n    }\n\n    /// Columns iterator with borrowed data from block.\n    fn columns_iter(&self) -> ColsIter<'_, Self> {\n        ColsIter::new(self)\n    }\n\n    fn to_records(&self) -> Vec<Vec<Value>> {\n        self.iter_rows()\n            .map(|row| row.into_iter().map(|(f, v)| v.into_value()).collect_vec())\n            .collect_vec()\n    }\n\n    /// Deserialize a row to a record type(primitive type or a struct).\n    ///\n    /// Any record could borrow data from the block, so that &[u8], &[str] could be used as record element (if valid).\n    fn deserialize<'b, T>(&'b self) -> DeserializeIter<'b, Self, T>\n    where\n        T: serde::de::Deserialize<'b>,\n    {\n        self.iter_rows().map(|row| {\n            let de = de::RecordDeserializer::from(row);\n            T::deserialize(de)\n        })\n    }\n\n    /// Deserialize a row to a record type(primitive type or a struct).\n    ///\n    /// Any record could borrow data from the block, so that &[u8], &[str] could be used as record element (if valid).\n    fn deserialize_into<T>(\n        self,\n    ) -> std::iter::Map<IntoRowsIter<Self>, fn(QueryRowIter<Self>) -> Result<T, DeError>>\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        self.into_iter_rows().map(|row| {\n            let de = de::RecordDeserializer::from(&row);\n            T::deserialize(de)\n        })\n    }\n\n    /// Shortcut version to `.deserialize_into.collect::<Vec<T>>()`\n    fn deserialize_into_vec<T>(self) -> Vec<Result<T, DeError>>\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        self.deserialize_into().collect()\n    }\n\n    /// Rows as [futures::stream::Stream].\n    fn rows_stream(&self) -> futures::stream::Iter<RowsIter<'_, Self>> {\n        futures::stream::iter(Self::iter_rows(self))\n    }\n\n    /// Owned version to rows stream.\n    fn into_rows_stream(self) -> futures::stream::Iter<IntoRowsIter<Self>> {\n        futures::stream::iter(Self::into_iter_rows(self))\n    }\n\n    /// Rows stream to deserialized record.\n    fn deserialize_stream<'b, T>(&'b self) -> futures::stream::Iter<DeserializeIter<'b, Self, T>>\n    where\n        T: serde::de::Deserialize<'b>,\n    {\n        futures::stream::iter(Self::deserialize(self))\n    }\n}\n\npub trait Fetchable\nwhere\n    Self: Sized,\n    for<'r> &'r mut Self: Iterator,\n    for<'b, 'r> <&'r mut Self as Iterator>::Item: BlockExt,\n{\n    // type Block: for<'b> BlockExt;\n\n    fn affected_rows(&self) -> i32;\n\n    fn precision(&self) -> Precision;\n\n    fn fields(&self) -> &[Field];\n\n    fn num_of_fields(&self) -> usize {\n        self.fields().len()\n    }\n\n    fn summary(&self) -> (usize, usize);\n\n    fn blocks_iter(&mut self) -> &mut Self {\n        self\n    }\n\n    fn to_rows_vec(&mut self) -> Vec<Vec<Value>> {\n        self.rows_iter()\n            .map(|row| row.into_iter().map(|(_, v)| v.into_value()).collect())\n            .collect()\n    }\n\n    fn rows_iter<'r>(\n        &'r mut self,\n    ) -> std::iter::FlatMap<\n        &'r mut Self,\n        IntoRowsIter<<&'r mut Self as Iterator>::Item>,\n        fn(<&'r mut Self as Iterator>::Item) -> IntoRowsIter<<&'r mut Self as Iterator>::Item>,\n    > {\n        self.flat_map(|block| block.into_iter_rows())\n    }\n\n    fn deserialize<T>(\n        &mut self,\n    ) -> std::iter::FlatMap<\n        &mut Self,\n        Vec<Result<T, DeError>>,\n        fn(<&mut Self as Iterator>::Item) -> Vec<Result<T, DeError>>,\n    >\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        self.flat_map(|block| block.deserialize_into_vec())\n    }\n}\n\n/// The synchronous query trait for TDengine connection.\npub trait Queryable<'q>: Debug\nwhere\n    for<'r> &'r mut Self::ResultSet: Iterator,\n    for<'b, 'r> <&'r mut Self::ResultSet as Iterator>::Item: BlockExt,\n{\n    type Error: Debug + From<serde::de::value::Error>;\n    // type B: for<'b> BlockExt<'b, 'b>;\n    type ResultSet: Fetchable;\n\n    fn query<T: AsRef<str>>(&'q self, sql: T) -> Result<Self::ResultSet, Self::Error>;\n\n    fn exec<T: AsRef<str>>(&'q self, sql: T) -> Result<usize, Self::Error> {\n        self.query(sql).map(|res| res.affected_rows() as _)\n    }\n\n    fn exec_many<T: AsRef<str>, I: IntoIterator<Item = T>>(\n        &'q self,\n        input: I,\n    ) -> Result<usize, Self::Error> {\n        input\n            .into_iter()\n            .map(|sql| self.exec(sql))\n            .try_fold(0, |mut acc, aff| {\n                acc += aff?;\n                Ok(acc)\n            })\n    }\n\n    fn query_one<T: AsRef<str>, O: DeserializeOwned>(\n        &'q self,\n        sql: T,\n    ) -> Result<Option<O>, Self::Error> {\n        self.query(sql)?\n            .deserialize::<O>()\n            .next()\n            .map_or(Ok(None), |v| v.map(Some).map_err(Into::into))\n    }\n\n    fn create_topic(\n        &'q self,\n        name: impl AsRef<str>,\n        sql: impl AsRef<str>,\n    ) -> Result<(), Self::Error> {\n        let (name, sql) = (name.as_ref(), sql.as_ref());\n        let query = format!(\"create topic if not exists {name} as {sql}\");\n\n        self.query(&query)?;\n        Ok(())\n    }\n\n    fn create_topic_as_database(\n        &'q self,\n        name: impl AsRef<str>,\n        db: impl std::fmt::Display,\n    ) -> Result<(), Self::Error> {\n        let name = name.as_ref();\n        let query = format!(\"create topic if not exists {name} as database {db}\");\n\n        self.exec(&query)?;\n        Ok(())\n    }\n\n    fn databases(&'q self) -> Result<Vec<ShowDatabase>, Self::Error> {\n        self.query(\"show databases\")?\n            .deserialize()\n            .try_collect()\n            .map_err(Into::into)\n    }\n\n    /// Topics information by `show topics` sql.\n    ///\n    /// ## Compatibility\n    ///\n    /// This is a 3.x-only API.\n    fn topics(&'q self) -> Result<Vec<Topic>, Self::Error> {\n        self.query(\"show topics\")?\n            .deserialize()\n            .try_collect()\n            .map_err(Into::into)\n    }\n\n    fn describe(&'q self, table: &str) -> Result<Describe, Self::Error> {\n        Ok(Describe(\n            self.query(format!(\"describe {table}\"))?\n                .deserialize()\n                .try_collect()?,\n        ))\n    }\n}\n\npub trait AsyncFetchable\nwhere\n    Self: Sized + Send,\n    Self::BlockStream: futures::stream::Stream + Send,\n    <Self::BlockStream as futures::stream::Stream>::Item: BlockExt + Send,\n{\n    type BlockStream;\n    // type Block: for<'b> BlockExt;\n\n    fn affected_rows(&self) -> i32;\n\n    fn precision(&self) -> Precision;\n\n    fn fields(&self) -> &[Field];\n\n    fn num_of_fields(&self) -> usize {\n        self.fields().len()\n    }\n\n    fn summary(&self) -> (usize, usize);\n\n    fn blocks_iter(&mut self) -> &mut Self {\n        self\n    }\n\n    fn block_stream(&mut self) -> Self::BlockStream;\n\n    fn into_blocks(mut self) -> Self::BlockStream {\n        self.block_stream()\n    }\n\n    /// Records is a row-based 2-dimension matrix of values.\n    fn to_records(&mut self) -> Vec<Vec<Value>> {\n        futures::executor::block_on_stream(Box::pin(self.block_stream()))\n            .flat_map(|block| block.to_records())\n            .collect()\n    }\n\n    fn deserialize_stream<T>(\n        &mut self,\n    ) -> futures::stream::FlatMap<\n        <Self as AsyncFetchable>::BlockStream,\n        futures::stream::Iter<std::vec::IntoIter<Result<T, DeError>>>,\n        fn(\n            <Self::BlockStream as futures::stream::Stream>::Item,\n        ) -> futures::stream::Iter<std::vec::IntoIter<Result<T, DeError>>>,\n    >\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        // self.blocks_iter()\n        use futures::stream::StreamExt;\n        self.block_stream()\n            .flat_map(|block| futures::stream::iter(block.deserialize_into_vec::<T>()))\n    }\n}\n\n/// The synchronous query trait for TDengine connection.\n#[async_trait]\npub trait AsyncQueryable<'q>: Send + Sync\nwhere\n    <Self::AsyncResultSet as AsyncFetchable>::BlockStream: 'q + futures::stream::Stream,\n    for<'b> <<Self::AsyncResultSet as AsyncFetchable>::BlockStream as futures::stream::Stream>::Item:\n        BlockExt + Send,\n{\n    type Error: Debug + From<serde::de::value::Error> + Send;\n    // type B: for<'b> BlockExt<'b, 'b>;\n    type AsyncResultSet: AsyncFetchable;\n\n    async fn query<T: AsRef<str> + Send>(\n        &'q self,\n        sql: T,\n    ) -> Result<Self::AsyncResultSet, Self::Error>;\n\n    async fn exec<T: AsRef<str> + Send>(&'q self, sql: T) -> Result<usize, Self::Error> {\n        let sql = sql.as_ref();\n        log::trace!(\"exec sql: {sql}\");\n        self.query(sql).await.map(|res| res.affected_rows() as _)\n    }\n\n    async fn exec_many<T, I>(&'q self, input: I) -> Result<usize, Self::Error>\n    where\n        T: AsRef<str> + Send,\n        I::IntoIter: Send,\n        I: IntoIterator<Item = T> + Send,\n    {\n        let mut aff = 0;\n        for sql in input {\n            aff += self.exec(sql).await?;\n        }\n        Ok(aff)\n    }\n\n    /// To conveniently get first row of the result, useful for queries like\n    ///\n    /// - `select count(*) from ...`\n    /// - `select last(*) from ...`\n    ///\n    /// Type `T` could be `Vec<taos::query::common::Value>`, a tuple, or a struct with serde support.\n    ///\n    /// ## Example\n    ///\n    /// ```rust,ignore\n    /// let count: u32 = taos.query_one(\"select count(*) from table1\")?.unwrap_or(0);\n    ///\n    /// let one: (i32, String, Timestamp) =\n    ///    taos.query_one(\"select c1,c2,c3 from table1 limit 1\")?.unwrap_or_default();\n    /// ```\n    async fn query_one<T: AsRef<str> + Send, O: DeserializeOwned + Send>(\n        &'q self,\n        sql: T,\n    ) -> Result<Option<O>, Self::Error> {\n        use futures::StreamExt;\n        self.query(sql)\n            .await?\n            .deserialize_stream::<O>()\n            .take(1)\n            .collect::<Vec<_>>()\n            .await\n            .into_iter()\n            .next()\n            .map_or(Ok(None), |v| v.map(Some).map_err(Into::into))\n    }\n\n    async fn create_topic<N: AsRef<str> + Send, S: AsRef<str> + Send>(\n        &'q self,\n        name: N,\n        sql: S,\n    ) -> Result<(), Self::Error> {\n        let (name, sql) = (name.as_ref(), sql.as_ref());\n        let query = format!(\"create topic if not exists {name} as {sql}\");\n\n        self.query(query).await?;\n        Ok(())\n    }\n\n    async fn create_topic_as_database(\n        &'q self,\n        name: impl AsRef<str> + Send + 'async_trait,\n        db: impl std::fmt::Display + Send + 'async_trait,\n    ) -> Result<(), Self::Error> {\n        let name = name.as_ref();\n        let query = format!(\"create topic if not exists {name} as database {db}\");\n\n        self.exec(&query).await?;\n        Ok(())\n    }\n\n    async fn databases(&'q self) -> Result<Vec<ShowDatabase>, Self::Error> {\n        use futures::stream::TryStreamExt;\n        Ok(self\n            .query(\"show databases\")\n            .await?\n            .deserialize_stream()\n            .try_collect()\n            .await?)\n    }\n\n    /// Topics information by `show topics` sql.\n    ///\n    /// ## Compatibility\n    ///\n    /// This is a 3.x-only API.\n    async fn topics(&'q self) -> Result<Vec<Topic>, Self::Error> {\n        Ok(self\n            .query(\"show topics\")\n            .await?\n            .deserialize_stream()\n            .try_collect()\n            .await?)\n    }\n\n    async fn describe(&'q self, table: &str) -> Result<Describe, Self::Error> {\n        Ok(Describe(\n            self.query(format!(\"describe {table}\"))\n                .await?\n                .deserialize_stream()\n                .try_collect()\n                .await?,\n        ))\n    }\n\n    fn exec_sync<T: AsRef<str> + Send>(&'q self, sql: T) -> Result<usize, Self::Error> {\n        futures::executor::block_on(self.exec(sql))\n    }\n\n    fn query_sync<T: AsRef<str> + Send>(\n        &'q self,\n        sql: T,\n    ) -> Result<Self::AsyncResultSet, Self::Error> {\n        futures::executor::block_on(self.query(sql))\n    }\n}\n\npub trait FromDsn: Sized + 'static {\n    type Err: std::error::Error;\n\n    /// Validate or hygienize the DSN.\n    ///\n    /// ## Error\n    ///\n    /// When there're multi addresses, validate all addresses for connection,\n    /// and filter success addresses. When all addresses of DSN are invalid,\n    /// return last error. When success, it will return a pair of DSN and\n    /// filtered addresses.\n    fn hygienize(dsn: Dsn) -> Result<(Dsn, Vec<Address>), DsnError>;\n\n    /// Generate a connection object from DSN.\n    fn from_dsn<T: IntoDsn>(dsn: T) -> Result<Self, Self::Err>;\n\n    /// Is the connection available?\n    fn ping(dsn: &Dsn) -> Result<(), Self::Err>;\n}\n\n/// This is how we manage connections.\npub struct Manager<T: FromDsn> {\n    dsn: Dsn,\n    marker: PhantomData<T>,\n}\n\nimpl<T: FromDsn> Default for Manager<T> {\n    fn default() -> Self {\n        Self {\n            dsn: Dsn {\n                driver: \"taos\".to_string(),\n                ..Default::default()\n            },\n            marker: Default::default(),\n        }\n    }\n}\n\nimpl<T: FromDsn + Send + Sync> Manager<T> {\n    /// Build a connection manager from a DSN.\n    #[inline]\n    pub fn new(dsn: Dsn) -> Result<Self, DsnError> {\n        let (dsn, _) = T::hygienize(dsn)?;\n\n        Ok(Self {\n            dsn,\n            marker: PhantomData,\n        })\n    }\n\n    /// Parse a DSN format from str.\n    #[inline]\n    pub fn parse(dsn: impl AsRef<str>) -> Result<Self, DsnError> {\n        let dsn = Dsn::parse(dsn)?;\n        Self::new(dsn)\n    }\n\n    #[inline]\n    pub fn from_dsn(dsn: impl IntoDsn) -> Result<Self, DsnError> {\n        let dsn = dsn.into_dsn()?;\n        Self::new(dsn)\n    }\n\n    /// Open a connection to TDengine.\n    #[inline]\n    pub fn connect(&self) -> Result<T, <T as FromDsn>::Err> {\n        T::from_dsn(&self.dsn)\n    }\n\n    #[cfg(feature = \"r2d2\")]\n    #[inline]\n    pub fn into_pool(self) -> Result<Pool<T>, r2d2::Error> {\n        r2d2::Pool::new(self)\n    }\n\n    #[cfg(feature = \"r2d2\")]\n    #[inline]\n    pub fn into_pool_with_builder(\n        self,\n        builder: r2d2::Builder<Self>,\n    ) -> Result<Pool<T>, r2d2::Error> {\n        builder.build(self)\n    }\n}\n\n#[cfg(feature = \"r2d2\")]\npub type Pool<T> = r2d2::Pool<Manager<T>>;\n\n#[cfg(feature = \"r2d2\")]\nimpl<T: FromDsn + Send + Sync + 'static> r2d2::ManageConnection for Manager<T> {\n    type Connection = T;\n    type Error = <T as FromDsn>::Err;\n\n    #[inline]\n    fn connect(&self) -> Result<Self::Connection, Self::Error> {\n        self.connect()\n    }\n\n    #[inline]\n    fn is_valid(&self, _: &mut Self::Connection) -> Result<(), Self::Error> {\n        <T as FromDsn>::ping(&self.dsn)\n    }\n\n    #[inline]\n    fn has_broken(&self, _: &mut Self::Connection) -> bool {\n        false\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::forward_to_deserialize_any;\n    use std::marker::PhantomData;\n\n    use super::*;\n    #[derive(Debug)]\n    struct Conn;\n\n    #[derive(Debug)]\n    struct Value<'s>(&'s str);\n\n    struct Deserializer;\n\n    impl<'de> serde::de::Deserializer<'de> for Deserializer {\n        type Error = serde::de::value::Error;\n        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: serde::de::Visitor<'de>,\n        {\n            visitor.visit_i32(1)\n        }\n\n        forward_to_deserialize_any! {\n            bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n            seq bytes byte_buf map unit_struct newtype_struct\n            tuple_struct struct tuple enum identifier ignored_any\n        }\n    }\n\n    impl<'de, 's: 'de> serde::de::Deserializer<'de> for Value<'s> {\n        type Error = serde::de::value::Error;\n        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: serde::de::Visitor<'de>,\n        {\n            visitor.visit_i32(1)\n        }\n\n        forward_to_deserialize_any! {\n            bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char unit option\n            seq byte_buf map unit_struct newtype_struct\n            tuple_struct struct tuple enum identifier ignored_any\n        }\n\n        fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: serde::de::Visitor<'de>,\n        {\n            visitor.visit_borrowed_str(self.0)\n        }\n        fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: serde::de::Visitor<'de>,\n        {\n            self.deserialize_str(visitor)\n        }\n        fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: serde::de::Visitor<'de>,\n        {\n            const V: u32 = 0x0f0f0f0f;\n            let v: &[u8; 4] = unsafe { std::mem::transmute(&V) };\n            visitor.visit_borrowed_bytes(v)\n        }\n    }\n\n    #[derive(Debug)]\n    struct MyResultSet<'q>(PhantomData<&'q u8>);\n\n    #[derive(Debug)]\n    struct Block<'r, 'q>(PhantomData<(&'r u8, &'q u8)>);\n\n    impl<'b, 'r, 'q> BlockExt for Block<'r, 'q> {\n        fn num_of_rows(&self) -> usize {\n            1\n        }\n\n        fn fields(&self) -> &[Field] {\n            static mut FIELDS: Vec<Field> = Vec::new();\n            unsafe {\n                if FIELDS.len() == 0 {\n                    FIELDS.push(Field::new(\"ts\", Ty::Timestamp, 8));\n                    FIELDS.push(Field::new(\"bin10\", Ty::VarChar, 10));\n                    FIELDS.push(Field::new(\"int32\", Ty::Int, 4));\n                }\n                &FIELDS\n            }\n        }\n\n        fn precision(&self) -> Precision {\n            Precision::Microsecond\n        }\n\n        fn is_null(&self, _row: usize, _col: usize) -> bool {\n            false\n        }\n\n        fn field_count(&self) -> usize {\n            3\n        }\n\n        unsafe fn cell_unchecked(&self, _row: usize, col: usize) -> (&Field, BorrowedValue) {\n            match col {\n                0 => (\n                    self.get_field_unchecked(col) as _,\n                    BorrowedValue::Timestamp(crate::Timestamp::Milliseconds(0)),\n                ),\n                2 => (self.get_field_unchecked(col) as _, BorrowedValue::Int(32)),\n                1 => (\n                    self.get_field_unchecked(col) as _,\n                    BorrowedValue::VarChar(\"str\"),\n                ),\n                _ => (self.get_field_unchecked(col) as _, BorrowedValue::Int(32)),\n            }\n        }\n\n        unsafe fn get_col_unchecked(&self, _col: usize) -> BorrowedColumn {\n            todo!()\n        }\n    }\n\n    impl<'r, 'q> Iterator for &'r mut MyResultSet<'q> {\n        type Item = Block<'r, 'q>;\n\n        fn next(&mut self) -> Option<Self::Item> {\n            static mut AVAILABLE: bool = true;\n            if unsafe { AVAILABLE } {\n                unsafe { AVAILABLE = false };\n\n                Some(Block(PhantomData))\n            } else {\n                None\n            }\n        }\n    }\n\n    impl<'r, 'q> crate::Fetchable for MyResultSet<'q> {\n        fn fields(&self) -> &[Field] {\n            todo!()\n        }\n\n        fn precision(&self) -> Precision {\n            todo!()\n        }\n\n        fn summary(&self) -> (usize, usize) {\n            todo!()\n        }\n\n        fn affected_rows(&self) -> i32 {\n            todo!()\n        }\n    }\n\n    #[derive(Debug)]\n    struct Error;\n\n    impl<'q> Queryable<'q> for Conn {\n        type Error = anyhow::Error;\n\n        type ResultSet = MyResultSet<'q>;\n\n        fn query<T: AsRef<str>>(&'q self, _sql: T) -> Result<MyResultSet, Self::Error> {\n            Ok(MyResultSet(PhantomData))\n        }\n\n        fn exec<T: AsRef<str>>(&self, _sql: T) -> Result<usize, Self::Error> {\n            Ok(1)\n        }\n    }\n    #[test]\n    fn query_deserialize() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut rs = conn.query(\"abc\").unwrap();\n\n        for record in rs.deserialize::<(i32, String, u8)>() {\n            dbg!(record.unwrap());\n        }\n    }\n    #[test]\n    fn block_deserialize_borrowed() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n        for block in &mut set {\n            for record in block.deserialize::<(i32, &str, u8)>() {\n                dbg!(record.unwrap());\n            }\n        }\n    }\n    #[test]\n    fn block_deserialize_borrowed_bytes() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n\n        for block in &mut set {\n            for record in block.deserialize::<(String, &str, u8)>() {\n                dbg!(record.unwrap());\n            }\n        }\n    }\n    #[tokio::test]\n    async fn block_deserialize_borrowed_bytes_stream() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n\n        use futures::stream::*;\n\n        for block in &mut set {\n            for record in block\n                .deserialize_stream::<(String, &str, u8)>()\n                .next()\n                .await\n            {\n                dbg!(record.unwrap());\n            }\n        }\n    }\n    #[test]\n    fn with_iter() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n\n        for block in &mut set {\n            // todo\n            for row in block.iter_rows() {\n                for value in row {\n                    println!(\"{:?}\", value);\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":51,"address":[3759920],"length":1,"stats":{"Line":0},"fn_name":"field_count<taos::impls::SyncBlock>"},{"line":52,"address":[3759929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3329088],"length":1,"stats":{"Line":2},"fn_name":"get_field_unchecked<taos_query::tests::Block>"},{"line":65,"address":[3329107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[3329168],"length":1,"stats":{"Line":0},"fn_name":"get_field<taos_query::tests::Block>"},{"line":70,"address":[3329187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[3329248],"length":1,"stats":{"Line":2},"fn_name":"iter_rows<taos_query::tests::Block>"},{"line":82,"address":[3329257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[3329296],"length":1,"stats":{"Line":0},"fn_name":"into_iter_rows<taos_query::tests::Block>"},{"line":87,"address":[3329300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3329328],"length":1,"stats":{"Line":0},"fn_name":"columns_iter<taos_query::tests::Block>"},{"line":92,"address":[3329337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[3329376],"length":1,"stats":{"Line":0},"fn_name":"to_records<taos_query::tests::Block>"},{"line":96,"address":[3329408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2814224,2814254,2814112,2814165],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<taos_query::tests::Block>"},{"line":104,"address":[3329584,3329488],"length":1,"stats":{"Line":2},"fn_name":"deserialize<taos_query::tests::Block, (i32, &str, u8)>"},{"line":108,"address":[2814336,2814464],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}<taos_query::tests::Block, (i32, &str, u8)>"},{"line":109,"address":[2814529,2814401],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[2814411,2814539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[3329808,3329680,3329872,3329744],"length":1,"stats":{"Line":0},"fn_name":"deserialize_into<taos_query::tests::Block, (i32, alloc::string::String, u8)>"},{"line":123,"address":[2815167,2814751,2814592,2814959,2815008,2815375,2814800,2815216],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<taos_query::tests::Block, (i32, alloc::string::String, u8)>"},{"line":124,"address":[2815260,2814636,2814844,2815052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2815305,2815097,2814681,2814889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3330128,3329936,3330064,3330000],"length":1,"stats":{"Line":0},"fn_name":"deserialize_into_vec<taos_query::tests::Block, taos_query::helpers::describe::ColumnMeta>"},{"line":134,"address":[3329950,3330078,3330142,3330014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3330192],"length":1,"stats":{"Line":0},"fn_name":"rows_stream<taos_query::tests::Block>"},{"line":139,"address":[3330201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[3330256],"length":1,"stats":{"Line":0},"fn_name":"into_rows_stream<taos_query::tests::Block>"},{"line":144,"address":[3330260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[3330320],"length":1,"stats":{"Line":0},"fn_name":"deserialize_stream<taos_query::tests::Block, (alloc::string::String, &str, u8)>"},{"line":152,"address":[3330339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[3330384],"length":1,"stats":{"Line":0},"fn_name":"num_of_fields<taos_query::tests::MyResultSet>"},{"line":171,"address":[3330393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[3330416],"length":1,"stats":{"Line":0},"fn_name":"blocks_iter<taos_query::tests::MyResultSet>"},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[3330432],"length":1,"stats":{"Line":0},"fn_name":"to_rows_vec<taos_query::tests::MyResultSet>"},{"line":181,"address":[3330450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2815616,2815462,2815584,2815424],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<taos_query::tests::MyResultSet>"},{"line":186,"address":[3330512],"length":1,"stats":{"Line":0},"fn_name":"rows_iter<taos_query::tests::MyResultSet>"},{"line":193,"address":[2815680,2815689],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<taos_query::tests::MyResultSet>"},{"line":196,"address":[3330656,3330608,3330704,3330560],"length":1,"stats":{"Line":1},"fn_name":"deserialize<taos_query::tests::MyResultSet, taos_query::helpers::topic::Topic>"},{"line":206,"address":[2815744,2815776,2815728,2815824,2815808,2815840,2815760,2815792],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}<taos_query::tests::MyResultSet, (i32, alloc::string::String, u8)>"},{"line":222,"address":[3778352],"length":1,"stats":{"Line":0},"fn_name":"exec<taos::Taos, alloc::string::String>"},{"line":223,"address":[3414185,3414176],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<taos::Taos, alloc::string::String>"},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[3330981,3330752],"length":1,"stats":{"Line":0},"fn_name":"databases<taos_query::tests::Conn>"},{"line":274,"address":[3330788,3330955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3331237,3331008],"length":1,"stats":{"Line":0},"fn_name":"topics<taos_query::tests::Conn>"},{"line":286,"address":[3331044,3331211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[3331264,3331914],"length":1,"stats":{"Line":0},"fn_name":"describe<taos_query::tests::Conn>"},{"line":293,"address":[3331765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3331304,3331868,3331627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[3331836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3759584],"length":1,"stats":{"Line":0},"fn_name":"num_of_fields<taos::impls::ResultSet>"},{"line":317,"address":[3759593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[3759456],"length":1,"stats":{"Line":0},"fn_name":"blocks_iter<taos::impls::ResultSet>"},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[3759541,3759472],"length":1,"stats":{"Line":0},"fn_name":"into_blocks<taos::impls::ResultSet>"},{"line":329,"address":[3759489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[3759200],"length":1,"stats":{"Line":0},"fn_name":"to_records<taos::impls::ResultSet>"},{"line":334,"address":[3759388,3759225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3406032,3406060],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<taos::impls::ResultSet>"},{"line":339,"address":[3759744,3759680,3759616],"length":1,"stats":{"Line":0},"fn_name":"deserialize_stream<taos::impls::ResultSet, taos_query::helpers::describe::ColumnMeta>"},{"line":353,"address":[3759699,3759635,3759763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[3406286,3406190,3406256,3406160,3406382,3406352],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<taos::impls::ResultSet, taos_query::helpers::database::ShowDatabase>"},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[3411001,3411145,3410688,3410743,3411442,3412662],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}<taos::Taos>"},{"line":451,"address":[3411599,3411377,3411205,3411814,3412145,3412270,3412485,3411498,3411867,3412070,3411919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[3410963,3411453,3411272,3410881,3411399,3411533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[3411738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[3412092,3410899,3411946,3412209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[3412453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[3406905,3408422,3407202,3406503,3406761,3406448],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}<taos::Taos>"},{"line":465,"address":[3408030,3408245,3407830,3406965,3407679,3407359,3407258,3407574,3407627,3407137,3407905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[3406641,3406723,3407032,3407159,3407213,3407293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[3407498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[3407969,3406659,3407852,3407706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[3408213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[3410653,3408783,3408464,3408927,3409400,3408519],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}<taos::Taos>"},{"line":474,"address":[3410350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[3408657,3409070,3409411,3410028,3409772,3409877,3410104,3410476,3408742,3409825,3410229,3409015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[3409696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[3410051,3408675,3409904,3410168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[3410444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[1846160],"length":1,"stats":{"Line":2},"fn_name":"num_of_rows"},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[1846176],"length":1,"stats":{"Line":2},"fn_name":"fields"},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[1846191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":686,"address":[1846219,1846285],"length":1,"stats":{"Line":4},"fn_name":null},{"line":687,"address":[1846302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":688,"address":[1846357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":690,"address":[1846259],"length":1,"stats":{"Line":2},"fn_name":null},{"line":694,"address":[1846448],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":695,"address":[1846457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[1846480],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[1846512],"length":1,"stats":{"Line":2},"fn_name":"field_count"},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[1846528],"length":1,"stats":{"Line":2},"fn_name":"cell_unchecked"},{"line":707,"address":[1846579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":708,"address":[1846946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":709,"address":[1846644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":710,"address":[1846903],"length":1,"stats":{"Line":2},"fn_name":null},{"line":712,"address":[1846669,1846853],"length":1,"stats":{"Line":4},"fn_name":null},{"line":713,"address":[1846816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[1846694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":715,"address":[1846781],"length":1,"stats":{"Line":2},"fn_name":null},{"line":717,"address":[1846622,1846715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[1846976],"length":1,"stats":{"Line":0},"fn_name":"get_col_unchecked"},{"line":729,"address":[1847024],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[1847047,1847033],"length":1,"stats":{"Line":3},"fn_name":null},{"line":732,"address":[1847049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":734,"address":[1847056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":736,"address":[1847042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[1847088],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":746,"address":[1847136],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":750,"address":[1847184],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":754,"address":[1847232],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":767,"address":[3332000,3331952],"length":1,"stats":{"Line":2},"fn_name":"query<alloc::string::String>"},{"line":768,"address":[3332019,3331972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":771,"address":[3332048],"length":1,"stats":{"Line":1},"fn_name":"exec<&str>"},{"line":772,"address":[3332074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":776,"address":[1848990,1849006,1847792],"length":1,"stats":{"Line":3},"fn_name":"query_deserialize"},{"line":779,"address":[1847799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":780,"address":[1847860,1848003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[1848059,1847952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":784,"address":[1849001,1848071,1848372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[1848294,1848399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[1849040],"length":1,"stats":{"Line":3},"fn_name":"block_deserialize_borrowed"},{"line":792,"address":[1849047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[1849224,1849102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":795,"address":[1849277,1849185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":796,"address":[1849289,1849505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":797,"address":[1849510,1849368,1850132],"length":1,"stats":{"Line":3},"fn_name":null},{"line":798,"address":[1849574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":803,"address":[1851337,1850144],"length":1,"stats":{"Line":3},"fn_name":"block_deserialize_borrowed_bytes"},{"line":806,"address":[1850151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":807,"address":[1850212,1850355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":809,"address":[1850304,1850411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[1850645,1850423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":812,"address":[1851363,1850508,1850650],"length":1,"stats":{"Line":3},"fn_name":null},{"line":813,"address":[1850676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[1851376,1851696,1851723,1851383],"length":1,"stats":{"Line":6},"fn_name":"block_deserialize_borrowed_bytes_stream"},{"line":821,"address":[3332341,3332577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":822,"address":[3332634,3332771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[3332835,3332728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":828,"address":[1851490,1851403],"length":1,"stats":{"Line":3},"fn_name":null},{"line":829,"address":[3333000,3333097,3333363,3334315,3333654,3333172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[3332395,3333331,3333136,3333049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[3333681,3333560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[1852564,1851760],"length":1,"stats":{"Line":3},"fn_name":"with_iter"},{"line":842,"address":[1851767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":843,"address":[1851932,1851816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":845,"address":[1851985,1851893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[1851997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[1852076,1852345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[1852350,1852240,1852590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[1852406,1852473],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":65,"coverable":233},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","util","inline_bytes.rs"],"content":"use std::fmt;\n\n#[repr(C)]\n#[repr(packed(1))]\npub struct InlineBytes<T = u16> {\n    len: T,\n    data: [u8; 0],\n}\n\nmacro_rules! _impl_inline_lines {\n    ($($ty:ty) *) => {\n        $(\n\n            impl fmt::Debug for InlineBytes<$ty> {\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    f.debug_struct(\"InlineBytes\")\n                        .field(\"len\", &self.len())\n                        .field(\"data\", &self.as_bytes())\n                        .finish()\n                }\n            }\n\n            impl fmt::Display for InlineBytes<$ty> {\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    f.write_str(&self.printable())\n                }\n            }\n\n            impl AsRef<[u8]> for InlineBytes<$ty> {\n                fn as_ref(&self) -> &[u8] {\n                    self.as_bytes()\n                }\n            }\n\n            impl InlineBytes<$ty> {\n                #[inline]\n                pub fn from_ptr<'a>(ptr: *const u8) -> &'a Self {\n                    unsafe { std::mem::transmute::<*const u8, &InlineBytes<$ty>>(ptr) }\n                }\n                #[inline]\n                #[rustversion::attr(nightly, const)]\n                pub fn as_bytes(&self) -> &[u8] {\n                    unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len()) }\n                }\n\n                #[inline]\n                pub fn printable(&self) -> String {\n                    String::from_utf8(self.as_bytes().iter().flat_map(|b| b.escape_ascii().into_iter()).collect()).expect(\"\")\n                }\n\n                #[inline]\n                pub const fn len(&self) -> usize {\n                    self.len as _\n                }\n\n                #[inline]\n                pub fn encode(v: &[u8]) -> Vec<u8> {\n                    let len = v.len() as $ty;\n                    let mut vec = Vec::with_capacity(v.len() + std::mem::size_of::<$ty>());\n                    vec.extend(len.to_le_bytes());\n                    vec.extend(v);\n                    vec\n                }\n            }\n        )*\n    };\n}\n_impl_inline_lines!(u8 u16 u32 u64 usize);\n\nmacro_rules! _impl_test_inline_lines {\n    ($ty:ty, $bytes:literal) => {{\n        let bytes = $bytes;\n        let inline = InlineBytes::<$ty>::from_ptr(bytes.as_ptr());\n        dbg!(inline);\n        assert_eq!(inline.len(), 4);\n        assert_eq!(inline.as_ref(), b\"abcd\");\n        assert_eq!(inline.to_string(), \"abcd\");\n        assert_eq!(InlineBytes::<$ty>::encode(b\"abcd\"), bytes);\n    }};\n}\n\n#[test]\nfn test_inline_lines() {\n    _impl_test_inline_lines!(u8, b\"\\x04abcd\");\n    _impl_test_inline_lines!(u16, b\"\\x04\\x00abcd\");\n    _impl_test_inline_lines!(u32, b\"\\x04\\x00\\x00\\x00abcd\");\n    _impl_test_inline_lines!(u64, b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcd\");\n}\n","traces":[{"line":15,"address":[2761216,2762128,2763040,2759360,2760288],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":16,"address":[2760307,2763102,2760415,2759379,2759487,2761235,2759422,2761343,2762147,2763167,2760350,2763059,2762190,2761278,2762255],"length":1,"stats":{"Line":12},"fn_name":null},{"line":17,"address":[2759407,2762175,2761263,2763087,2760335],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[2762230,2761318,2760390,2763142,2759462],"length":1,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[2762320,2759552,2762452,2760612,2763364,2759684,2761408,2761540,2763232,2760480],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":25,"address":[2760505,2763257,2763336,2762345,2762424,2759656,2759577,2760584,2761433,2761512],"length":1,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[2762496,2761584,2760656,2763408,2759728],"length":1,"stats":{"Line":4},"fn_name":"as_ref"},{"line":31,"address":[2760665,2761593,2762505,2759737,2763417],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[2762544,2763456,2759776,2760704,2761632],"length":1,"stats":{"Line":4},"fn_name":"from_ptr"},{"line":38,"address":[2763465,2761641,2759785,2762553,2760713],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[2764240,2764144,2764336,2763952,2764048],"length":1,"stats":{"Line":4},"fn_name":"as_bytes"},{"line":43,"address":[2764254,2764350,2763966,2764158,2764062],"length":1,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[2762576,2760736,2763488,2759808,2761664],"length":1,"stats":{"Line":4},"fn_name":"printable"},{"line":48,"address":[2759846,2763526,2761702,2760774,2762614],"length":1,"stats":{"Line":12},"fn_name":null},{"line":52,"address":[2761856,2763680,2762768,2760000,2760928],"length":1,"stats":{"Line":4},"fn_name":"len"},{"line":53,"address":[2760005,2762773,2763685,2761861,2760933],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[2761872,2763016,2762104,2763696,2763928,2760944,2760252,2760016,2761189,2762784],"length":1,"stats":{"Line":4},"fn_name":"encode"},{"line":58,"address":[2760978,2760050,2762818,2761906,2763730],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[2762828,2760065,2760996,2761921,2763740],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[2763809,2762897,2761122,2763861,2762041,2762949,2761065,2760133,2761989,2760188],"length":1,"stats":{"Line":8},"fn_name":null},{"line":61,"address":[2761168,2762995,2762083,2763907,2760231],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[2401264,2401269],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":84,"address":[2765644,2764439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[2765899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2767337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[2768775],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","util","inline_str.rs"],"content":"use std::fmt;\n\nuse super::Inlinable;\n\n#[repr(C)]\n#[repr(packed(1))]\npub struct InlineStr<T = u16> {\n    len: T,\n    data: [u8; 0],\n}\n// #[repr(C)]\n// #[repr(packed(1))]\n// struct InlineStr<T: AsUsize> {\n//     len: T,\n//     data: [u8; 0],\n// }\n\n// pub trait AsUsize: Copy {\n//     fn as_usize(&self) -> usize;\n// }\n\n// impl AsUsize for u8 {\n//     fn as_usize(&self) -> usize {\n//         *self as _\n//     }\n// }\n\n// impl AsUsize for u16 {\n//     fn as_usize(&self) -> usize {\n//         *self as _\n//     }\n// }\n\n// impl AsUsize for u32 {\n//     fn as_usize(&self) -> usize {\n//         *self as _\n//     }\n// }\n\n// impl AsUsize for u64 {\n//     fn as_usize(&self) -> usize {\n//         *self as _\n//     }\n// }\n// impl AsUsize for usize {\n//     fn as_usize(&self) -> usize {\n//         *self as _\n//     }\n// }\n\n// impl<T: AsUsize> InlineStr<T> {\n//     #[inline]\n//     pub fn from_ptr<'a>(ptr: *const u8) -> &'a Self {\n//         unsafe { std::mem::transmute::<*const u8, &Self>(ptr) }\n//     }\n//     #[inline]\n//     #[rustversion::attr(nightly, const)]\n//     pub fn as_bytes(&self) -> &[u8] {\n//         unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len()) }\n//     }\n//     #[inline]\n//     #[rustversion::attr(nightly, const)]\n//     pub fn as_str(&self) -> &str {\n//         unsafe { std::str::from_utf8_unchecked(self.as_bytes()) }\n//     }\n\n//     #[inline]\n//     #[allow(unaligned_references)]\n//     pub fn len(&self) -> usize {\n//         self.len.as_usize()\n//     }\n// }\n\nmacro_rules! _impl_inline_str {\n    ($($ty:ty) *) => {\n        $(\n\n            impl fmt::Debug for InlineStr<$ty> {\n                #[inline]\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    f.debug_struct(\"InlineStr\")\n                        .field(\"len\", &self.len())\n                        .field(\"data\", &self.as_str())\n                        .finish()\n                }\n            }\n\n            impl fmt::Display for InlineStr<$ty> {\n                #[inline]\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    f.write_str(self.as_str())\n                }\n            }\n\n            impl AsRef<str> for InlineStr<$ty> {\n                #[inline]\n                fn as_ref(&self) -> &str {\n                    self.as_str()\n                }\n            }\n\n            impl Inlinable for InlineStr<$ty> {\n                #[inline]\n                fn write_inlined<W: std::io::Write>(&self, mut wtr: W) -> std::io::Result<usize> {\n                    let l = wtr.write(&self.len.to_le_bytes())?;\n                    Ok(l + wtr.write(self.as_bytes())?)\n                }\n\n                #[inline]\n                fn read_inlined<R: std::io::Read>(_: R) -> std::io::Result<Self> {\n                    Err(std::io::Error::new(std::io::ErrorKind::Other, \"can't read into a inlined string\"))\n                }\n            }\n\n            impl InlineStr<$ty> {\n                #[inline]\n                pub fn from_ptr<'a>(ptr: *const u8) -> &'a Self {\n                    unsafe { std::mem::transmute::<*const u8, &InlineStr<$ty>>(ptr) }\n                }\n                #[inline]\n                #[rustversion::attr(nightly, const)]\n                pub fn as_bytes(&self) -> &[u8] {\n                    unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len()) }\n                }\n                #[inline]\n                #[rustversion::attr(nightly, const)]\n                pub fn as_str(&self) -> &str {\n                    unsafe { std::str::from_utf8_unchecked(self.as_bytes()) }\n                }\n\n                #[inline]\n                pub const fn len(&self) -> usize {\n                    self.len as _\n                }\n            }\n        )*\n    };\n}\n_impl_inline_str!(u8 u16 u32 u64 usize);\n\nmacro_rules! _impl_test_inline_str {\n    ($ty:ty, $bytes:literal, $print:literal) => {{\n        let bytes = $bytes;\n        let inline = InlineStr::<$ty>::from_ptr(bytes.as_ptr());\n        dbg!(inline);\n        assert_eq!(inline.len(), 4);\n        assert_eq!(inline.as_ref(), \"abcd\");\n        assert_eq!(format!(\"{}\", inline), \"abcd\");\n        assert_eq!(inline.inlined(), bytes);\n        assert_eq!(inline.printable_inlined(), $print);\n    }};\n}\n\n#[test]\nfn test_inline_str() {\n    _impl_test_inline_str!(u8, b\"\\x04abcd\", \"\\\\x04abcd\");\n    _impl_test_inline_str!(u16, b\"\\x04\\x00abcd\", \"\\\\x04\\\\x00abcd\");\n    _impl_test_inline_str!(u32, b\"\\x04\\x00\\x00\\x00abcd\", \"\\\\x04\\\\x00\\\\x00\\\\x00abcd\");\n    _impl_test_inline_str!(\n        u64,\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcd\",\n        \"\\\\x04\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00abcd\"\n    );\n}\n","traces":[{"line":80,"address":[2445952,2446320,2445216,2445584,2444848],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":81,"address":[2446447,2445971,2445343,2444975,2446079,2444910,2445278,2445646,2446339,2445603,2446382,2445235,2444867,2446014,2445711],"length":1,"stats":{"Line":12},"fn_name":null},{"line":82,"address":[2445631,2445999,2446367,2445263,2444895],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[2444950,2445318,2446054,2446422,2445686],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[2446144,2445040,2445408,2446512,2445776],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":91,"address":[2445059,2445427,2445795,2446163,2446531],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[2445120,2445488,2445856,2446224,2446592],"length":1,"stats":{"Line":4},"fn_name":"as_ref"},{"line":98,"address":[2445497,2446601,2445129,2445865,2446233],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[2186148,2185599,2185072,2186176,2187812,2185616,2187280,2186702,2186720,2187252],"length":1,"stats":{"Line":4},"fn_name":"write_inlined<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":105,"address":[2187315,2185651,2186944,2185291,2185698,2186211,2185152,2185107,2187504,2186255,2187362,2186394,2186802,2185840,2186755],"length":1,"stats":{"Line":8},"fn_name":null},{"line":106,"address":[2185915,2187220,2185554,2187019,2185269,2187579,2186670,2186372,2186657,2186469,2186922,2187780,2185366,2187767,2185818,2187207,2186103,2185567,2186116,2187482],"length":1,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[2445904,2445536,2445168,2446272,2446640],"length":1,"stats":{"Line":4},"fn_name":"from_ptr"},{"line":118,"address":[2445177,2445545,2445913,2446281,2446649],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[2447008,2447168,2446848,2447328,2446688],"length":1,"stats":{"Line":4},"fn_name":"as_bytes"},{"line":123,"address":[2446702,2447022,2447182,2446862,2447342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[2447264,2446944,2447104,2447424,2446784],"length":1,"stats":{"Line":4},"fn_name":"as_str"},{"line":128,"address":[2447273,2446953,2447433,2446793,2447113],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[2446672,2445200,2445568,2445936,2446304],"length":1,"stats":{"Line":4},"fn_name":"len"},{"line":133,"address":[2445573,2445941,2446309,2445205,2446677],"length":1,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[2187840,2187845],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":156,"address":[2447501,2448829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[2449330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[2451137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[2452959],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","util","mod.rs"],"content":"mod inline_bytes;\nmod inline_str;\n\nuse std::{\n    io::{Read, Write},\n    mem::size_of,\n};\n\npub use inline_bytes::InlineBytes;\npub use inline_str::InlineStr;\n\npub trait InlinableWrite: Write {\n    #[inline]\n    /// Write `usize` length as little endian `N` bytes.\n    fn write_len_with_width<const N: usize>(&mut self, len: usize) -> std::io::Result<usize> {\n        self.write(&len.to_le_bytes()[0..N])?;\n        Ok(N)\n    }\n\n    #[inline]\n    /// Write a [u8] value to writer.\n    fn write_u8(&mut self, value: u8) -> std::io::Result<usize> {\n        self.write(&[value])?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u16] value to writer.\n    fn write_u16(&mut self, value: u16) -> std::io::Result<usize> {\n        self.write(&value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u32] value to writer.\n    fn write_u32(&mut self, value: u32) -> std::io::Result<usize> {\n        self.write(&value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u64] value to writer.\n    fn write_u64(&mut self, value: u64) -> std::io::Result<usize> {\n        self.write(&value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u128] value to writer.\n    fn write_u128(&mut self, value: u128) -> std::io::Result<usize> {\n        self.write(&value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write inlined bytes to writer with specific length width `N`.\n    ///\n    /// The inlined bytes are constructed as:\n    ///\n    /// ```text\n    /// +--------------+-----------------+\n    /// | len: N bytes | data: len bytes |\n    /// +--------------+-----------------+\n    /// ```\n    ///\n    ///  ## Safety\n    ///\n    ///  Write inlined bytes may not be safe if the input bytes length overflows to the width.\n    ///  For example, write `256` bytes with length width `1` is not safe.\n    fn write_inlined_bytes<const N: usize>(&mut self, bytes: &[u8]) -> std::io::Result<usize> {\n        let l = self.write(&bytes.len().to_le_bytes()[0..N])?;\n        Ok(l + self.write(bytes)?)\n    }\n\n    #[inline]\n    /// Write inlined string with specific length width `N`.\n    fn write_inlined_str<const N: usize>(&mut self, s: &str) -> std::io::Result<usize> {\n        self.write_inlined_bytes::<N>(s.as_bytes())\n    }\n\n    #[inline]\n    /// Write an inlinable object.\n    fn write_inlinable<T: Inlinable>(&mut self, value: &T) -> std::io::Result<usize> {\n        value.write_inlined(self)\n    }\n}\n\nimpl<T> InlinableWrite for T where T: Write {}\n\nmacro_rules! _impl_read_exact {\n    ($ty: ty, $N: literal) => {\n        paste::paste! {\n            fn [<read_ $ty>](&mut self) -> std::io::Result<$ty> {\n                let mut bytes = [0; $N];\n                self.read_exact(&mut bytes)?;\n                Ok($ty::from_le_bytes(bytes))\n            }\n        }\n    };\n}\npub trait InlinableRead: Read {\n    #[inline]\n    /// Read `N` bytes as `usize`.\n    ///\n    /// Only 1/2/4/8 is valid as `N`.\n    fn read_len_with_width<const N: usize>(&mut self) -> std::io::Result<usize> {\n        let mut bytes: [u8; N] = [0; N];\n        self.read_exact(&mut bytes)?;\n        let len = match N {\n            1 => bytes[0] as usize,\n            2 => unsafe { *std::mem::transmute::<*const u8, *const u16>(bytes.as_ptr()) as usize },\n            4 => unsafe { *std::mem::transmute::<*const u8, *const u32>(bytes.as_ptr()) as usize },\n            8 => unsafe { *std::mem::transmute::<*const u8, *const u64>(bytes.as_ptr()) as usize },\n            _ => unreachable!(),\n        };\n        Ok(len)\n    }\n\n    fn read_f32(&mut self) -> std::io::Result<f32> {\n        let mut bytes = [0; 4];\n        self.read_exact(&mut bytes)?;\n        Ok(f32::from_le_bytes(bytes))\n    }\n\n    fn read_f64(&mut self) -> std::io::Result<f64> {\n        let mut bytes = [0; 8];\n        self.read_exact(&mut bytes)?;\n        Ok(f64::from_le_bytes(bytes))\n    }\n\n    fn read_u8(&mut self) -> std::io::Result<u8> {\n        let mut bytes = [0; 1];\n        self.read_exact(&mut bytes)?;\n        Ok(u8::from_le_bytes(bytes))\n    }\n    fn read_u16(&mut self) -> std::io::Result<u16> {\n        let mut bytes = [0; 2];\n        self.read_exact(&mut bytes)?;\n        Ok(u16::from_le_bytes(bytes))\n    }\n\n    fn read_u32(&mut self) -> std::io::Result<u32> {\n        let mut bytes = [0; 4];\n        self.read_exact(&mut bytes)?;\n        Ok(u32::from_le_bytes(bytes))\n    }\n\n    fn read_u64(&mut self) -> std::io::Result<u64> {\n        let mut bytes = [0; 8];\n        self.read_exact(&mut bytes)?;\n        Ok(u64::from_le_bytes(bytes))\n    }\n\n    fn read_u128(&mut self) -> std::io::Result<u128> {\n        let mut bytes = [0; 16];\n        self.read_exact(&mut bytes)?;\n        Ok(u128::from_le_bytes(bytes))\n    }\n\n    #[inline]\n    /// Read inlined bytes with specific length width `N`.\n    ///\n    /// The inlined bytes are constructed as:\n    ///\n    /// ```text\n    /// +--------------+-----------------+\n    /// | len: N bytes | data: len bytes |\n    /// +--------------+-----------------+\n    /// ```\n    ///\n    fn read_inlined_bytes<const N: usize>(&mut self) -> std::io::Result<Vec<u8>> {\n        let len = self.read_len_with_width::<N>()?;\n        let mut buf = Vec::with_capacity(len);\n        unsafe { buf.set_len(len) };\n        self.read_exact(&mut buf)?;\n        Ok(buf)\n    }\n\n    #[inline]\n    /// Read inlined string with specific length width `N`.\n    ///\n    /// The inlined string are constructed as:\n    ///\n    /// ```text\n    /// +--------------+-----------------+\n    /// | len: N bytes | data: len bytes |\n    /// +--------------+-----------------+\n    /// ```\n    ///\n    fn read_inlined_str<const N: usize>(&mut self) -> std::io::Result<String> {\n        self.read_inlined_bytes::<N>().and_then(|vec| {\n            String::from_utf8(vec)\n                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))\n        })\n    }\n\n    #[inline]\n    /// Read some bytes into inlinable object.\n    fn read_inlinable<T: Inlinable>(&mut self) -> std::io::Result<T> {\n        T::read_inlined(self)\n    }\n}\n\nimpl<T> InlinableRead for T where T: Read {}\n\n/// If one struct could be serialized/flattened to bytes array, we call it **inlinable**.\npub trait Inlinable: Sized {\n    /// Read inlined bytes into object.\n    fn read_inlined<R: Read>(reader: R) -> std::io::Result<Self>;\n\n    /// Write inlined bytes to a writer.\n    fn write_inlined<W: Write>(&self, wtr: W) -> std::io::Result<usize>;\n\n    #[inline]\n    /// Get inlined bytes as vector.\n    fn inlined(&self) -> Vec<u8> {\n        let mut buf = Vec::new();\n        self.write_inlined(&mut buf)\n            .expect(\"write to vec should always be success\");\n        buf\n    }\n\n    #[inline]\n    /// Get inlined bytes as printable string, all the bytes will displayed with escaped ascii code.\n    fn printable_inlined(&self) -> String {\n        self.inlined().escape_ascii().to_string()\n    }\n}\n\nimpl Inlinable for u8 {\n    #[inline]\n    fn write_inlined<W: Write>(&self, mut wtr: W) -> std::io::Result<usize> {\n        wtr.write_u8(*self)\n    }\n\n    #[inline]\n    fn read_inlined<R: Read>(mut reader: R) -> std::io::Result<Self> {\n        reader.read_u8()\n    }\n}\n\nimpl Inlinable for u16 {\n    #[inline]\n    fn write_inlined<W: Write>(&self, mut wtr: W) -> std::io::Result<usize> {\n        wtr.write_u16(*self)\n    }\n\n    #[inline]\n    fn read_inlined<R: Read>(mut reader: R) -> std::io::Result<Self> {\n        reader.read_u16()\n    }\n}\n\nimpl Inlinable for u32 {\n    #[inline]\n    fn write_inlined<W: Write>(&self, mut wtr: W) -> std::io::Result<usize> {\n        wtr.write_u32(*self)\n    }\n\n    #[inline]\n    fn read_inlined<R: Read>(mut reader: R) -> std::io::Result<Self> {\n        reader.read_u32()\n    }\n}\n\nimpl Inlinable for u64 {\n    #[inline]\n    fn write_inlined<W: Write>(&self, mut wtr: W) -> std::io::Result<usize> {\n        wtr.write_u64(*self)\n    }\n\n    #[inline]\n    fn read_inlined<R: Read>(mut reader: R) -> std::io::Result<Self> {\n        reader.read_u64()\n    }\n}\n\n#[test]\nfn inlined_bytes() -> std::io::Result<()> {\n    let s = \"abcd\";\n    let mut vec: Vec<u8> = Vec::new();\n    let bytes = vec.write_inlined_bytes::<1>(s.as_bytes())?;\n    assert_eq!(bytes, 5);\n    assert_eq!(&vec, b\"\\x04abcd\");\n\n    let r = vec.as_slice().read_inlined_str::<1>()?;\n    assert_eq!(r, \"abcd\");\n    Ok(())\n}\n","traces":[{"line":15,"address":[1910384,1910656],"length":1,"stats":{"Line":1},"fn_name":"write_len_with_width<&mut alloc::vec::Vec<u8, alloc::alloc::Global>, 4>"},{"line":16,"address":[1910881,1910429,1910609,1910701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1910587,1910859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1910928,1911088],"length":1,"stats":{"Line":1},"fn_name":"write_u8<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":23,"address":[1911044,1911112,1911204,1910952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1911023,1911183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1911248],"length":1,"stats":{"Line":0},"fn_name":"write_u16<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":30,"address":[1911280,1911398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[1911376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1911440,1911632],"length":1,"stats":{"Line":0},"fn_name":"write_u32<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":37,"address":[1911589,1911670,1911478,1911781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1911759,1911567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1911824],"length":1,"stats":{"Line":0},"fn_name":"write_u64<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":44,"address":[1911981,1911866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1911959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1912496,1912976,1913456,1912016],"length":1,"stats":{"Line":3},"fn_name":"write_inlined_bytes<&mut alloc::vec::Vec<u8, alloc::alloc::Global>, 2>"},{"line":71,"address":[1913722,1912282,1912762,1912080,1912560,1913242,1913040,1913520],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[1912462,1912741,1913701,1913886,1913902,1912803,1912446,1913422,1913221,1913763,1912261,1912942,1913283,1912323,1913406,1912926],"length":1,"stats":{"Line":9},"fn_name":null},{"line":77,"address":[1913936,1914048],"length":1,"stats":{"Line":0},"fn_name":"write_inlined_str<&mut &mut alloc::vec::Vec<u8, alloc::alloc::Global>, 2>"},{"line":78,"address":[1914030,1914142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1914224,1914160],"length":1,"stats":{"Line":0},"fn_name":"write_inlinable<&mut alloc::vec::Vec<u8, alloc::alloc::Global>, taos_query::common::field::Field>"},{"line":84,"address":[1914259,1914195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[2805024,2803632,2804560,2804096],"length":1,"stats":{"Line":3},"fn_name":"read_len_with_width<&mut &[u8], 2>"},{"line":107,"address":[2803659,2805051,2804123,2804587],"length":1,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[2803681,2803781,2804242,2805073,2804609,2805173,2804145,2804709],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2805143,2803751,2804679,2804212],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[2805465,2804313,2804534,2804780,2804073,2805244,2803852,2805001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[2804785,2804965,2804037,2805429,2805249,2804318,2804498,2803857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[2804811,2804344,2804925,2803883,2805275,2804458,2803997,2805389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[2803906,2804367,2805298,2804834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2805363,2803971,2804432,2804899],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2805680,2805488],"length":1,"stats":{"Line":1},"fn_name":"read_u8<&[u8]>"},{"line":132,"address":[2805704,2805512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[2805621,2805813,2805534,2805726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[2805592,2805856,2805784,2805664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[2805872],"length":1,"stats":{"Line":0},"fn_name":"read_u16<&[u8]>"},{"line":137,"address":[2805896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2805918,2806008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2806052,2805976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2806256,2806064],"length":1,"stats":{"Line":1},"fn_name":"read_u32<&[u8]>"},{"line":143,"address":[2806280,2806088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[2806388,2806302,2806196,2806110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[2806239,2806168,2806360,2806431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[2806448,2806976,2806942,2808526,2807998,2807470,2808032,2807504],"length":1,"stats":{"Line":3},"fn_name":"read_inlined_bytes<&mut &[u8], 2>"},{"line":172,"address":[2807092,2807534,2807620,2808148,2808062,2807006,2806478,2806564],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[2807602,2808130,2807074,2806546],"length":1,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[2807666,2806610,2808194,2807138],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[2806868,2807924,2808452,2807396,2808251,2807195,2806667,2807723],"length":1,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[2806776,2807304,2808360,2807832],"length":1,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[2808624,2808560,2808688],"length":1,"stats":{"Line":2},"fn_name":"read_inlined_str<&[u8], 1>"},{"line":191,"address":[2808912,2808706,2808578,2808752,2808832,2808642],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}<&[u8], 1>"},{"line":192,"address":[2808766,2808846,2808926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[2809120,2808992,2809127,2808999,2809063,2809056],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<&[u8], 1>"},{"line":199,"address":[2809184],"length":1,"stats":{"Line":0},"fn_name":"read_inlinable<&[u8], taos_query::common::field::Field>"},{"line":200,"address":[2809201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[2077840,2077972],"length":1,"stats":{"Line":6},"fn_name":"inlined<taos_query::common::raw::inner::RawBlock>"},{"line":217,"address":[2077867],"length":1,"stats":{"Line":6},"fn_name":null},{"line":218,"address":[2077927,2077888],"length":1,"stats":{"Line":12},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[2078000,2078147],"length":1,"stats":{"Line":5},"fn_name":"printable_inlined<taos_query::common::raw::inner::RawBlock>"},{"line":226,"address":[2078019,2078097],"length":1,"stats":{"Line":10},"fn_name":null},{"line":232,"address":[2810624,2810680],"length":1,"stats":{"Line":0},"fn_name":"write_inlined<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":233,"address":[2810645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2810760,2810704],"length":1,"stats":{"Line":0},"fn_name":"write_inlined<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":245,"address":[2810725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2810784,2810839],"length":1,"stats":{"Line":0},"fn_name":"write_inlined<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":257,"address":[2810805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2810864,2810920],"length":1,"stats":{"Line":0},"fn_name":"write_inlined<&mut alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":269,"address":[2810885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[2810944,2810953],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":280,"address":[2950151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[2950178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[2950497,2950328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[2950405,2950696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[2950750,2950594,2950788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[2950761,2950842,2951077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[2950998,2951217,2951261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[2951223],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":48,"coverable":105},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","benches","is_null.rs"],"content":"#![feature(test)]\n\nextern crate test;\nuse bitvec::prelude::*;\n\nunsafe fn is_null_bit_slice(ptr: *const u8, row: usize) -> bool {\n    let len = 1;\n    let slice = std::slice::from_raw_parts(ptr, len);\n    let is_nulls: &BitSlice<u8, Msb0> = &BitSlice::from_slice_unchecked(slice);\n    is_nulls[row]\n}\n\nunsafe fn is_null(ptr: *const u8, row: usize) -> bool {\n    macro_rules! is_null {\n        ($bm:expr, $row:expr) => {\n            *$bm.offset($row as isize >> 3) >> (7 - ($row & 7)) & 0x1 == 1\n        };\n    }\n    is_null!(ptr, row)\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n\n    #[test]\n    fn test() {\n        let ptr = [0b11110000; 1].as_ptr();\n        for i in 0..8 {\n            assert_eq!(\n                unsafe { is_null_bit_slice(ptr, i) },\n                unsafe { is_null(ptr, i) },\n                \" in row: {}\",\n                i\n            );\n        }\n    }\n\n    #[bench]\n    fn bench_bit_slice(b: &mut Bencher) {\n        let slice = [0b1010101; 6];\n        b.iter(|| {\n            for i in 0..8 {\n                let _ = unsafe { is_null_bit_slice(slice.as_ptr(), i) };\n            }\n        })\n    }\n\n    #[bench]\n    fn bench_macro(b: &mut Bencher) {\n        let slice = [0b1010101; 6];\n        b.iter(|| {\n            for i in 0..8 {\n                let _ = unsafe { is_null(slice.as_ptr(), i) };\n            }\n        })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","build.rs"],"content":"use std::env;\nuse std::ffi::OsString;\nuse std::fmt::Display;\n\nfn get_env(name: &str) -> Option<OsString> {\n    let var = env::var_os(name);\n    println!(\"cargo:rerun-if-env-changed={}\", name);\n\n    match var {\n        Some(ref v) => println!(\"{} = {}\", name, v.to_string_lossy()),\n        None => println!(\"{} unset\", name),\n    }\n\n    var\n}\n\nfn version2features<V: Into<Version>>(version: V) -> Vec<&'static str> {\n    let version = version.into();\n    let mut feats = Vec::new();\n    if version.mainline == 3 {\n        feats.push(\"v3\");\n        feats.push(\"tmq\");\n        feats.push(\"fetch_raw_block\");\n        feats.push(\"fetch_block_s\");\n    } else if version.mainline == 2 {\n        feats.push(\"v2\");\n        if version >= Version::new(2, 4, 0, 4) {\n            feats.push(\"result_block\");\n        }\n        if version >= Version::new(2, 4, 0, 0) {\n            feats.push(\"json_tag\");\n            feats.push(\"set_config\");\n            feats.push(\"is_update_query\");\n            feats.push(\"reset_db\");\n            feats.push(\"sml\");\n            feats.push(\"parse_time\");\n        }\n    } else {\n        panic!(\"unsupported TDengine client version {version}\")\n    }\n    feats\n}\nfn taos_version() -> String {\n    let lib_env = \"TAOS_LIBRARY_PATH\";\n    if let Some(path) = get_env(lib_env) {\n        println!(\"cargo:rustc-link-search={}\", path.to_string_lossy());\n    }\n    if cfg!(target_os = \"windows\") {\n        println!(\"cargo:rustc-link-search=C:\\\\TDengine\\\\driver\");\n    }\n    let lib_name = if cfg!(target_os = \"windows\") {\n        \"taos.dll\"\n    } else if cfg!(target_os = \"linux\") {\n        \"libtaos.so\"\n    } else if cfg!(target_os = \"darwin\") {\n        \"libtaos.dylib\"\n    } else {\n        unreachable!(\"the current os is not supported\");\n    };\n    let lib = unsafe { libloading::Library::new(lib_name).unwrap() };\n    let version = unsafe {\n        let version: libloading::Symbol<unsafe extern \"C\" fn() -> *const std::os::raw::c_char> =\n            lib.get(b\"taos_get_client_info\\0\").unwrap();\n        std::ffi::CStr::from_ptr(version()).to_string_lossy()\n    };\n    println!(\"cargo:rustc-cfg=taos_version=\\\"v{}\\\"\", version);\n    let parsed_version = Version::parse(&version).expect(\"invalid version of taos\");\n    for feat in version2features(parsed_version) {\n        println!(\"cargo:rustc-cfg=taos_{feat}\");\n    }\n    return version.to_string();\n}\n\n#[derive(Debug, PartialEq, PartialOrd)]\nstruct Version {\n    mainline: u8,\n    major: u8,\n    minor: u8,\n    patch: u8,\n}\n\nimpl Display for Version {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let Version {\n            mainline,\n            major,\n            minor,\n            patch,\n        } = self;\n        f.write_fmt(format_args!(\"{mainline}.{major}.{minor}.{patch}\"))\n    }\n}\n\nimpl Version {\n    fn new(mainline: u8, major: u8, minor: u8, patch: u8) -> Self {\n        Self {\n            mainline,\n            major,\n            minor,\n            patch,\n        }\n    }\n    fn parse(version: &str) -> Result<Self, Box<dyn std::error::Error>> {\n        let version_items: Vec<_> = version.split('.').collect();\n        let items = version_items.len();\n        if items == 0 || items > 4 {\n            Err(\"parse version error: {version}\")?\n        }\n\n        let mainline = version_items[0].parse()?;\n        let major = version_items\n            .get(1)\n            .and_then(|s| s.parse().ok())\n            .unwrap_or_default();\n        let minor = version_items\n            .get(2)\n            .and_then(|s| s.parse().ok())\n            .unwrap_or_default();\n        let patch = version_items\n            .get(3)\n            .and_then(|s| s.parse().ok())\n            .unwrap_or_default();\n\n        Ok(Self::new(mainline, major, minor, patch))\n    }\n}\n\nfn main() {\n    taos_version();\n    println!(\"cargo:rustc-link-lib=taos\");\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","ffi.rs"],"content":"use std::os::raw::*;\nuse taos_macros::c_cfg;\n\nuse crate::types::*;\n\npub type TAOS = c_void;\npub type TAOS_STMT = c_void;\npub type TAOS_RES = c_void;\npub type TAOS_STREAM = c_void;\npub type TAOS_SUB = c_void;\npub type TAOS_ROW = *mut *mut c_void;\n\npub type taos_subscribe_cb =\n    unsafe extern \"C\" fn(sub: *mut TAOS_SUB, res: *mut TAOS_RES, param: *mut c_void, code: c_int);\n\npub type taos_stream_cb =\n    unsafe extern \"C\" fn(param: *mut c_void, res: *mut TAOS_RES, row: TAOS_ROW);\n\npub type taos_stream_close_cb = unsafe extern \"C\" fn(param: *mut c_void);\n\nextern \"C\" {\n    pub fn taos_cleanup();\n\n    pub fn taos_options(option: TSDB_OPTION, arg: *const c_void, ...) -> c_int;\n\n    pub fn taos_get_client_info() -> *const c_char;\n\n    pub fn taos_data_type(type_: c_int) -> *const c_char;\n}\n\n#[c_cfg(taos_parse_time)]\nextern \"C\" {\n    pub fn taos_parse_time(\n        time_str: *const c_char,\n        time: *mut i64,\n        len: i32,\n        time_precision: Precision,\n        daylight: i8, // if in daylight saving time (DST) { 1 } else { 0 }\n    ) -> i32;\n}\n\nextern \"C\" {\n    pub fn taos_connect(\n        ip: *const c_char,\n        user: *const c_char,\n        pass: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -> *mut TAOS;\n\n    pub fn taos_connect_auth(\n        ip: *const c_char,\n        user: *const c_char,\n        auth: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -> *mut TAOS;\n\n    pub fn taos_close(taos: *mut TAOS);\n\n}\n\npub type taos_async_fetch_cb =\n    unsafe extern \"C\" fn(param: *mut c_void, res: *mut c_void, rows: c_int);\n\npub type taos_async_query_cb =\n    unsafe extern \"C\" fn(param: *mut c_void, res: *mut c_void, code: c_int);\n\nextern \"C\" {\n    pub fn taos_fetch_rows_a(res: *mut TAOS_RES, fp: taos_async_fetch_cb, param: *mut c_void);\n\n    pub fn taos_query_a(\n        taos: *mut TAOS,\n        sql: *const c_char,\n        fp: taos_async_query_cb,\n        param: *mut c_void,\n    );\n}\n\nextern \"C\" {\n    pub fn taos_load_table_info(taos: *mut TAOS, tableNameList: *const c_char) -> c_int;\n\n    pub fn taos_stmt_init(taos: *mut TAOS) -> *mut TAOS_STMT;\n\n    pub fn taos_stmt_prepare(stmt: *mut TAOS_STMT, sql: *const c_char, length: c_ulong) -> c_int;\n\n    pub fn taos_stmt_set_tbname_tags(\n        stmt: *mut TAOS_STMT,\n        name: *const c_char,\n        tags: *mut TaosBind,\n    ) -> c_int;\n\n    pub fn taos_stmt_set_tbname(stmt: *mut TAOS_STMT, name: *const c_char) -> c_int;\n\n    pub fn taos_stmt_set_sub_tbname(stmt: *mut TAOS_STMT, name: *const c_char) -> c_int;\n\n    pub fn taos_stmt_is_insert(stmt: *mut TAOS_STMT, insert: *mut c_int) -> c_int;\n\n    pub fn taos_stmt_num_params(stmt: *mut TAOS_STMT, nums: *mut c_int) -> c_int;\n\n    pub fn taos_stmt_get_param(\n        stmt: *mut TAOS_STMT,\n        idx: c_int,\n        type_: *mut c_int,\n        bytes: *mut c_int,\n    ) -> c_int;\n\n    pub fn taos_stmt_bind_param(stmt: *mut TAOS_STMT, bind: *const TaosBind) -> c_int;\n\n    pub fn taos_stmt_bind_param_batch(stmt: *mut TAOS_STMT, bind: *const TaosMultiBind) -> c_int;\n\n    pub fn taos_stmt_bind_single_param_batch(\n        stmt: *mut TAOS_STMT,\n        bind: *const TaosMultiBind,\n        colIdx: c_int,\n    ) -> c_int;\n\n    pub fn taos_stmt_add_batch(stmt: *mut TAOS_STMT) -> c_int;\n\n    pub fn taos_stmt_execute(stmt: *mut TAOS_STMT) -> c_int;\n\n    pub fn taos_stmt_affected_rows(stmt: *mut TAOS_STMT) -> c_int;\n\n    pub fn taos_stmt_use_result(stmt: *mut TAOS_STMT) -> *mut TAOS_RES;\n\n    pub fn taos_stmt_close(stmt: *mut TAOS_STMT) -> c_int;\n\n    pub fn taos_stmt_errstr(stmt: *mut TAOS_STMT) -> *const c_char;\n}\n\nextern \"C\" {\n    pub fn taos_query(taos: *mut TAOS, sql: *const c_char) -> *mut TAOS_RES;\n\n    pub fn taos_fetch_row(res: *mut TAOS_RES) -> TAOS_ROW;\n\n    pub fn taos_result_precision(res: *mut TAOS_RES) -> c_int;\n\n    pub fn taos_free_result(res: *mut TAOS_RES);\n\n    pub fn taos_field_count(res: *mut TAOS_RES) -> c_int;\n\n    pub fn taos_num_fields(res: *mut TAOS_RES) -> c_int;\n\n    pub fn taos_affected_rows(res: *mut TAOS_RES) -> c_int;\n\n    pub fn taos_fetch_fields(res: *mut TAOS_RES) -> *mut TAOS_FIELD;\n\n    pub fn taos_select_db(taos: *mut TAOS, db: *const c_char) -> c_int;\n\n    pub fn taos_print_row(\n        str_: *mut c_char,\n        row: TAOS_ROW,\n        fields: *mut TAOS_FIELD,\n        num_fields: c_int,\n    ) -> c_int;\n\n    pub fn taos_stop_query(res: *mut TAOS_RES);\n\n    pub fn taos_is_null(res: *mut TAOS_RES, row: i32, col: i32) -> bool;\n\n    pub fn taos_is_update_query(res: *mut TAOS_RES) -> bool;\n\n    pub fn taos_fetch_block(res: *mut TAOS_RES, rows: *mut TAOS_ROW) -> c_int;\n\n    pub fn taos_fetch_lengths(res: *mut TAOS_RES) -> *mut c_int;\n\n    pub fn taos_validate_sql(taos: *mut TAOS, sql: *const c_char) -> c_int;\n\n    pub fn taos_reset_current_db(taos: *mut TAOS);\n\n    pub fn taos_get_server_info(taos: *mut TAOS) -> *mut c_char;\n\n    pub fn taos_errstr(tres: *mut TAOS_RES) -> *mut c_char;\n\n    pub fn taos_errno(tres: *mut TAOS_RES) -> c_int;\n\n}\n\n#[c_cfg(taos_v3)]\nextern \"C\" {\n    pub fn taos_get_column_data_offset(res: *mut TAOS_RES, col: i32) -> *mut i32;\n\n    pub fn taos_fetch_raw_block(res: *mut TAOS_RES, num: *mut i32, data: *mut *mut c_void)\n        -> c_int;\n\n    pub fn taos_fetch_raw_block_a(res: *mut TAOS_RES, fp: taos_async_fetch_cb, param: *mut c_void);\n\n    pub fn taos_get_raw_block(taos: *mut TAOS_RES) -> *mut c_void;\n}\n\n#[c_cfg(taos_result_block)]\nextern \"C\" {\n    pub fn taos_result_block(res: *mut TAOS_RES) -> *mut TAOS_ROW;\n}\n\n#[cfg(taos_fetch_block_s)]\nextern \"C\" {\n    pub fn taos_fetch_block_s(\n        res: *mut TAOS_RES,\n        num_of_rows: *mut c_int,\n        rows: *mut TAOS_ROW,\n    ) -> c_int;\n}\n\n#[cfg(not(taos_fetch_block_s))]\n#[no_mangle]\npub unsafe extern \"C\" fn taos_fetch_block_s(\n    res: *mut TAOS_RES,\n    num_of_rows: *mut c_int,\n    rows: *mut TAOS_ROW,\n) -> c_int {\n    *num_of_rows = taos_fetch_block(res, rows);\n    return 0;\n}\n\nextern \"C\" {\n    pub fn taos_subscribe(\n        taos: *mut TAOS,\n        restart: c_int,\n        topic: *const c_char,\n        sql: *const c_char,\n        fp: Option<taos_subscribe_cb>,\n        param: *mut c_void,\n        interval: c_int,\n    ) -> *mut TAOS_SUB;\n\n    pub fn taos_consume(tsub: *mut TAOS_SUB) -> *mut TAOS_RES;\n\n    pub fn taos_unsubscribe(tsub: *mut TAOS_SUB, keep_progress: c_int);\n}\n\nextern \"C\" {\n    pub fn taos_open_stream(\n        taos: *mut TAOS,\n        sql: *const c_char,\n        fp: Option<taos_stream_cb>,\n        stime: i64,\n        param: *mut c_void,\n        callback: Option<taos_stream_close_cb>,\n    ) -> *mut TAOS_STREAM;\n\n    pub fn taos_close_stream(stream: *mut TAOS_STREAM);\n}\n","traces":[{"line":31,"address":[8095165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[8095136],"length":1,"stats":{"Line":0},"fn_name":"taos_parse_time"},{"line":191,"address":[8095241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8095232],"length":1,"stats":{"Line":0},"fn_name":"taos_result_block"}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","into_c_str.rs"],"content":"use std::borrow::Cow;\nuse std::ffi::{c_void, CStr, CString};\nuse std::os::raw::c_char;\n\n/// Helper trait to auto convert Rust strings to CStr.\npub trait IntoCStr<'a> {\n    fn into_c_str(self) -> Cow<'a, CStr>;\n}\n\nmacro_rules! _impl_for_raw {\n    ($t:ty) => {\n        impl<'a> IntoCStr<'a> for $t {\n            fn into_c_str(self) -> Cow<'a, CStr> {\n                Cow::from(self)\n            }\n        }\n    };\n}\n_impl_for_raw!(CString);\n_impl_for_raw!(&'a CStr);\n_impl_for_raw!(&'a CString);\n\nmacro_rules! _impl_for_ref {\n    ($t:ty) => {\n        impl<'a> IntoCStr<'a> for &'a $t {\n            fn into_c_str(self) -> Cow<'a, CStr> {\n                self.as_c_str().into_c_str()\n            }\n        }\n    };\n}\n_impl_for_ref!(&CString);\n_impl_for_ref!(&&CString);\n\nimpl<'a> IntoCStr<'a> for &&'a CStr {\n    fn into_c_str(self) -> Cow<'a, CStr> {\n        Cow::from(*self)\n    }\n}\n\nimpl<'a> IntoCStr<'a> for String {\n    fn into_c_str(self) -> Cow<'a, CStr> {\n        let v = self.into_bytes();\n        Cow::from(unsafe { CString::from_vec_unchecked(v) })\n    }\n}\n\nmacro_rules! _impl_for_str {\n    ($t:ty) => {\n        impl<'a> IntoCStr<'a> for &'a $t {\n            fn into_c_str(self) -> Cow<'a, CStr> {\n                self.to_owned().into_c_str()\n            }\n        }\n    };\n}\n\n_impl_for_str!(String);\n_impl_for_str!(str);\n_impl_for_str!(&str);\n\npub struct NullableCStr<'a>(Option<Cow<'a, CStr>>);\n\nimpl<'a> NullableCStr<'a> {\n    pub fn as_ptr(&self) -> *const c_char {\n        match self.0.as_ref() {\n            Some(c) => c.as_ptr(),\n            None => std::ptr::null(),\n        }\n    }\n}\n\npub trait IntoNullableCStr<'a> {\n    fn into_nullable_c_str(self) -> NullableCStr<'a>;\n}\n\nimpl<'a, T> IntoNullableCStr<'a> for T\nwhere\n    T: IntoCStr<'a>,\n{\n    fn into_nullable_c_str(self) -> NullableCStr<'a> {\n        NullableCStr(Some(self.into_c_str()))\n    }\n}\n\nimpl<'a, T> IntoNullableCStr<'a> for Option<T>\nwhere\n    T: IntoCStr<'a>,\n{\n    fn into_nullable_c_str(self) -> NullableCStr<'a> {\n        NullableCStr(self.map(IntoCStr::into_c_str))\n    }\n}\n\nimpl<'a, T> IntoNullableCStr<'a> for &'a Option<T>\nwhere\n    &'a T: IntoCStr<'a>,\n{\n    fn into_nullable_c_str(self) -> NullableCStr<'a> {\n        NullableCStr(self.as_ref().map(|c| c.into_c_str()))\n    }\n}\n\nimpl<'a> IntoNullableCStr<'a> for () {\n    fn into_nullable_c_str(self) -> NullableCStr<'a> {\n        NullableCStr(None)\n    }\n}\n\nimpl<'a, T> From<T> for NullableCStr<'a>\nwhere\n    T: IntoNullableCStr<'a>,\n{\n    fn from(rhs: T) -> NullableCStr<'a> {\n        rhs.into_nullable_c_str()\n    }\n}\n\nmacro_rules! _impl_for_ptr {\n    ($t:ty) => {\n        impl<'a> IntoNullableCStr<'a> for $t {\n            fn into_nullable_c_str(self) -> NullableCStr<'a> {\n                NullableCStr(if self.is_null() {\n                    None\n                } else {\n                    Some(Cow::from(unsafe { CStr::from_ptr(self as _) }))\n                })\n            }\n        }\n    };\n}\n\n_impl_for_ptr!(*const i8);\n_impl_for_ptr!(*mut i8);\n_impl_for_ptr!(*const u8);\n_impl_for_ptr!(*mut u8);\n_impl_for_ptr!(*mut c_void);\n\n#[cfg(test)]\nmod test_into_c_str {\n    use std::{\n        borrow::Borrow,\n        ffi::{CStr, CString},\n    };\n\n    use super::*;\n\n    fn from_c_str<'a>(_: impl IntoCStr<'a>) {}\n\n    #[test]\n    fn c_str_to_c_str() {\n        let s = CStr::from_bytes_with_nul(b\"abc\\0\").unwrap();\n        from_c_str(&s);\n        from_c_str(s);\n    }\n    #[test]\n    fn c_string_to_c_str() {\n        let s = CString::new(\"abc\").unwrap();\n        from_c_str(&s);\n        from_c_str(s);\n    }\n    #[test]\n    fn str_to_c_str() {\n        let s = \"abc\";\n        from_c_str(&s);\n        from_c_str(s);\n    }\n    #[test]\n    fn string_to_c_str() {\n        let s = String::from(\"abc\");\n        from_c_str(&s);\n        from_c_str(s.as_str());\n        from_c_str(s);\n    }\n\n    #[test]\n    fn option_string_to_c_str() {\n        let s = Some(String::from(\"abc\"));\n        let _ = s.borrow().into_nullable_c_str();\n        let _ = s.as_ref().into_nullable_c_str();\n        let _ = s.into_nullable_c_str();\n    }\n    #[test]\n    fn option_cstring_to_c_str() {\n        let s = Some(CString::new(\"abc\").unwrap());\n        let _ = s.borrow().into_nullable_c_str();\n        let _ = s.as_ref().into_nullable_c_str();\n        let _ = s.into_nullable_c_str();\n    }\n}\n","traces":[{"line":13,"address":[8062448],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":14,"address":[8128753,8128709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[8128768,8128848],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":27,"address":[8128786,8128866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[8062400],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":37,"address":[8062420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[8092928],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":43,"address":[8092942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[8092983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[8093072],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":52,"address":[8115872,8115799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[8115584],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":66,"address":[8115593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[8115662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[8115655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[3446912],"length":1,"stats":{"Line":0},"fn_name":"into_nullable_c_str<alloc::string::String>"},{"line":100,"address":[3446944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[8115728],"length":1,"stats":{"Line":0},"fn_name":"into_nullable_c_str"},{"line":106,"address":[8115735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[3454864],"length":1,"stats":{"Line":0},"fn_name":"from<&core::option::Option<alloc::string::String>>"},{"line":115,"address":[3454881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8115920,8116448,8116272,8116096],"length":1,"stats":{"Line":0},"fn_name":"into_nullable_c_str"},{"line":123,"address":[8116480,8116540,8116092,8116620,8116364,8116128,8116444,8116304,8115952,8116012,8116188,8116268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[8116521,8116345,8115993,8116169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[8116228,8115977,8116052,8116505,8116404,8116329,8116153,8116580],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","lib.rs"],"content":"#![feature(const_slice_from_raw_parts)]\n#![allow(non_camel_case_types)]\n#![allow(dead_code)]\n#![allow(unused_variables)]\n\nuse std::{ffi::CStr, marker::PhantomData, ops::Deref, os::raw::*, sync::Arc};\n\nuse into_c_str::IntoCStr;\nuse once_cell::sync::OnceCell;\nuse taos_error::{Code, Error};\nuse taos_query::common::{Field, Ty};\n\npub(crate) mod types;\npub use types::*;\npub mod ffi;\nuse ffi::*;\n\nmod set_config;\npub use set_config::*;\n\npub use ffi::taos_options;\n\nmod schemaless;\npub use schemaless::*;\n\nmod tmq;\npub use tmq::*;\n\nmacro_rules! err_or {\n    ($res:ident, $code:expr, $ret:expr) => {\n        unsafe {\n            let code: Code = { $code }.into();\n            if code.success() {\n                Ok($ret)\n            } else {\n                Err(Error::new(code, $res.err_as_str()))\n            }\n        }\n    };\n\n    ($res:ident, $code:expr) => {{\n        err_or!($res, $code, ())\n    }};\n    ($code:expr, $ret:expr) => {\n        unsafe {\n            let code: Code = { $code }.into();\n            if code.success() {\n                Ok($ret)\n            } else {\n                Err(Error::from_code(code))\n            }\n        }\n    };\n\n    ($code:expr) => {\n        err_or!($code, ())\n    };\n}\n\n#[derive(Debug)]\n#[repr(transparent)]\npub struct RawTaos(*mut TAOS);\n\nimpl Drop for RawTaos {\n    fn drop(&mut self) {\n        self.close()\n    }\n}\n\nimpl RawTaos {\n    /// Client version.\n    pub fn version() -> &'static CStr {\n        unsafe { CStr::from_ptr(taos_get_client_info()) }\n    }\n\n    #[inline]\n    pub fn connect(\n        host: *const c_char,\n        user: *const c_char,\n        pass: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -> Result<Self, Error> {\n        let ptr = unsafe { taos_connect(host, user, pass, db, port) };\n        let null = std::ptr::null_mut();\n        let code = unsafe { taos_errno(null) };\n        if code != 0 {\n            let err = unsafe { CStr::from_ptr(taos_errstr(null)) }\n                .to_string_lossy()\n                .to_string();\n            let err = Error::new(code, err);\n            log::trace!(\"error: {err}\");\n        }\n\n        if ptr.is_null() {\n            let null = std::ptr::null_mut();\n            let code = unsafe { taos_errno(null) };\n            let err = unsafe { CStr::from_ptr(taos_errstr(null)) }\n                .to_string_lossy()\n                .to_string();\n            Err(Error::new(code, err))\n        } else {\n            Ok(RawTaos(ptr))\n        }\n    }\n    #[inline]\n    pub fn connect_auth(\n        host: *const c_char,\n        user: *const c_char,\n        auth: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -> Result<Self, Error> {\n        let ptr = unsafe { taos_connect_auth(host, user, auth, db, port) };\n        if ptr.is_null() {\n            let null = std::ptr::null_mut();\n            let code = unsafe { taos_errno(null) };\n            let err = unsafe { CStr::from_ptr(taos_errstr(null)) }\n                .to_string_lossy()\n                .to_string();\n            Err(Error::new(code, err))\n        } else {\n            Ok(RawTaos(ptr))\n        }\n    }\n\n    #[inline]\n    pub fn as_ptr(&self) -> *mut TAOS {\n        self.0\n    }\n\n    #[inline]\n    pub fn query<'a, S: IntoCStr<'a>>(&self, sql: S) -> Result<DroppableRawRes, Error> {\n        RawRes::from_ptr(unsafe { taos_query(self.as_ptr(), sql.into_c_str().as_ptr()) })\n            .map(DroppableRawRes::new)\n    }\n\n    #[inline]\n    pub fn query_a(&self, sql: *const i8, fp: taos_async_query_cb, param: *mut c_void) {\n        unsafe { taos_query_a(self.as_ptr(), sql, fp, param) }\n    }\n\n    #[inline]\n    pub fn validate_sql(self, sql: *const c_char) -> Result<(), Error> {\n        let code: Code = unsafe { taos_validate_sql(self.as_ptr(), sql) }.into();\n        if code.success() {\n            return Ok(());\n        } else {\n            let err = unsafe { taos_errstr(std::ptr::null_mut()) };\n            let err = unsafe { std::str::from_utf8_unchecked(CStr::from_ptr(err).to_bytes()) };\n            return Err(Error::new(code, err));\n        }\n    }\n\n    #[inline]\n    pub fn reset_current_db(&self) {\n        unsafe { taos_reset_current_db(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn server_version(&self) -> &CStr {\n        unsafe { CStr::from_ptr(taos_get_server_info(self.as_ptr())) }\n    }\n\n    #[inline]\n    pub fn load_table_info(&self, list: *const c_char) -> Result<(), Error> {\n        err_or!(taos_load_table_info(self.as_ptr(), list))\n    }\n\n    #[inline]\n    pub fn close(&mut self) {\n        unsafe { taos_close(self.as_ptr()) }\n    }\n}\n\n#[derive(Debug)]\npub struct RawRes {\n    ptr: *mut TAOS_RES,\n    fields: OnceCell<Vec<Field>>,\n}\n\nunsafe impl Send for RawRes {}\nunsafe impl Sync for RawRes {}\n\n#[derive(Debug)]\npub struct DroppableRawRes {\n    raw: Arc<RawRes>,\n}\n\nimpl Deref for DroppableRawRes {\n    type Target = RawRes;\n\n    fn deref(&self) -> &Self::Target {\n        &self.raw\n    }\n}\n\nimpl DroppableRawRes {\n    pub fn new(raw: RawRes) -> Self {\n        Self { raw: Arc::new(raw) }\n    }\n\n    pub fn from_ptr_with_code(ptr: *mut TAOS_RES, code: Code) -> Result<Self, Error> {\n        RawRes::from_ptr_with_code(ptr, code).map(Self::new)\n    }\n\n    pub fn raw(&self) -> Arc<RawRes> {\n        self.raw.clone()\n    }\n}\n\npub type VGroupId = i32;\n\nimpl Drop for DroppableRawRes {\n    fn drop(&mut self) {\n        if let Some(raw) = Arc::get_mut(&mut self.raw) {\n            raw.free_result();\n        } else {\n            log::error!(\"there's other result pointer in-use, please check\");\n            // todo: safely drop result pointer.\n            // panic!(\"there's other result pointer in-use, please check\");\n        }\n    }\n}\n\nimpl RawRes {\n    #[inline]\n    pub fn as_ptr(&self) -> *mut TAOS_RES {\n        self.ptr\n    }\n\n    #[inline]\n    pub fn errno(&self) -> Code {\n        unsafe { taos_errno(self.as_ptr()) & 0xffff }.into()\n    }\n    #[inline]\n    pub fn errstr(&self) -> &CStr {\n        unsafe { CStr::from_ptr(taos_errstr(self.as_ptr())) }\n    }\n    #[inline]\n    pub fn err_as_str(&self) -> &'static str {\n        unsafe {\n            std::str::from_utf8_unchecked(CStr::from_ptr(taos_errstr(self.as_ptr())).to_bytes())\n        }\n    }\n\n    #[inline]\n    pub fn from_ptr(ptr: *mut TAOS_RES) -> Result<RawRes, Error> {\n        let raw = unsafe { Self::from_ptr_unchecked(ptr) };\n        let code = raw.errno();\n        raw.with_code(code)\n    }\n\n    #[inline]\n    pub const unsafe fn from_ptr_unchecked(ptr: *mut TAOS_RES) -> RawRes {\n        RawRes {\n            ptr,\n            fields: OnceCell::new(),\n        }\n    }\n\n    #[inline]\n    pub fn from_ptr_with_code(ptr: *mut TAOS_RES, code: Code) -> Result<RawRes, Error> {\n        unsafe { RawRes::from_ptr_unchecked(ptr) }.with_code(code)\n    }\n\n    #[inline]\n    fn with_code(self, code: Code) -> Result<Self, Error> {\n        if code.success() {\n            Ok(self)\n        } else {\n            Err(Error::new(code, self.err_as_str()))\n        }\n    }\n\n    #[inline]\n    pub fn num_fields(&self) -> usize {\n        self.fields().len()\n    }\n    #[inline]\n    pub fn fields<'any>(&self) -> &[Field] {\n        let fields = self.fields.get_or_init(|| {\n            let len = unsafe { taos_num_fields(self.as_ptr()) };\n            from_raw_fields(unsafe { taos_fetch_fields(self.as_ptr()) }, len as usize)\n        });\n        &fields\n    }\n\n    pub fn fetch_fields(&self) -> Vec<Field> {\n        let len = unsafe { taos_num_fields(self.as_ptr()) };\n        from_raw_fields(unsafe { taos_fetch_fields(self.as_ptr()) }, len as usize)\n    }\n\n    #[inline]\n    pub fn fetch_lengths(&self) -> *const i32 {\n        unsafe { taos_fetch_lengths(self.as_ptr()) }\n    }\n    #[inline]\n    unsafe fn fetch_lengths_raw(&self) -> *const i32 {\n        taos_fetch_lengths(self.as_ptr())\n    }\n\n    #[inline]\n    pub fn fetch_block(&self) -> Result<Option<(TAOS_ROW, i32, *const i32)>, Error> {\n        let block = Box::into_raw(Box::new(std::ptr::null_mut()));\n        let mut num = 0;\n        err_or!(\n            self,\n            taos_fetch_block_s(self.as_ptr(), &mut num, block),\n            if num > 0 {\n                Some((*block, num, self.fetch_lengths_raw()))\n            } else {\n                None\n            }\n        )\n    }\n\n    #[inline]\n    pub fn get_column_data_offset(&self, col: usize) -> *const i32 {\n        unsafe { taos_get_column_data_offset(self.as_ptr(), col as i32) }\n    }\n\n    #[inline]\n    pub fn fetch_raw_block(&self) -> Result<(*mut u8, u32), Error> {\n        let block = Box::into_raw(Box::new(std::ptr::null_mut()));\n        let mut num = 0;\n        err_or!(\n            self,\n            taos_fetch_raw_block(self.as_ptr(), &mut num as _, block),\n            (*block as _, num as _)\n        )\n    }\n\n    #[inline]\n    pub fn is_update_query(&self) -> bool {\n        unsafe { taos_is_update_query(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn is_null(&self, row: i32, col: i32) -> bool {\n        unsafe { taos_is_null(self.as_ptr(), row, col) }\n    }\n\n    #[inline]\n    pub fn stop_query(&self) {\n        unsafe { taos_stop_query(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn select_db(&self, db: *const i8) -> Result<(), Error> {\n        err_or!(self, taos_select_db(self.as_ptr(), db))\n    }\n\n    #[inline]\n    pub fn affected_rows(&self) -> i32 {\n        unsafe { taos_affected_rows(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn field_count(&self) -> i32 {\n        unsafe { taos_field_count(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn free_result(&mut self) {\n        unsafe { taos_free_result(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn precision(&self) -> Precision {\n        unsafe { taos_result_precision(self.as_ptr()) }.into()\n    }\n\n    #[inline]\n    pub fn fetch_row(&self) -> TAOS_ROW {\n        unsafe { taos_fetch_row(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn fetch_rows_a(&self, fp: taos_async_fetch_cb, param: *mut c_void) {\n        unsafe { taos_fetch_rows_a(self.as_ptr(), fp, param) }\n    }\n\n    #[inline]\n    pub fn block(&self) -> *mut *mut c_void {\n        unsafe { taos_result_block(self.as_ptr()).read() }\n    }\n\n    #[inline]\n    pub fn tmq_topic_name(&self) -> Option<&str> {\n        unsafe {\n            let c = tmq_get_topic_name(self.as_ptr());\n            if c.is_null() {\n                None\n            } else {\n                CStr::from_ptr(c).to_str().ok()\n            }\n        }\n    }\n    #[inline]\n    pub fn tmq_vgroup_id(&self) -> Option<VGroupId> {\n        unsafe {\n            let c = tmq_get_vgroup_id(self.as_ptr());\n            if c == -1 {\n                None\n            } else {\n                Some(c)\n            }\n        }\n    }\n\n    #[inline]\n    pub fn tmq_table_name(&self) -> Option<&str> {\n        unsafe {\n            let c = tmq_get_table_name(self.as_ptr());\n            if c.is_null() {\n                None\n            } else {\n                CStr::from_ptr(c).to_str().ok()\n            }\n        }\n    }\n    #[inline]\n    pub fn tmq_db_name(&self) -> Option<&str> {\n        unsafe {\n            let c = tmq_get_db_name(self.as_ptr());\n            if c.is_null() {\n                None\n            } else {\n                CStr::from_ptr(c).to_str().ok()\n            }\n        }\n    }\n}\n\npub mod into_c_str;\npub mod stmt;\n\n// #[derive(Debug, Clone, Copy)]\n// #[repr(C)]\n// enum BlockVer {\n//     V2 = 0,\n//     V3,\n// }\n// #[derive(Debug, Clone, Copy)]\n// #[repr(C)]\n\n// enum BlockCodec {\n//     Bytes,\n// }\n\n// #[derive(Debug)]\n// enum BlockType<'a> {\n//     V2(*mut *mut c_void),\n//     Bytes(Cow<'a, [u8]>),\n// }\n\n// struct RawCodec<'a> {\n//     version: BlockVer,\n//     method: BlockCodec,\n//     precision: Precision,\n//     fields: Cow<'a, [Field]>,\n// }\n\n// #[derive(Debug)]\n// pub struct RawBlock<'a> {\n//     version: BlockVer,\n//     codec: BlockCodec,\n//     precision: Precision,\n//     fields: Cow<'a, [Field]>,\n//     num_of_rows: usize,\n//     data: BlockType<'a>,\n// }\n\n// impl<'a> RawBlock<'a> {\n//     fn precision(&self) -> Precision {\n//         self.precision\n//     }\n\n//     fn to_bytes(&self) -> Cow<[u8]> {\n//         todo!()\n//     }\n\n//     fn write<T: Write>(&self, mut wtr: T) -> std::io::Result<usize> {\n//         wtr.write(&self.to_bytes())\n//     }\n\n//     fn write_all<T: Write>(&self, mut wtr: T) -> std::io::Result<usize> {\n//         wtr.write(&self.to_bytes())\n//     }\n// }\n","traces":[{"line":65,"address":[8102144],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":66,"address":[8102149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[8053616],"length":1,"stats":{"Line":0},"fn_name":"version"},{"line":73,"address":[8053620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3857520,3857970],"length":1,"stats":{"Line":0},"fn_name":"connect"},{"line":84,"address":[3857663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[3857751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[3857767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[3857788,3858522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3857824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3858038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[3858273,3858191,3858353,3858105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[3858999,3858602,3857801,3858553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3858650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[3858663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3858685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[3858879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[3858575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[8055616,8055184],"length":1,"stats":{"Line":0},"fn_name":"connect_auth"},{"line":114,"address":[8055297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[8055333,8055390,8055795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[8055438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[8055451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[8055473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[8055684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[8055363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3857504],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":129,"address":[3857509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3898496,3898839,3898863],"length":1,"stats":{"Line":0},"fn_name":"query<&str>"},{"line":134,"address":[3898746,3898560,3898639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3859040],"length":1,"stats":{"Line":0},"fn_name":"query_a"},{"line":140,"address":[3859079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[8056369,8055936],"length":1,"stats":{"Line":0},"fn_name":"validate_sql"},{"line":145,"address":[8055976,8056039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[8056081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[8056166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[8056194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[8056223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[8056318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[8056416],"length":1,"stats":{"Line":0},"fn_name":"reset_current_db"},{"line":157,"address":[8056425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[8056464],"length":1,"stats":{"Line":0},"fn_name":"server_version"},{"line":162,"address":[8056473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[8056544],"length":1,"stats":{"Line":0},"fn_name":"load_table_info"},{"line":167,"address":[8056699,8056586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[8056720],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":172,"address":[8056729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8056768],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":194,"address":[8056777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[8056800],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":200,"address":[8056807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[8056864],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_with_code"},{"line":204,"address":[8056887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[8056928],"length":1,"stats":{"Line":0},"fn_name":"raw"},{"line":208,"address":[8056937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[8102160],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":216,"address":[8102172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[8102216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[8102308,8102223,8102357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[3856688],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":229,"address":[3856693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[3856624],"length":1,"stats":{"Line":0},"fn_name":"errno"},{"line":234,"address":[3856633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[8057040],"length":1,"stats":{"Line":0},"fn_name":"errstr"},{"line":238,"address":[8057049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[3855120],"length":1,"stats":{"Line":0},"fn_name":"err_as_str"},{"line":243,"address":[3855129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[3856864,3857065,3857034],"length":1,"stats":{"Line":0},"fn_name":"from_ptr"},{"line":249,"address":[3856886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[3856911,3856962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[3856969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[3856320],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_unchecked"},{"line":258,"address":[3856344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[3856416],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_with_code"},{"line":264,"address":[3856443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[3857152,3857439],"length":1,"stats":{"Line":0},"fn_name":"with_code"},{"line":269,"address":[3857437,3857178,3857259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3857300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[3857385,3857270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[8058000],"length":1,"stats":{"Line":0},"fn_name":"num_fields"},{"line":278,"address":[8058009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3856704],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":282,"address":[3856716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[8130560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[8130594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[3856744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[8058112],"length":1,"stats":{"Line":0},"fn_name":"fetch_fields"},{"line":290,"address":[8058144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[8058178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[3856064],"length":1,"stats":{"Line":0},"fn_name":"fetch_lengths"},{"line":296,"address":[3856073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[3856272],"length":1,"stats":{"Line":0},"fn_name":"fetch_lengths_raw"},{"line":300,"address":[3856281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[3855248],"length":1,"stats":{"Line":0},"fn_name":"fetch_block"},{"line":305,"address":[3855415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[3855439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[3855486,3855714,3855796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[3855447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[3855573,3855554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3855588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[3855561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[3856496],"length":1,"stats":{"Line":0},"fn_name":"get_column_data_offset"},{"line":320,"address":[3856515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[8059008],"length":1,"stats":{"Line":0},"fn_name":"fetch_raw_block"},{"line":325,"address":[8059175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[8059199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[8059387,8059246,8059337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[8059207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[8059321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[8059440],"length":1,"stats":{"Line":0},"fn_name":"is_update_query"},{"line":336,"address":[8059449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[3856784],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":341,"address":[3856809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[8059568],"length":1,"stats":{"Line":0},"fn_name":"stop_query"},{"line":346,"address":[8059577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[8059616],"length":1,"stats":{"Line":0},"fn_name":"select_db"},{"line":351,"address":[8059802,8059664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[3856016],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":356,"address":[3856025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[8059888],"length":1,"stats":{"Line":0},"fn_name":"field_count"},{"line":361,"address":[8059897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[8059936],"length":1,"stats":{"Line":0},"fn_name":"free_result"},{"line":366,"address":[8059945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[3857088],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":371,"address":[3857097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[8060048],"length":1,"stats":{"Line":0},"fn_name":"fetch_row"},{"line":376,"address":[8060057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[8060096],"length":1,"stats":{"Line":0},"fn_name":"fetch_rows_a"},{"line":381,"address":[8060125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[3856560],"length":1,"stats":{"Line":0},"fn_name":"block"},{"line":386,"address":[3856569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[8060240],"length":1,"stats":{"Line":0},"fn_name":"tmq_topic_name"},{"line":392,"address":[8060249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[8060285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[8060327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[8060310,8060361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[8060400],"length":1,"stats":{"Line":0},"fn_name":"tmq_vgroup_id"},{"line":403,"address":[8060409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[8060455,8060442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[8060447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[8060461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[3856112],"length":1,"stats":{"Line":0},"fn_name":"tmq_table_name"},{"line":415,"address":[3856121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[3856157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[3856199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[3856233,3856182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[3855856],"length":1,"stats":{"Line":0},"fn_name":"tmq_db_name"},{"line":426,"address":[3855865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[3855901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[3855943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[3855977,3855926],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":154},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","schemaless.rs"],"content":"use crate::{TAOS, TAOS_RES};\nuse std::os::raw::*;\n\n///\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub enum SchemalessProtocol {\n    #[non_exhaustive]\n    Unknown = 0,\n    Line,\n    Telnet,\n    Json,\n}\npub type TSDB_SML_PROTOCOL_TYPE = SchemalessProtocol;\npub const TSDB_SML_UNKNOWN_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Unknown;\npub const TSDB_SML_LINE_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Line;\npub const TSDB_SML_TELNET_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Telnet;\npub const TSDB_SML_JSON_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Json;\n\n/// Timestamp precision to parse from schemaless input.\n///\n/// Accepted timestamp precision options are:\n/// - NonConfigured: let the parse detect precision from input\n/// - Hours/minutes/seconds/milliseconds/microseconds/nanoseconds: specified precision to use\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub enum SchemalessPrecision {\n    NonConfigured = 0,\n    Hours,\n    Minutes,\n    Seconds,\n    Milliseconds,\n    Microseconds,\n    Nanoseconds,\n}\npub type TSDB_SML_TIMESTAMP_TYPE = SchemalessPrecision;\npub const TSDB_SML_TIMESTAMP_NOT_CONFIGURED: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::NonConfigured;\npub const TSDB_SML_TIMESTAMP_HOURS: TSDB_SML_TIMESTAMP_TYPE = TSDB_SML_TIMESTAMP_TYPE::Hours;\npub const TSDB_SML_TIMESTAMP_MINUTES: TSDB_SML_TIMESTAMP_TYPE = TSDB_SML_TIMESTAMP_TYPE::Minutes;\npub const TSDB_SML_TIMESTAMP_SECONDS: TSDB_SML_TIMESTAMP_TYPE = TSDB_SML_TIMESTAMP_TYPE::Seconds;\npub const TSDB_SML_TIMESTAMP_MILLISECONDS: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::Milliseconds;\npub const TSDB_SML_TIMESTAMP_MICROSECONDS: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::Microseconds;\npub const TSDB_SML_TIMESTAMP_NANOSECONDS: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::Nanoseconds;\n\nextern \"C\" {\n    pub fn taos_schemaless_insert(\n        taos: *mut TAOS,\n        lines: *mut *mut c_char,\n        numLines: c_int,\n        protocol: SchemalessProtocol,\n        precision: TSDB_SML_TIMESTAMP_TYPE,\n    ) -> *mut TAOS_RES;\n}\n\n#[test]\n#[cfg(taos_v2)] // TODO: SML in v3 is unimplemented.\nfn test_sml() {\n    use std::ptr;\n    unsafe {\n        let null = ptr::null();\n        let mut lines = [\n            b\"st,t1=4i64,t3=\\\"t4\\\",t2=5f64,t4=5f64 c1=3i64,c3=L\\\"a, abc\\\",c2=true,c4=5f64,c5=5f64,c6=7u64 1626006933640000000\\0\\0\" as *const u8 as *mut c_char\n        ];\n        let taos = crate::taos_connect(ptr::null(), ptr::null(), null, null, 0);\n        let res = crate::taos_query(taos, b\"create database _rs_sml_\\0\" as *const u8 as _);\n        crate::taos_free_result(res);\n        let _ = crate::taos_query(taos, b\"use _rs_sml_\\0\" as *const u8 as _);\n\n        let res = crate::taos_schemaless_insert(\n            taos,\n            &mut lines as _,\n            1,\n            SchemalessProtocol::Line,\n            TSDB_SML_TIMESTAMP_TYPE::NonConfigured,\n        );\n        assert!(crate::taos_errno(res) == 0);\n        crate::taos_free_result(res);\n        let res = crate::taos_query(taos, b\"select * from st\\0\" as *const u8 as _);\n\n        crate::taos_free_result(res);\n        assert!(!taos.is_null());\n        crate::taos_close(taos);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","set_config.rs"],"content":"use std::os::raw::*;\n\npub const SET_CONF_RET_SUCC: SET_CONF_RET_CODE = SET_CONF_RET_CODE::Succ;\npub const SET_CONF_RET_ERR_PART: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrPart;\npub const SET_CONF_RET_ERR_INNER: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrInner;\npub const SET_CONF_RET_ERR_JSON_INVALID: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrJsonInvalid;\npub const SET_CONF_RET_ERR_JSON_PARSE: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrJsonParse;\npub const SET_CONF_RET_ERR_ONLY_ONCE: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrOnlyOnce;\npub const SET_CONF_RET_ERR_TOO_LONG: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrTooLong;\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct SetConfRet {\n    pub code: SET_CONF_RET_CODE,\n    pub msg: [c_char; 1024usize],\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum SET_CONF_RET_CODE {\n    Succ = 0,\n    ErrPart = -1,\n    ErrInner = -2,\n    ErrJsonInvalid = -3,\n    ErrJsonParse = -4,\n    ErrOnlyOnce = -5,\n    ErrTooLong = -6,\n}\n\nextern \"C\" {\n    pub fn taos_set_config(config: *const c_char) -> SetConfRet;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","stmt","bind.rs"],"content":"use taos_query::common::{itypes::IsValue, Ty};\n\nuse crate::{BindFrom, TaosBind, TaosBindV2, TaosBindV3};\n\nfn box_into_raw<T>(v: T) -> *mut T {\n    Box::into_raw(Box::new(v))\n}\n\nimpl<T> From<&T> for TaosBindV2\nwhere\n    T: IsValue,\n{\n    #[inline(always)]\n    fn from(v: &T) -> Self {\n        macro_rules! as_is {\n            () => {\n                Self::from_primitive(v)\n            };\n        }\n\n        match T::TY {\n            Ty::Null => Self::null(),\n            Ty::Bool => as_is!(),\n            Ty::TinyInt => as_is!(),\n            Ty::SmallInt => as_is!(),\n            Ty::Int => as_is!(),\n            Ty::BigInt => as_is!(),\n            Ty::UTinyInt => as_is!(),\n            Ty::USmallInt => as_is!(),\n            Ty::UInt => as_is!(),\n            Ty::UBigInt => as_is!(),\n            Ty::Float => as_is!(),\n            Ty::Double => as_is!(),\n            Ty::Timestamp => Self::from_timestamp(v.as_timestamp()),\n            Ty::VarChar => Self::from_varchar(v.as_var_char()),\n            Ty::NChar => Self::from_nchar(v.as_nchar()),\n            Ty::Json => todo!(),\n            _ => Self::null(),\n        }\n    }\n}\n\nimpl<T> From<&T> for TaosBindV3\nwhere\n    T: IsValue,\n{\n    #[inline(always)]\n    fn from(v: &T) -> Self {\n        macro_rules! as_is {\n            () => {\n                Self::from_primitive(v)\n            };\n        }\n\n        match T::TY {\n            Ty::Null => Self::null(),\n            Ty::Bool => as_is!(),\n            Ty::TinyInt => as_is!(),\n            Ty::SmallInt => as_is!(),\n            Ty::Int => as_is!(),\n            Ty::BigInt => as_is!(),\n            Ty::UTinyInt => as_is!(),\n            Ty::USmallInt => as_is!(),\n            Ty::UInt => as_is!(),\n            Ty::UBigInt => as_is!(),\n            Ty::Float => as_is!(),\n            Ty::Double => as_is!(),\n            Ty::Timestamp => Self::from_timestamp(v.as_timestamp()),\n            Ty::VarChar => Self::from_varchar(v.as_var_char()),\n            Ty::NChar => Self::from_nchar(v.as_nchar()),\n            Ty::Json => todo!(),\n            _ => Self::null(),\n        }\n    }\n}\n\npub trait ToBind: IsValue {\n    fn to_bind(&self) -> TaosBind {\n        macro_rules! as_is {\n            () => {\n                TaosBind::from_primitive(self)\n            };\n        }\n\n        if self.is_null() {\n            return TaosBind::null();\n        }\n\n        match Self::TY {\n            Ty::Null => TaosBind::null(),\n            Ty::Bool => as_is!(),\n            Ty::TinyInt => as_is!(),\n            Ty::SmallInt => as_is!(),\n            Ty::Int => as_is!(),\n            Ty::BigInt => as_is!(),\n            Ty::UTinyInt => as_is!(),\n            Ty::USmallInt => as_is!(),\n            Ty::UInt => as_is!(),\n            Ty::UBigInt => as_is!(),\n            Ty::Float => as_is!(),\n            Ty::Double => as_is!(),\n            Ty::Timestamp => TaosBind::from_timestamp(self.as_timestamp()),\n            Ty::VarChar => TaosBind::from_varchar(self.as_var_char()),\n            Ty::NChar => TaosBind::from_nchar(self.as_nchar()),\n            Ty::Json => todo!(),\n            _ => TaosBind::null(),\n        }\n    }\n}\n\nimpl<T: IsValue> ToBind for T {}\n\n#[cfg(test)]\nmod tests_v2 {\n    use std::ffi::CStr;\n\n    use taos_query::common::itypes::IVarChar;\n\n    use super::*;\n    use crate::TaosBindV2 as TaosBind;\n\n    #[test]\n    fn bind_bool() {\n        for v in [true, false] {\n            let bind = TaosBind::from(&v);\n            dbg!(&bind);\n            let v1 = unsafe { (bind.buffer as *const bool).read() };\n            assert!(v1 == v);\n        }\n    }\n\n    #[test]\n    fn bind_i8() {\n        for v in [0i8, 1i8].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(&bind);\n            let v1 = unsafe { (bind.buffer as *const i8).read() };\n            assert!(v1.eq(v));\n        }\n    }\n    #[test]\n    fn bind_var_char() {\n        for v in [IVarChar::from(\"abc\")].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(&bind);\n\n            let v1 =\n                unsafe { std::str::from_utf8(std::slice::from_raw_parts(bind.buffer() as _, 3)) }\n                    .unwrap();\n\n            dbg!(v1);\n            assert!(v1 == v.as_str());\n        }\n    }\n}\n#[cfg(test)]\nmod tests_v3 {\n    use std::ffi::CStr;\n\n    use crate::TaosBindV3 as TaosBind;\n    use taos_query::common::itypes::IVarChar;\n\n    #[test]\n    fn bind_bool() {\n        for v in [true, false].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(&bind);\n            let v1 = unsafe { (bind.buffer() as *const bool).read() };\n            assert!(v1.eq(v));\n        }\n    }\n\n    #[test]\n    fn bind_i8() {\n        for v in [0i8, 1i8].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(&bind);\n            let v1 = unsafe { (bind.buffer() as *const i8).read() };\n            assert!(v1.eq(v));\n        }\n    }\n    #[test]\n    fn bind_var_char() {\n        for v in [IVarChar::from(\"abc\")].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(&bind);\n            let v1 =\n                unsafe { std::str::from_utf8(std::slice::from_raw_parts(bind.buffer() as _, 3)) }\n                    .unwrap();\n\n            dbg!(v1);\n            assert!(v1 == v.as_str());\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":67},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","stmt","mod.rs"],"content":"use crate::{ffi::*, into_c_str::IntoCStr, RawRes, RawTaos};\n\nuse std::{ffi::CStr, os::raw::*};\n\nuse taos_error::{Code, Error};\nuse taos_query::common::{itypes::ITimestamp, Ty};\n\nuse crate::types::*;\n\nmod bind;\nmod multi;\n\n#[derive(Debug)]\npub struct RawStmt(*mut TAOS_STMT);\n\nimpl Drop for RawStmt {\n    fn drop(&mut self) {\n        let _ = self.close();\n    }\n}\n\nimpl RawStmt {\n    #[inline(always)]\n    fn ok(&self, code: impl Into<Code>) -> Result<(), Error> {\n        let code = code.into();\n\n        if code.success() {\n            Ok(())\n        } else {\n            Err(Error::from_string(self.err_as_str()))\n        }\n    }\n\n    #[inline]\n    pub unsafe fn as_ptr(&self) -> *mut TAOS_STMT {\n        self.0\n    }\n\n    #[inline]\n    pub fn errstr(&self) -> &CStr {\n        unsafe { CStr::from_ptr(taos_stmt_errstr(self.as_ptr())) }\n    }\n\n    #[inline]\n    pub fn err_as_str(&self) -> String {\n        unsafe {\n            CStr::from_ptr(taos_stmt_errstr(self.as_ptr()))\n                .to_string_lossy()\n                .to_string()\n        }\n    }\n\n    #[inline]\n    pub fn from_raw_taos(taos: &RawTaos) -> RawStmt {\n        RawStmt(unsafe { taos_stmt_init(taos.as_ptr()) })\n    }\n    #[inline]\n    pub fn close(&mut self) -> Result<(), Error> {\n        err_or!(self, taos_stmt_close(self.as_ptr()))\n    }\n\n    #[inline]\n    pub fn prepare<'c>(&mut self, sql: impl IntoCStr<'c>) -> Result<(), Error> {\n        let sql = sql.into_c_str();\n        self.ok(unsafe {\n            taos_stmt_prepare(self.as_ptr(), sql.as_ptr(), sql.to_bytes().len() as _)\n        })\n    }\n\n    pub fn set_tbname_tags_v3<'a>(\n        &mut self,\n        name: impl IntoCStr<'a>,\n        tags: &[TaosBind],\n    ) -> Result<(), Error> {\n        self.ok(unsafe {\n            taos_stmt_set_tbname_tags(\n                self.as_ptr(),\n                name.into_c_str().as_ptr(),\n                tags.as_ptr() as _,\n            )\n        })\n    }\n\n    #[inline]\n    pub fn set_tbname<'c>(&mut self, name: impl IntoCStr<'c>) -> Result<(), Error> {\n        self.ok(unsafe { taos_stmt_set_tbname(self.as_ptr(), name.into_c_str().as_ptr()) })\n    }\n\n    #[inline]\n    pub fn set_sub_tbname<'c>(&mut self, name: impl IntoCStr<'c>) -> Result<(), Error> {\n        self.ok(unsafe { taos_stmt_set_sub_tbname(self.as_ptr(), name.into_c_str().as_ptr()) })\n    }\n\n    #[inline]\n    pub fn use_result(&mut self) -> RawRes {\n        unsafe { RawRes::from_ptr_unchecked(taos_stmt_use_result(self.as_ptr())) }\n    }\n\n    #[inline]\n    pub fn affected_rows(&self) -> i32 {\n        unsafe { taos_stmt_affected_rows(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn execute(&self) -> Result<(), Error> {\n        err_or!(self, taos_stmt_execute(self.as_ptr()))\n    }\n\n    #[inline]\n    pub fn add_batch(&self) -> Result<(), Error> {\n        err_or!(self, taos_stmt_add_batch(self.as_ptr()))\n    }\n\n    #[inline]\n    pub fn is_insert(&self) -> Result<bool, Error> {\n        let mut is_insert = 0;\n        err_or!(\n            self,\n            taos_stmt_is_insert(self.as_ptr(), &mut is_insert as _),\n            is_insert != 0\n        )\n    }\n\n    #[inline]\n    pub fn num_params(&self) -> Result<usize, Error> {\n        let mut num = 0i32;\n        err_or!(\n            self,\n            taos_stmt_num_params(self.as_ptr(), &mut num as _),\n            num as usize\n        )\n    }\n\n    #[inline]\n    pub fn get_param(&mut self, idx: i32) -> Result<(Ty, i32), Error> {\n        let (mut type_, mut bytes) = (0, 0);\n        err_or!(\n            self,\n            taos_stmt_get_param(self.as_ptr(), idx, &mut type_ as _, &mut bytes as _),\n            ((type_ as u8).into(), bytes)\n        )\n    }\n    #[inline]\n    pub fn bind_param(&mut self, bind: &[TaosBind]) -> Result<(), Error> {\n        err_or!(self, taos_stmt_bind_param(self.as_ptr(), bind.as_ptr()))\n    }\n\n    #[inline]\n    pub fn bind_param_batch(&mut self, bind: &[TaosMultiBind]) -> Result<(), Error> {\n        err_or!(\n            self,\n            taos_stmt_bind_param_batch(self.as_ptr(), bind.as_ptr())\n        )\n    }\n\n    #[inline]\n    pub fn bind_single_param_batch(&self, bind: &TaosMultiBind, col: i32) -> Result<(), Error> {\n        self.ok(unsafe {\n            taos_stmt_bind_single_param_batch(self.as_ptr(), bind as *const _ as _, col)\n        })\n    }\n}\n\n#[test]\nfn test_tbname_tags() -> Result<(), Error> {\n    use std::ptr::null;\n    let host = null();\n    let user = null();\n    let pass = null();\n    let db = null();\n    let port = 0;\n    let taos = RawTaos::connect(host, user, pass, db, port)?;\n    taos.query(\"drop database if exists stt1\")?;\n    taos.query(\"create database if not exists stt1 keep 36500\")?;\n    taos.query(\"use stt1\")?;\n    taos.query(\n        \"create stable if not exists st1(ts timestamp, v int) tags(t1 int, t2 bool)\"\n    )?;\n\n    let mut stmt = RawStmt::from_raw_taos(&taos);\n    let sql = \"insert into ? using st1 tags(?, ?) values(?, ?)\";\n    stmt.prepare(sql)?;\n\n    let tags = vec![TaosBind::from(&1i32), TaosBind::from(&true)];\n    println!(\"tags: {tags:#?}\");\n    let tbname = \"tb1\";\n    stmt.set_tbname_tags_v3(&tbname, &tags)?;\n    println!(\"bind\");\n\n    // todo: get_param not implemented in taosc 3.0\n    // let p = stmt.get_param(0)?;\n    // dbg!(p);\n\n    let params = vec![TaosBind::from(&ITimestamp(0)), TaosBind::from(&0i32)];\n    stmt.bind_param(&params)?;\n    println!(\"add batch\");\n\n    stmt.add_batch()?;\n    stmt.execute()?;\n\n    assert!(stmt.affected_rows() == 1);\n\n    let res = taos.query(\"select count(*) from st1\")?;\n\n    taos.query(\"drop database stt1\")?;\n    Ok(())\n}\n","traces":[{"line":17,"address":[8102448],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":18,"address":[8102460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[8133933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[8133943,8134009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[8134016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[8133963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[8131376],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":36,"address":[8131381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[8131392],"length":1,"stats":{"Line":0},"fn_name":"errstr"},{"line":41,"address":[8131401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[8131633,8131472],"length":1,"stats":{"Line":0},"fn_name":"err_as_str"},{"line":47,"address":[8131504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[8131680],"length":1,"stats":{"Line":0},"fn_name":"from_raw_taos"},{"line":55,"address":[8131689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[8131744],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":59,"address":[8131900,8131782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[8131952],"length":1,"stats":{"Line":0},"fn_name":"use_result"},{"line":96,"address":[8131984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[8132048],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":101,"address":[8132057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[8132096],"length":1,"stats":{"Line":0},"fn_name":"execute"},{"line":106,"address":[8132252,8132134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[8132304],"length":1,"stats":{"Line":0},"fn_name":"add_batch"},{"line":111,"address":[8132342,8132460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[8132512],"length":1,"stats":{"Line":0},"fn_name":"is_insert"},{"line":116,"address":[8132550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[8132691,8132592,8132665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[8132558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[8132657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[8132752],"length":1,"stats":{"Line":0},"fn_name":"num_params"},{"line":126,"address":[8132790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[8132832,8132902,8132930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[8132798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[8132897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[8132992],"length":1,"stats":{"Line":0},"fn_name":"get_param"},{"line":136,"address":[8133041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[8133116,8133254,8133217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[8133073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[8133179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[8133312],"length":1,"stats":{"Line":0},"fn_name":"bind_param"},{"line":145,"address":[8133376,8133520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[8133568],"length":1,"stats":{"Line":0},"fn_name":"bind_param_batch"},{"line":150,"address":[8133687,8133776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[8133632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[8133824],"length":1,"stats":{"Line":0},"fn_name":"bind_single_param_batch"},{"line":158,"address":[8134023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[8133877],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":65},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","stmt","multi.rs"],"content":"use taos_query::common::{\n    itypes::{IsPrimitive, IsValue},\n    Ty,\n};\n\nuse crate::{BindFrom, TaosBind, TaosBindV2, TaosMultiBind};\n\nfn box_into_raw<T>(v: T) -> *mut T {\n    Box::into_raw(Box::new(v))\n}\n\n// impl<T> From<T> for TaosMultiBind\n// where\n//     T: IsValue,\n// {\n//     #[inline(always)]\n//     fn from(v: T) -> Self {\n//         macro_rules! as_is {\n//             () => {{\n//                 let mut param = Self::new(T::TY);\n//                 param.buffer_length = T::TY.fixed_length();\n//                 param.buffer = box_into_raw(v) as _;\n//                 param.length = box_into_raw(param.buffer_length) as _;\n//                 param\n//             }};\n//             ($v:expr) => {{\n//                 let mut param = Self::new(T::TY);\n//                 param.buffer_length = T::TY.fixed_length();\n//                 param.buffer = box_into_raw($v) as _;\n//                 param.length = box_into_raw(param.buffer_length) as _;\n//                 param\n//             }};\n//         }\n\n//         match T::TY {\n//             Ty::Null => Self::null(),\n//             Ty::Bool => as_is!(),\n//             Ty::TinyInt => as_is!(),\n//             Ty::SmallInt => as_is!(),\n//             Ty::Int => as_is!(),\n//             Ty::BigInt => as_is!(),\n//             Ty::UTinyInt => as_is!(),\n//             Ty::USmallInt => as_is!(),\n//             Ty::UInt => as_is!(),\n//             Ty::UBigInt => as_is!(),\n//             Ty::Float => as_is!(),\n//             Ty::Double => as_is!(),\n//             Ty::Timestamp => {\n//                 as_is!(v.as_timestamp())\n//             }\n//             Ty::VarChar => Self::from_varchar(v.as_var_char()),\n//             Ty::NChar => Self::from_nchar(v.as_nchar()),\n//             Ty::Json => todo!(),\n//             _ => Self::null(),\n//         }\n//     }\n// }\n\n#[cfg(test)]\nmod tests {\n    use crate::{TaosBind, TaosBindV2};\n\n    #[test]\n    fn bind_bool() {\n        for v in [true, false].iter() {\n            let bind = TaosBindV2::from(v);\n            dbg!(&bind);\n            let v1 = unsafe { (bind.buffer as *const bool).read() };\n            assert!(v1.eq(v));\n        }\n    }\n\n    #[test]\n    fn bind_i8() {\n        for v in [0i8, 1i8].iter() {\n            let bind = TaosBindV2::from(v);\n            dbg!(&bind);\n            let v1 = unsafe { (bind.buffer as *const i8).read() };\n            assert!(v1.eq(v));\n        }\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","tmq.rs"],"content":"use std::{borrow::Cow, fmt::Display, os::raw::*};\n\nuse taos_macros::c_cfg;\n\nuse crate::ffi::TAOS_RES;\n\n#[repr(transparent)]\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\npub struct tmq_resp_err_t(i32);\n\nimpl PartialEq<i32> for tmq_conf_res_t {\n    fn eq(&self, other: &i32) -> bool {\n        self == other\n    }\n}\n\nimpl tmq_resp_err_t {\n    pub fn ok_or(self, s: impl Into<Cow<'static, str>>) -> Result<(), taos_error::Error> {\n        match self {\n            Self(0) => Ok(()),\n            _ => Err(taos_error::Error::from_string(s.into())),\n        }\n    }\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_t {\n    _unused: [u8; 0],\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_conf_t {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_list_t {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_message_t {\n    _unused: [u8; 0],\n}\n\n#[repr(C)]\npub enum tmq_conf_res_t {\n    Unknown = -2,\n    Invalid = -1,\n    Ok = 0,\n}\n\nimpl tmq_conf_res_t {\n    pub fn ok(self, k: &str, v: &str) -> Result<(), taos_error::Error> {\n        match self {\n            Self::Ok => Ok(()),\n            Self::Invalid => Err(taos_error::Error::from_string(format!(\n                \"Invalid key value pair ({k}, {v})\"\n            ))),\n            Self::Unknown => Err(taos_error::Error::from_string(format!(\"Unknown key {k}\"))),\n        }\n    }\n}\n\npub type tmq_commit_cb =\n    unsafe extern \"C\" fn(tmq: *mut tmq_t, resp: tmq_resp_err_t, param: *mut c_void);\n\n// TMQ streaming/consuming API.\n#[c_cfg(taos_tmq)]\nextern \"C\" {\n    pub fn tmq_list_new() -> *mut tmq_list_t;\n    pub fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -> i32;\n    pub fn tmq_list_destroy(list: *mut tmq_list_t);\n    pub fn tmq_list_get_size(list: *const tmq_list_t) -> i32;\n    pub fn tmq_list_to_c_array(list: *const tmq_list_t) -> *mut *mut c_char;\n\n    pub fn tmq_consumer_new(\n        conf: *mut tmq_conf_t,\n        errstr: *mut c_char,\n        errstr_len: i32,\n    ) -> *mut tmq_t;\n\n    pub fn tmq_err2str(err: tmq_resp_err_t) -> *const c_char;\n\n    pub fn tmq_subscribe(tmq: *mut tmq_t, topic_list: *mut tmq_list_t) -> tmq_resp_err_t;\n\n    pub fn tmq_subscription(tmq: *mut tmq_t, topic_list: *mut *mut tmq_list_t) -> tmq_resp_err_t;\n\n    pub fn tmq_consumer_poll(tmq: *mut tmq_t, blocking_time: i64) -> *mut TAOS_RES;\n\n    pub fn tmq_consumer_close(tmq: *mut tmq_t) -> tmq_resp_err_t;\n\n    pub fn tmq_commit_sync(tmq: *mut tmq_t, msg: *const TAOS_RES) -> tmq_resp_err_t;\n\n    pub fn tmq_commit_async(\n        tmq: *mut tmq_t,\n        msg: *const TAOS_RES,\n        cb: tmq_commit_cb,\n        param: *mut c_void,\n    );\n\n    pub fn tmq_get_topic_name(res: *mut TAOS_RES) -> *const c_char;\n    pub fn tmq_get_table_name(res: *mut TAOS_RES) -> *const c_char;\n    pub fn tmq_get_db_name(res: *mut TAOS_RES) -> *const c_char;\n    pub fn tmq_get_vgroup_id(res: *mut TAOS_RES) -> i32;\n}\n\n// TMQ Conf API\n#[c_cfg(taos_tmq)]\nextern \"C\" {\n    pub fn tmq_conf_new() -> *mut tmq_conf_t;\n\n    pub fn tmq_conf_destroy(conf: *mut tmq_conf_t);\n\n    pub fn tmq_conf_set(\n        conf: *mut tmq_conf_t,\n        key: *const c_char,\n        value: *const c_char,\n    ) -> tmq_conf_res_t;\n\n    pub fn tmq_conf_set_auto_commit_cb(\n        conf: *mut tmq_conf_t,\n        cb: tmq_commit_cb,\n        param: *mut c_void,\n    );\n}\n","traces":[{"line":12,"address":[8046096],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":13,"address":[8046110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3759040],"length":1,"stats":{"Line":0},"fn_name":"ok_or<&str>"},{"line":19,"address":[3759084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3759104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[3759123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[8046144],"length":1,"stats":{"Line":0},"fn_name":"ok"},{"line":57,"address":[8046185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[8046274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[8046246,8046294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[8046529,8046220],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","types","field.rs"],"content":"use std::ffi::CStr;\n\n// use super::Ty;\nuse taos_query::common::{Field, Ty};\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct TAOS_FIELD {\n    pub name: [u8; 65usize],\n    pub type_: u8,\n    #[cfg(taos_v2)]\n    pub bytes: i16,\n    #[cfg(not(taos_v2))]\n    pub bytes: i32,\n}\n\nimpl TAOS_FIELD {\n    pub fn name(&self) -> &CStr {\n        unsafe { CStr::from_ptr(self.name.as_ptr() as _) }\n    }\n    pub fn type_(&self) -> Ty {\n        self.type_.into()\n    }\n\n    pub fn bytes(&self) -> u32 {\n        self.bytes as _\n    }\n}\n\nimpl Into<Field> for &TAOS_FIELD {\n    fn into(self) -> Field {\n        Field::new(\n            self.name()\n                .to_str()\n                .expect(\"invalid utf-8 field name\")\n                .to_string(),\n            self.type_(),\n            self.bytes(),\n        )\n    }\n}\n\npub fn from_raw_fields<'a>(ptr: *const TAOS_FIELD, len: usize) -> Vec<Field> {\n    unsafe { std::slice::from_raw_parts(ptr, len) }\n        .into_iter()\n        .map(Into::into)\n        .collect()\n}\n","traces":[{"line":18,"address":[8086592],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":19,"address":[8086601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[8086656],"length":1,"stats":{"Line":0},"fn_name":"type_"},{"line":22,"address":[8086665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[8086688],"length":1,"stats":{"Line":0},"fn_name":"bytes"},{"line":26,"address":[8086693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[8086704,8087006,8086975],"length":1,"stats":{"Line":0},"fn_name":"into"},{"line":33,"address":[8086742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[8086854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[8086905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[8087024],"length":1,"stats":{"Line":0},"fn_name":"from_raw_fields"},{"line":44,"address":[8087074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","types","mod.rs"],"content":"use std::{\n    any::{Any, TypeId},\n    borrow::Cow,\n    fmt::Debug,\n    intrinsics::transmute,\n    mem::ManuallyDrop,\n    os::raw::*,\n    ptr,\n};\n\nmod field;\nuse derive_more::Deref;\npub use field::*;\npub use taos_query::common::{Precision, Ty};\n\nuse taos_query::common::{itypes::*, BorrowedColumn, Column, Timestamp};\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub enum TSDB_OPTION {\n    Locale = 0,\n    Charset,\n    Timezone,\n    ConfigDir,\n    ShellActivityTimer,\n    MaxOptions,\n}\npub const TSDB_OPTION_LOCALE: TSDB_OPTION = TSDB_OPTION::Locale;\npub const TSDB_OPTION_CHARSET: TSDB_OPTION = TSDB_OPTION::Charset;\npub const TSDB_OPTION_TIMEZONE: TSDB_OPTION = TSDB_OPTION::Timezone;\npub const TSDB_OPTION_CONFIGDIR: TSDB_OPTION = TSDB_OPTION::ConfigDir;\npub const TSDB_OPTION_SHELL_ACTIVITY_TIMER: TSDB_OPTION = TSDB_OPTION::ShellActivityTimer;\npub const TSDB_MAX_OPTIONS: TSDB_OPTION = TSDB_OPTION::MaxOptions;\n\n#[repr(C)]\n#[derive(Clone)]\npub struct TaosBindV2 {\n    pub buffer_type: c_int,\n    pub buffer: *mut c_void,\n    pub buffer_length: usize,\n    pub length: *mut usize,\n    pub is_null: *mut c_int,\n    pub is_unsigned: c_int,\n    pub error: *mut c_int,\n    pub u: TaosBindUnionV2,\n    pub allocated: c_uint,\n}\n\nimpl Debug for TaosBindV2 {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"TaosBindV2\")\n            .field(\"buffer_type\", &self.buffer_type)\n            .field(\"buffer\", &self.buffer)\n            .field(\"buffer_length\", &self.buffer_length)\n            .field(\"length\", &self.length)\n            .field(\"is_null\", &self.is_null)\n            .field(\"is_unsigned\", &self.is_unsigned)\n            .field(\"error\", &self.error)\n            .field(\"allocated\", &self.allocated)\n            .finish()\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union TaosBindUnionV2 {\n    pub ts: i64,\n    pub b: i8,\n    pub v1: i8,\n    pub v2: i16,\n    pub v4: i32,\n    pub v8: i64,\n    pub f4: f32,\n    pub f8: f64,\n    pub bin: *mut c_uchar,\n    pub nchar: *mut c_char,\n}\n#[repr(C)]\n#[derive(Debug, Clone)]\npub struct TaosMultiBind {\n    pub buffer_type: c_int,\n    pub buffer: *const c_void,\n    pub buffer_length: usize,\n    pub length: *const i32,\n    pub is_null: *const c_char,\n    pub num: c_int,\n}\n\nimpl TaosMultiBind {\n    pub fn new(ty: Ty) -> Self {\n        Self {\n            buffer_type: ty as _,\n            buffer: std::ptr::null_mut(),\n            buffer_length: 0,\n            length: std::ptr::null_mut(),\n            is_null: std::ptr::null_mut(),\n            num: 1,\n        }\n    }\n}\nimpl BindFrom for TaosBindV3 {\n    #[inline]\n    fn null() -> Self {\n        Self(TaosMultiBind {\n            buffer_type: Ty::Null as _,\n            buffer: std::ptr::null_mut(),\n            buffer_length: 0,\n            length: std::ptr::null_mut(),\n            is_null: std::ptr::null_mut(),\n            num: 1 as _,\n        })\n    }\n\n    fn from_primitive<T: IsValue>(v: &T) -> Self {\n        let mut param = TaosMultiBind::new(T::TY);\n        param.buffer_length = T::TY.fixed_length();\n        param.buffer = v as *const T as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0) as _;\n        Self(param)\n    }\n\n    fn from_timestamp(v: i64) -> Self {\n        let mut param = TaosMultiBind::new(Ty::Timestamp);\n        param.buffer_length = std::mem::size_of::<i64>();\n        param.buffer = box_into_raw(v) as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0i8) as _;\n        Self(param)\n    }\n\n    fn from_varchar(v: &str) -> Self {\n        let mut param = TaosMultiBind::new(Ty::VarChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0i8) as _;\n        Self(param)\n    }\n\n    fn from_nchar(v: &str) -> Self {\n        let mut param = TaosMultiBind::new(Ty::NChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0i8) as _;\n        Self(param)\n    }\n}\n\n#[derive(Debug, Deref)]\n#[repr(transparent)]\npub struct TaosBindV3(TaosMultiBind);\n\n#[cfg(taos_v3)]\npub type TaosBind = TaosBindV3;\n#[cfg(not(taos_v3))]\npub type TaosBind = TaosBindV2;\n\nimpl TaosBindV2 {\n    #[inline]\n    pub fn new(buffer_type: Ty) -> Self {\n        let buffer: *mut c_void = ptr::null_mut();\n        let length: *mut usize = ptr::null_mut();\n        let is_null: *mut c_int = ptr::null_mut();\n        let error: *mut c_int = ptr::null_mut();\n        TaosBindV2 {\n            buffer_type: buffer_type as _,\n            buffer,\n            buffer_length: 0,\n            length,\n            is_null,\n            is_unsigned: 0,\n            error,\n            allocated: 1,\n            u: TaosBindUnionV2 { ts: 0 },\n        }\n    }\n\n    pub(crate) fn buffer(&self) -> *const c_void {\n        self.buffer\n    }\n\n    fn ty(&self) -> Ty {\n        Ty::from(self.buffer_type)\n    }\n\n    #[inline]\n    unsafe fn free(&mut self) {\n        if self.ty() == Ty::Json && !self.buffer.is_null() {\n            Vec::from_raw_parts(self.buffer as _, *self.length, *self.length);\n        }\n        if !self.length.is_null() {\n            Box::from_raw(self.length);\n        }\n        if !self.is_null.is_null() {\n            Box::from_raw(self.is_null);\n        }\n        if !self.error.is_null() {\n            Box::from_raw(self.error);\n        }\n    }\n}\n\npub trait BindFrom: Sized {\n    fn null() -> Self;\n    fn from_primitive<T: IsValue>(v: &T) -> Self;\n    fn from_timestamp(v: i64) -> Self;\n    fn from_varchar(v: &str) -> Self;\n    fn from_nchar(v: &str) -> Self;\n    fn from_binary(v: &str) -> Self {\n        Self::from_varchar(v)\n    }\n}\n\nfn box_into_raw<T>(v: T) -> *mut T {\n    Box::into_raw(Box::new(v))\n}\n\nimpl BindFrom for TaosBindV2 {\n    #[inline]\n    fn null() -> Self {\n        let mut null = Self::new(Ty::Null);\n        let v = Box::new(1i8);\n        null.is_null = Box::into_raw(v) as _;\n        null\n    }\n    fn from_timestamp(v: i64) -> Self {\n        let mut param = Self::new(Ty::Timestamp);\n        param.buffer_length = std::mem::size_of::<i64>();\n        param.buffer = box_into_raw(v) as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n\n    fn from_varchar(v: &str) -> Self {\n        let mut param = Self::new(Ty::VarChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n\n    fn from_nchar(v: &str) -> Self {\n        let mut param = Self::new(Ty::NChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n\n    fn from_primitive<T: IsValue>(v: &T) -> Self {\n        let mut param = Self::new(T::TY);\n        param.buffer_length = T::TY.fixed_length();\n        param.buffer = v as *const T as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n}\n\nimpl Drop for TaosBindV2 {\n    fn drop(&mut self) {\n        unsafe { self.free() }\n    }\n}\n\npub trait ToMultiBind {\n    fn to_multi_bind(&self) -> TaosMultiBind;\n}\n\n// impl<T> From<T> for TaosBind\n// where\n//     T: IValue + Any,\n// {\n//     fn from(value: T) -> Self {\n//         match T::TY {\n//             Ty::Null => Self::null(),\n//             Ty::Bool => {\n//                 let inner = value.into_inner();\n//                 let inner: &bool = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_bool(*inner)\n//             }\n//             Ty::TinyInt => {\n//                 let inner = value.into_inner();\n//                 let inner: &i8 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_tiny_int(*inner)\n//             }\n//             Ty::SmallInt => {\n//                 let inner = value.into_inner();\n//                 let inner: &i16 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_small_int(*inner)\n//             }\n//             Ty::Int => {\n//                 let inner = value.into_inner();\n//                 let inner: &i32 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_int(*inner)\n//             }\n//             Ty::BigInt => {\n//                 let inner = value.into_inner();\n//                 let inner: &i64 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_big_int(*inner)\n//             }\n\n//             Ty::UTinyInt => {\n//                 let inner = value.into_inner();\n//                 let inner: &u8 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_tiny_int_unsigned(*inner)\n//             }\n//             Ty::USmallInt => {\n//                 let inner = value.into_inner();\n//                 let inner: &u16 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_small_int_unsigned(*inner)\n//             }\n//             Ty::UInt => {\n//                 let inner = value.into_inner();\n//                 let inner: &u32 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_int_unsigned(*inner)\n//             }\n//             Ty::UBigInt => {\n//                 let inner = value.into_inner();\n//                 let inner: &u64 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_big_int_unsigned(*inner)\n//             }\n//             Ty::Float => {\n//                 let inner = value.into_inner();\n//                 let inner: &f32 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_float(*inner)\n//             }\n//             Ty::Double => {\n//                 let inner = value.into_inner();\n//                 let inner: &f64 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_double(*inner)\n//             }\n//             Ty::Timestamp => {\n//                 let inner = value.into_inner();\n//                 let inner: &i64 = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_timestamp(*inner)\n//             }\n//             Ty::VarChar => {\n//                 let inner = value.into_inner();\n//                 let inner: &String = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_varchar(inner)\n//             }\n//             Ty::NChar => {\n//                 let inner = value.into_inner();\n//                 let inner: &String = unsafe { std::mem::transmute(&inner) };\n//                 Self::from_nchar(inner)\n//             }\n//             Ty::Json => todo!(),\n//             _ => Self::null(),\n//         }\n//     }\n// }\n\n// impl<T> From<Vec<T>> for TaosMultiBind\n// where\n//     T: IValue,\n// {\n//     fn from(_: Vec<T>) -> Self {\n//         todo!()\n//     }\n// }\n\nimpl TaosMultiBind {\n    pub(crate) fn nulls(n: usize) -> Self {\n        TaosMultiBind {\n            buffer_type: Ty::Null as _,\n            buffer: std::ptr::null_mut(),\n            buffer_length: 0,\n            length: n as _,\n            is_null: std::ptr::null_mut(),\n            num: n as _,\n        }\n    }\n    pub(crate) fn from_primitives<T: IValue>(nulls: Vec<bool>, values: &[T]) -> Self {\n        TaosMultiBind {\n            buffer_type: T::TY as _,\n            buffer: values.as_ptr() as _,\n            buffer_length: std::mem::size_of::<T>(),\n            length: values.len() as _,\n            is_null: ManuallyDrop::new(nulls).as_ptr() as _,\n            num: values.len() as _,\n        }\n    }\n    pub(crate) fn from_raw_timestamps(nulls: Vec<bool>, values: &[i64]) -> Self {\n        TaosMultiBind {\n            buffer_type: Ty::Timestamp as _,\n            buffer: values.as_ptr() as _,\n            buffer_length: std::mem::size_of::<i64>(),\n            length: values.len() as _,\n            is_null: ManuallyDrop::new(nulls).as_ptr() as _,\n            num: values.len() as _,\n        }\n    }\n\n    pub(crate) fn from_binary_vec(values: &[Option<impl AsRef<[u8]>>]) -> Self {\n        let mut buffer_length = 0;\n        let num = values.len();\n        let mut nulls = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { nulls.set_len(num) };\n        nulls.fill(false);\n        let mut length: ManuallyDrop<Vec<i32>> = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { length.set_len(num) };\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                length[i] = v.len() as _;\n                if v.len() > buffer_length {\n                    buffer_length = v.len();\n                }\n            } else {\n                nulls[i] = true;\n            }\n        }\n        let buffer_size = buffer_length * values.len();\n        let mut buffer: ManuallyDrop<Vec<u8>> = ManuallyDrop::new(Vec::with_capacity(buffer_size));\n        unsafe { buffer.set_len(buffer_size) };\n        buffer.fill(0);\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                unsafe {\n                    let dst = buffer.as_mut_ptr().add(buffer_length * i);\n                    std::intrinsics::copy_nonoverlapping(v.as_ptr(), dst, v.len());\n                }\n            }\n        }\n        TaosMultiBind {\n            buffer_type: Ty::VarChar as _,\n            buffer: buffer.as_ptr() as _,\n            buffer_length,\n            length: length.as_ptr() as _,\n            is_null: nulls.as_ptr() as _,\n            num: num as _,\n        }\n    }\n    pub(crate) fn from_string_vec(values: &[Option<impl AsRef<str>>]) -> Self {\n        let values: Vec<_> = values\n            .iter()\n            .map(|f| {\n                f.as_ref()\n                    .map(|s| dbg!(s.as_ref().to_string()).into_bytes())\n            })\n            .collect();\n        let mut s = Self::from_binary_vec(&values);\n        s.buffer_type = Ty::NChar as _;\n        s\n    }\n\n    pub(crate) fn buffer(&self) -> *const c_void {\n        self.buffer\n    }\n}\n\nimpl Drop for TaosMultiBind {\n    fn drop(&mut self) {\n        let ty = Ty::from(self.buffer_type as u8);\n        // if ty == Ty::VarChar || ty == Ty::NChar {\n        //     let len = self.buffer_length * self.num as usize;\n        //     unsafe { Vec::from_raw_parts(self.buffer as *mut u8, len, len as _) };\n        //     unsafe { Vec::from_raw_parts(self.length as *mut i32, self.num as _, self.num as _) };\n        // }\n        unsafe { Vec::from_raw_parts(self.is_null as *mut i8, self.num as _, self.num as _) };\n    }\n}\n\nimpl<'c> From<&'c Column> for TaosMultiBind {\n    fn from(col: &'c Column) -> Self {\n        match col {\n            Column::Null(n) => Self::nulls(*n),\n            Column::Bool(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::TinyInt(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::SmallInt(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Int(nulls, values) => Self::from_primitives(nulls.clone().into_bools(), values),\n            Column::BigInt(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::UTinyInt(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::USmallInt(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::UInt(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::UBigInt(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Float(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Double(nulls, values) => {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Timestamp(nulls, values) => {\n                Self::from_raw_timestamps(nulls.clone().into_bools(), values)\n            }\n            Column::Binary(values) => Self::from_binary_vec(values),\n            Column::NChar(values) => Self::from_string_vec(values),\n            Column::Json(_, _) => todo!(),\n            Column::VarChar(_, _) => todo!(),\n            Column::VarBinary(_, _) => todo!(),\n            Column::Decimal(_, _) => todo!(),\n            Column::Blob(_, _) => todo!(),\n            // _ => unreachable!(),\n        }\n    }\n}\n\nimpl<'b> From<BorrowedColumn<'b>> for TaosMultiBind {\n    fn from(col: BorrowedColumn<'b>) -> Self {\n        use BorrowedColumn::*;\n        match col {\n            Null(n) => Self::nulls(n),\n            Bool(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            TinyInt(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            SmallInt(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Int(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            BigInt(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            UTinyInt(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            USmallInt(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            UInt(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            UBigInt(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Float(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Double(nulls, values) => TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Timestamp(nulls, values) => {\n                TaosMultiBind::from_raw_timestamps(nulls.into_bools(), values)\n            }\n            Binary(values) => TaosMultiBind::from_binary_vec(&values),\n            NChar(values) => TaosMultiBind::from_string_vec(&values),\n            _ => unreachable!(),\n        }\n    }\n}\n\n// impl<'b, 'c> From<&'c BorrowedColumn<'b>> for MultiBind<'c> {\n//     fn from(col: &'c BorrowedColumn<'b>) -> Self {\n//         match col {\n//             BorrowedColumn::Null(n) => MultiBind::nulls(*n),\n//             BorrowedColumn::Bool(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::TinyInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::SmallInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Int(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::BigInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UTinyInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::USmallInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UBigInt(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Float(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Double(nulls, values) => MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Timestamp(nulls, values) => {\n//                 MultiBind::from_raw_timestamps(nulls, values)\n//             }\n//             BorrowedColumn::Binary(values) => MultiBind::from_binary_vec(values),\n//             BorrowedColumn::NChar(values) => MultiBind::from_string_vec(values),\n//             _ => unreachable!(),\n//         }\n//     }\n// }\n\n// impl<T> From<Vec<T>> for TaosMultiBind {\n//     fn from(_: Vec<T>) -> Self {\n//         todo!()\n//     }\n// }\n","traces":[{"line":50,"address":[8136144],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":51,"address":[8136504,8136240,8136163,8136416,8136372,8136460,8136328,8136284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[8136236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[8136280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[8136324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[8136368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[8136412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[8136456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[8136500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[8136576],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":91,"address":[8136597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[8136784],"length":1,"stats":{"Line":0},"fn_name":"null"},{"line":103,"address":[8136927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8137008,8137254],"length":1,"stats":{"Line":0},"fn_name":"from_timestamp"},{"line":123,"address":[8137038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[8137107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[8137116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[8137142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[8137173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[8137201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[8137559,8137280],"length":1,"stats":{"Line":0},"fn_name":"from_varchar"},{"line":132,"address":[8137323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[8137354,8137422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[8137427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[8137449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[8137480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[8137506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[8137600,8137879],"length":1,"stats":{"Line":0},"fn_name":"from_nchar"},{"line":141,"address":[8137643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[8137742,8137674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[8137747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[8137769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[8137800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[8137826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[8137920],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":162,"address":[8137988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[8138027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[8138075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[8138122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[8138161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[8138165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[8138240],"length":1,"stats":{"Line":0},"fn_name":"buffer"},{"line":180,"address":[8138245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[8138256],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":184,"address":[8138265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[8138288],"length":1,"stats":{"Line":0},"fn_name":"free"},{"line":189,"address":[8138302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[8138413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[8138459,8138392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8138491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[8138470,8138523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[8138555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[8138587,8138534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[8138603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[8103040,8103088],"length":1,"stats":{"Line":0},"fn_name":"from_binary<taos_sys::types::TaosBindV2>"},{"line":211,"address":[8103109,8103061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[8103360,8103136,8103248],"length":1,"stats":{"Line":0},"fn_name":"box_into_raw<i64>"},{"line":216,"address":[8103451,8103329,8103227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[8138841,8138640],"length":1,"stats":{"Line":0},"fn_name":"null"},{"line":222,"address":[8138657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[8138798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[8138803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[8138864,8139030],"length":1,"stats":{"Line":0},"fn_name":"from_timestamp"},{"line":228,"address":[8138891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[8138950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[8138958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[8138988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[8139056,8139256],"length":1,"stats":{"Line":0},"fn_name":"from_varchar"},{"line":236,"address":[8139093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[8139118,8139182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[8139186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[8139212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[8139280,8139480],"length":1,"stats":{"Line":0},"fn_name":"from_nchar"},{"line":244,"address":[8139317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[8139342,8139406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[8139410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[8139436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[8102048],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":262,"address":[8102053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[8139504],"length":1,"stats":{"Line":0},"fn_name":"nulls"},{"line":371,"address":[8139621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[8105335,8103942,8106848,8106832,8105366,8104432,8104416,8107318,8105831,8105888,8105392,8108310,8104880,8108336,8106358,8107840,8104385,8107814,8108279,8105862,8107783,8106384,8103911,8104849,8103472,8103968,8107287,8108775,8107344,8106327,8108806,8106801,8104896],"length":1,"stats":{"Line":0},"fn_name":"from_primitives<u32>"},{"line":376,"address":[8104496,8105456,8104960,8106912,8107904,8105952,8108400,8103536,8104032,8106448,8107408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[8104976,8107920,8104048,8103552,8105472,8106928,8107424,8108416,8104512,8106464,8105968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[8106045,8104117,8103629,8105053,8104581,8107501,8107997,8105549,8107005,8108493,8106533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[8104138,8106694,8104602,8106554,8107178,8108018,8103802,8105722,8105570,8106066,8104742,8103650,8104278,8107026,8106218,8108170,8105074,8107522,8107674,8105226,8108514,8108666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[8107700,8108196,8106720,8104768,8104304,8105252,8107204,8105748,8108692,8103828,8106244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[8140103,8139664,8140134],"length":1,"stats":{"Line":0},"fn_name":"from_raw_timestamps"},{"line":386,"address":[8139728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[8139744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[8139821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[8139842,8139994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[8140020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[8110992,8108832],"length":1,"stats":{"Line":0},"fn_name":"from_binary_vec<&[u8]>"},{"line":396,"address":[8111058,8108898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[8111070,8108910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[8111078,8108918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[8109076,8111236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[8109122,8111282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[8111336,8109176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[8109334,8111494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[8111739,8109356,8109579,8111516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[8111936,8111787,8109776,8109627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[8109664,8111824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[8109844,8112004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[8109920,8109890,8112050,8112080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[8109912,8112072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[8109744,8111904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[8112117,8109957,8109544,8111704,8109933,8112093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[8112101,8109941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[8110131,8112291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[8112337,8110177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[8112399,8110239,8112613,8110453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[8112655,8110495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[8110533,8112693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[8112864,8110704,8112759,8110599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[8110754,8112914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[8112956,8110796,8110448,8112608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[8113014,8110854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[8113059,8110899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[8113424,8113152,8113373,8113645],"length":1,"stats":{"Line":0},"fn_name":"from_string_vec<&str>"},{"line":437,"address":[8113205,8113477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[8113696,8113776],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<&str>"},{"line":440,"address":[8113733,8113813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[8113906,8114640,8113856,8114690],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<alloc::string::String>"},{"line":444,"address":[8113342,8113540,8113268,8113614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[8113626,8113354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[8140160],"length":1,"stats":{"Line":0},"fn_name":"buffer"},{"line":450,"address":[8140165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[8102064],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":456,"address":[8102078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[8102098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[8141545,8141579,8140176],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":468,"address":[8140223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[8140372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[8140409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[8143583,8140444,8143433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[8140471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[8143261,8140506,8143411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[8140533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[8143089,8140568,8143239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[8140595,8142917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[8140657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[8142895,8140692,8142745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[8140999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[8141034,8141971,8142133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[8141061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[8141096,8141787,8141949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[8141123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[8141158,8141603,8141765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[8141185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[8141220,8141389,8141560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[8140719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[8142573,8140754,8142723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[8140781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[8142551,8140816,8142401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[8140890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[8140925,8142189,8142345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[8142391,8140843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[8142179,8140952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[8143616,8147384,8146679],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":519,"address":[8143661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[8143975,8147139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[8144005,8147127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[8144191,8147083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[8144377,8147039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[8144563,8146995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[8146951,8144749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[8146570,8145649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[8146529,8145835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[8146488,8146021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[8146423,8146177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[8146907,8144935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[8146863,8145121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[8145385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[8146722,8145531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[8145307,8146734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[8146582,8145571],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":199},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","info.rs"],"content":"use taos_sys::ffi::taos_get_client_info;\n\nuse std::ffi::CStr;\n\n#[test]\nfn test_server_info() {\n    let info = unsafe { CStr::from_ptr(taos_get_client_info()) }.to_string_lossy();\n    println!(\"{}\", dbg!(&info));\n    assert!(info.contains(\".\"))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","query_a.rs"],"content":"use std::{ffi::*, os::raw::c_int};\n\n#[test]\n#[cfg(taos_v2)]\nfn test_query_a() {\n    use taos_sys::*;\n\n    use std::sync::mpsc::channel;\n    use std::sync::mpsc::Sender;\n    pub struct CallbackArg {\n        pub sender: Sender<i32>,\n    }\n    pub unsafe extern \"C\" fn async_query_callback(\n        param: *mut c_void,\n        res: *mut c_void,\n        code: c_int,\n    ) {\n        assert!(code == 0);\n        let _ = RawRes::from_ptr(res);\n        let param = param as *mut CallbackArg;\n        let args = Box::from_raw(param);\n\n        let CallbackArg { sender } = *args;\n\n        sender.send(12).unwrap();\n    }\n\n    let taos = RawTaos::connect(\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        0,\n    )\n    .expect(\"connect\");\n    let (sender, receiver) = channel();\n    let args = CallbackArg { sender };\n    let args = Box::new(args);\n    taos.query_a(\n        b\"show databases\\0\" as *const u8 as _,\n        async_query_callback,\n        Box::into_raw(args) as *mut c_void,\n    );\n    let msg = receiver.recv().unwrap();\n    println!(\"received: {msg}\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","raw_block.rs"],"content":"// todo: some const functions are not available for stable Rust.\n#![feature(const_slice_from_raw_parts)]\n#![feature(const_slice_index)]\n\nuse once_cell::unsync::OnceCell;\nuse taos_query::{\n    common::{Column, Field, Timestamp, Ty, Value},\n    BlockExt,\n};\nuse taos_sys::Precision;\n\nuse core::slice;\nuse std::{\n    fmt::Debug,\n    mem::transmute,\n    mem::{size_of, transmute_copy},\n    ops::Deref,\n};\n\n#[derive(Debug, Clone, Copy)]\n#[repr(C)]\n#[repr(packed(2))] // use packed(2) because it's int16_t in raw block.\npub struct ColSchema {\n    ty: Ty,\n    len: u32,\n}\n\n#[test]\nfn col_schema() {\n    let col = ColSchema {\n        ty: Ty::BigInt,\n        len: 1,\n    };\n    let bytes: [u8; 6] = unsafe { transmute_copy(&col) };\n    dbg!(&bytes);\n\n    let bytes: [u8; 6] = [4, 0, 1, 0, 0, 0];\n    let col2: ColSchema = unsafe { transmute_copy(&bytes) };\n    dbg!(col2);\n}\n#[test]\nfn test_bin() {\n    let v: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let ptr = v.as_ptr();\n\n    let v_u16 = unsafe { *transmute::<*const u8, *const u16>(ptr) };\n    println!(\"{v_u16:#x?}: {:?}\", v_u16.to_le_bytes());\n    #[derive(Debug, Clone, Copy)]\n    #[repr(packed)]\n    #[allow(dead_code)]\n    struct A {\n        a: u16,\n        b: u32,\n    }\n    println!(\"A size: {}\", std::mem::size_of::<A>());\n    let a: &A = unsafe { transmute::<*const u8, *const A>(ptr).as_ref().unwrap() };\n    println!(\"{a:#x?}\");\n}\n\npub struct RawBlock {\n    data: Vec<u8>,\n    len: usize,\n    rows: usize,\n    cols: usize,\n    precision: Precision,\n    offsets: Vec<(Ty, isize, isize)>,\n}\n\nimpl RawBlock {\n    pub unsafe fn copy_from_ptr(\n        data: *const u8,\n        rows: usize,\n        cols: usize,\n        precision: Precision,\n    ) -> Self {\n        let len = *transmute::<*const u8, *const u32>(data) as usize + 4;\n        Self {\n            data: slice::from_raw_parts(data, len).into(),\n            len,\n            rows,\n            cols,\n            precision,\n            offsets: Vec::new(),\n        }\n    }\n}\n\n/// Raw data block format:\n///\n/// ```text,ignore\n/// +--------------+----------+---------------+-----------+-----------------------+-----------------+\n/// | total length | group id | col_schema... | length... | (bitmap or offsets    | col data)   ... |\n/// |  4 bytes     | 8 bytes  | (2 + 4) * cols| 4 * cols  | (row+7)/8 or 4 * rows | length[col] ... |\n/// +--------------+----------+---------------+-----------+-----------------------+-----------------+\n/// ```\n///\n/// The length of bitmap is decided by number of rows of this data block, and the length of each column data is\n/// recorded in the first segment, next to the struct header\n#[derive(Debug)]\npub struct InnerBlock {\n    data: *const u8,\n    len: usize,\n    rows: usize,\n    cols: usize,\n    precision: Precision,\n    offsets: OnceCell<Vec<(Ty, isize, isize)>>,\n}\n\nimpl InnerBlock {\n    /// From raw data block.\n    pub unsafe fn from_ptr(\n        data: *const u8,\n        rows: usize,\n        cols: usize,\n        precision: Precision,\n    ) -> Self {\n        let len = *transmute::<*const u8, *const u32>(data) as usize + 4;\n        Self {\n            data,\n            len,\n            rows,\n            cols,\n            precision,\n            offsets: OnceCell::new(),\n        }\n    }\n\n    /// The whole block slice length.\n    pub const fn len(&self) -> usize {\n        unsafe { *transmute::<*const u8, *const u32>(self.as_ptr()) as usize + 4 }\n    }\n\n    /// The group id of the raw block.\n    pub const fn group_id(&self) -> u64 {\n        unsafe { *std::mem::transmute::<*const u8, *const u64>(self.as_ptr()) }\n    }\n\n    /// Inner block as bytes slice.\n    pub const fn as_bytes(&self) -> &[u8] {\n        unsafe { slice::from_raw_parts(self.data, self.len) }\n    }\n\n    /// Raw data block bytes.\n    pub fn to_vec(&self) -> Vec<u8> {\n        self.as_bytes().to_owned()\n    }\n\n    /// Pointer to raw block data slice.\n    const fn as_ptr(&self) -> *const u8 {\n        self.data\n    }\n\n    /// Offset to column schema start position.\n    const fn schema_offset(&self) -> isize {\n        // 4 = block data length.\n        // 8 = group id.\n        4 + 8\n    }\n\n    /// Offset to lengths start position.\n    const fn lengths_offset(&self) -> isize {\n        // 6 == size_of::<ColumnSchema>()\n        self.schema_offset() + self.cols as isize * 6\n    }\n\n    /// Offset to column data start position.\n    const fn data_offset(&self) -> isize {\n        self.lengths_offset() + self.cols as isize * 4\n    }\n\n    /// Pointer to specific offset.\n    const unsafe fn offset(&self, count: isize) -> *const u8 {\n        self.as_ptr().offset(count)\n    }\n\n    /// Length of each bitmap block.\n    const fn bitmap_len(&self) -> usize {\n        (self.rows + 7) / 8\n    }\n\n    /// A lazy-init-ed index to each column.\n    ///\n    /// For each column, the index is a 3-element tuple:\n    ///\n    /// 0. Column data type represented as [Ty]\n    /// 1. Offset to column data start position relative to the block front.\n    ///   - For var-type, it's a `rows` length `i32` vector contains the offsets to each row.\n    ///   - For non-var-type, it's the is-null bitmap.\n    /// 2. Offset to the start position of real column data.\n    fn column_offsets(&self) -> &[(Ty, isize, isize)] {\n        self.offsets.get_or_init(|| {\n            let lengths = self.lengths();\n            let mut data_offset = self.data_offset();\n            self.schemas()\n                .iter()\n                .enumerate()\n                .map(|(i, col)| {\n                    assert!(data_offset < self.len() as isize);\n                    if col.ty.is_var_type() {\n                        let o = (col.ty, data_offset, data_offset + 4 * self.rows as isize);\n                        data_offset = o.2 + lengths[i] as isize;\n                        o\n                    } else {\n                        let o = (\n                            col.ty,\n                            data_offset,\n                            data_offset + self.bitmap_len() as isize,\n                        );\n                        data_offset = o.2 + lengths[i] as isize;\n\n                        assert!(data_offset < self.len() as isize);\n                        o\n                    }\n                })\n                .collect()\n        })\n    }\n\n    /// Column schema extractor.\n    #[inline]\n    pub const fn schemas(&self) -> &[ColSchema] {\n        unsafe {\n            let ptr = self.offset(self.schema_offset());\n            slice::from_raw_parts(ptr as *mut ColSchema, self.cols)\n        }\n    }\n    /// Get column data type.\n    #[inline]\n    pub const fn get_type_of(&self, col: usize) -> Ty {\n        self.get_schema_of(col).ty\n    }\n\n    /// Get column schema which includes data type and bytes length.\n    #[inline]\n    pub const fn get_schema_of(&self, col: usize) -> &ColSchema {\n        unsafe { self.schemas().get_unchecked(col) }\n    }\n\n    #[inline]\n    /// Lengths for each column raw data.\n    const fn lengths(&self) -> &[i32] {\n        unsafe {\n            let ptr = self.offset(self.lengths_offset());\n            slice::from_raw_parts(ptr as *mut i32, self.cols)\n        }\n    }\n\n    #[inline]\n    /// Get one value at `(row, col)` of the block.\n    pub unsafe fn get_unchecked(&self, row: usize, col: usize) -> Value {\n        let (ty, o1, o2) = self.column_offsets().get_unchecked(col);\n\n        macro_rules! is_null {\n            ($bm:expr, $row:expr) => {{\n                (*$bm.offset($row as isize >> 3) >> (7 - ($row & 7)) as u8) & 0x1 == 1\n            }};\n        }\n\n        macro_rules! _primitive_value {\n            ($ty:ident, $native:ty) => {{\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::<$native>()) as isize)\n                        as *const $native);\n                    Value::$ty(v)\n                }\n            }};\n        }\n\n        match ty {\n            Ty::Null => Value::Null,\n            Ty::Bool => _primitive_value!(Bool, bool),\n            Ty::TinyInt => _primitive_value!(TinyInt, i8),\n            Ty::SmallInt => _primitive_value!(SmallInt, i16),\n            Ty::Int => _primitive_value!(Int, i32),\n            Ty::BigInt => _primitive_value!(BigInt, i64),\n            Ty::Float => _primitive_value!(Float, f32),\n            Ty::Double => _primitive_value!(Double, f64),\n            Ty::VarChar => {\n                //\n                let offset =\n                    *transmute::<*const u8, *const i32>(self.offset(o1 + row as isize * 4));\n                if offset < 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    Value::VarChar(\n                        std::str::from_utf8_unchecked(slice::from_raw_parts(\n                            ptr.offset(2),\n                            len as usize,\n                        ))\n                        .to_string(),\n                    )\n                }\n            }\n            Ty::Timestamp => {\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::<i64>()) as isize) as *const i64);\n                    Value::Timestamp(Timestamp::new(v, self.precision))\n                }\n            }\n            Ty::NChar => {\n                let offset =\n                    *transmute::<*const u8, *const i32>(self.offset(o1 + row as isize * 4));\n                if offset < 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    \n                    Value::NChar(\n                        slice::from_raw_parts(ptr.offset(2) as *mut char, len as usize / 4)\n                            .into_iter()\n                            .collect(),\n                    )\n                }\n            }\n            Ty::UTinyInt => _primitive_value!(UTinyInt, u8),\n            Ty::USmallInt => _primitive_value!(USmallInt, u16),\n            Ty::UInt => _primitive_value!(UInt, u32),\n            Ty::UBigInt => _primitive_value!(UBigInt, u64),\n            Ty::Json => {\n                let offset =\n                    *transmute::<*const u8, *const i32>(self.offset(o1 + row as isize * 4));\n                if offset < 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    debug_assert!(self.len() as isize >= o1 + row as isize * 4 + len as isize);\n                    let chars_len = len / 4;\n                    let chars_ptr = ptr.offset(2) as *mut char;\n                    let chars = slice::from_raw_parts(chars_ptr, chars_len as usize);\n                    let json: String = chars.into_iter().collect();\n\n                    serde_json::from_str(&json)\n                        .ok()\n                        .map(Value::Json)\n                        .unwrap_or(Value::Null)\n                }\n            }\n            ty => unreachable!(\"unsupported type: {ty}\"),\n        }\n    }\n}\n\n#[test]\nfn raw_block() -> Result<(), taos_error::Error> {\n    use taos_sys::*;\n    let taos = RawTaos::connect(\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        0,\n    )?;\n    let rs = taos.query(\"show databases\")?;\n    let fields = rs.fields();\n    let precision = rs.precision();\n    let field_count = rs.field_count();\n    let (ptr, rows) = rs.fetch_raw_block()?;\n\n    let inner = unsafe { InnerBlock::from_ptr(ptr, rows as _, field_count as _, precision) };\n    let gid = inner.group_id();\n    println!(\"group id: {gid}\");\n\n    for i in 0..field_count {\n        let col = inner.get_schema_of(i as _);\n        let field = &fields[i as usize];\n        println!(\"{field:?}, {col:#x?}\");\n    }\n\n    let schemas = inner.schemas();\n    dbg!(schemas);\n    let lengths = inner.lengths();\n    dbg!(lengths);\n    let offsets = inner.column_offsets();\n    dbg!(offsets);\n\n    dbg!(unsafe { inner.get_unchecked(0, field_count as usize - 1) });\n    for row in 0..dbg!(rows) as usize {\n        for col in 0..field_count as usize {\n            println!(\"({row}, {col}): \");\n            let v = unsafe { inner.get_unchecked(row, col) };\n            dbg!(v);\n        }\n    }\n    Ok(())\n}\n\n// impl BlockExt for InnerBlock {\n//     fn num_of_rows(&self) -> usize {\n//         todo!()\n//     }\n\n//     fn fields(&self) -> &[Field] {\n//         todo!()\n//     }\n\n//     fn precision(&self) -> Precision {\n//         todo!()\n//     }\n\n//     fn is_null(&self, row: usize, col: usize) -> bool {\n//         todo!()\n//     }\n\n//     unsafe fn cell_unchecked(\n//         &self,\n//         row: usize,\n//         col: usize,\n//     ) -> (&Field, taos_query::common::BorrowedValue) {\n//         todo!()\n//     }\n\n//     unsafe fn get_col_unchecked(&self, col: usize) -> taos_query::common::BorrowedColumn {\n//         todo!()\n//     }\n// }\n\n#[test]\nfn inner_block() {\n    use taos_query::common::Timestamp::Milliseconds;\n    use taos_sys::Precision::Millisecond;\n    let bytes = b\"5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x08\\x00\\x00\\x00\\x0b\\x00\\x01\\x00\\x00\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\r\\x00\\x04\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x04\\x00\\x00\\x00\\x07\\x00\\x08\\x00\\x00\\x00\\x08\\x00f\\x00\\x00\\x00\\n\\x00\\x92\\x01\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x00\\xf2=\\xc3u\\x81\\x01\\x00\\x00\\xdaA\\xc3u\\x81\\x01\\x00\\x00@\\x01\\x00@\\xff\\x00@\\xff\\xff\\x00\\x00@\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00@\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00@\\x01\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x03\\x00abc\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x14\\x00\\x9bm\\x00\\x00\\x1d`\\x00\\x00\\x1e\\xd1\\x01\\x00pe\\x00\\x00nc\\x00\\x00\\x00\\x00\\x00\\x00\";\n    let rows = 2;\n    let cols = 14;\n    let precision = Millisecond;\n\n    let block = unsafe { InnerBlock::from_ptr(bytes.as_ptr(), rows, cols, precision) };\n\n    assert_eq!(block.as_bytes(), bytes);\n    assert_eq!(block.len(), bytes.len());\n\n    use Value::*;\n    let values = vec![\n        vec![\n            Timestamp(Milliseconds(1655538138610)),\n            Bool(true),\n            Value::TinyInt(-1),\n            SmallInt(-1),\n            Int(-1),\n            BigInt(-1),\n            UTinyInt(1),\n            USmallInt(1),\n            UInt(1),\n            UBigInt(1),\n            Float(0.0),\n            Double(0.0),\n            VarChar(\"abc\".to_string()),\n            NChar(\"涛思𝄞数据\".to_string()),\n        ],\n        {\n            Some(Timestamp(Milliseconds(1655538139610)))\n                .into_iter()\n                .chain(std::iter::repeat(Value::Null).take(14))\n                .collect::<Vec<_>>()\n        },\n    ];\n    assert!(block.cols == 14);\n\n    for row in 0..rows {\n        for col in 0..block.cols {\n            let v = unsafe { block.get_unchecked(row, col) };\n            assert_eq!(v, values[row][col]);\n        }\n    }\n}\n\n#[test]\nfn raw_block_full_test() -> Result<(), taos_error::Error> {\n    use taos_sys::*;\n    let taos = RawTaos::connect(\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        0,\n    )?;\n\n    let _ = taos.query(\"drop database if exists _rs_ts_raw_block_full_\")?;\n    let _ = taos.query(\"create database if not exists _rs_ts_raw_block_full_\")?;\n    let _ = taos.query(\"use _rs_ts_raw_block_full_\")?;\n    let _ = taos.query(\"create stable stb1 (ts timestamp,vb bool,vi8 tinyint,vi16 smallint,\\\n        vi32 int,vi64 bigint, vu8 tinyint unsigned,vu16 smallint unsigned,vu32 int unsigned,vu64 bigint unsigned,\\\n        vf float,vd double,vv varchar(100), vn nchar(100)) tags(tj json)\")?;\n\n    let _ = taos.query(\n        \"insert into tb1 using stb1 tags(NULL) values\\\n        (now,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\",\n    )?;\n    let _ = taos.query(\n        \"insert into tb2 using stb1 tags('{\\\"a\\\":\\\"涛思𝄞数据\\\"}') values\\\n        (now,true,-1,-1,-1,-1, 1,1,1,1,0.0,0.0,'abc', '涛思𝄞数据')\\\n        (now+1s,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\",\n    )?;\n    let rs = taos.query(\"select * from tb2 order by tbname\")?;\n    let fields = rs.fields();\n    let precision = rs.precision();\n    let field_count = rs.field_count();\n    let (ptr, rows) = rs.fetch_raw_block()?;\n\n    let inner = unsafe { InnerBlock::from_ptr(ptr, rows as _, field_count as _, precision) };\n    let gid = inner.group_id();\n    println!(\"group id: {gid}\");\n\n    use std::ascii::escape_default;\n\n    pub fn show_buf<B: AsRef<[u8]>>(buf: B) -> String {\n        String::from_utf8(\n            buf.as_ref()\n                .iter()\n                .map(|b| escape_default(*b))\n                .flatten()\n                .collect(),\n        )\n        .unwrap()\n    }\n\n    dbg!(inner.len());\n    dbg!(inner.as_bytes());\n    let bytes = inner.to_vec();\n    println!(\"{}\", show_buf(bytes));\n\n    for i in 0..field_count {\n        let col = inner.get_schema_of(i as _);\n        let field = &fields[i as usize];\n        println!(\"{field:?}, {col:#x?}\");\n    }\n\n    let schemas = inner.schemas();\n    dbg!(schemas);\n    let lengths = inner.lengths();\n    dbg!(lengths);\n    let offsets = inner.column_offsets();\n    dbg!(offsets);\n\n    dbg!(unsafe { inner.get_unchecked(0, field_count as usize - 1) });\n    for row in 0..dbg!(rows) as usize {\n        for col in 0..field_count as usize {\n            println!(\"({row}, {col}): \");\n            let v = unsafe { inner.get_unchecked(row, col) };\n\n            dbg!(v);\n        }\n    }\n    Ok(())\n}\n\n#[test]\nfn char_size() {\n    assert_eq!(size_of::<char>(), 4);\n}\n","traces":[{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":84},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","time.rs"],"content":"use taos_sys::{ffi::*, *};\n\n#[test]\n#[cfg(taos_parse_time)]\nfn test_parse_time() {\n    use std::ffi::CString;\n    let s = CString::new(\"1970-01-01 00:00:00\").unwrap();\n    let mut time = 0i64;\n    unsafe {\n        taos_options(\n            TSDB_OPTION_TIMEZONE,\n            b\"Europe/Landon\\0\" as *const u8 as *const _,\n        )\n    };\n    let res = unsafe {\n        taos_parse_time(\n            s.as_ptr(),\n            &mut time as _,\n            s.to_bytes().len() as _,\n            Precision::Microsecond,\n            0,\n        )\n    };\n    assert_eq!(res, 0, \"success\");\n    assert_eq!(time, 0, \"parse time\");\n\n    let s = CString::new(\"1970-01-01 08:00:00\").unwrap(); // CST +8\n                                                          // timezone could be set multiple times\n    unsafe {\n        taos_options(\n            TSDB_OPTION_TIMEZONE,\n            b\"Asia/Shanghai\\0\" as *const u8 as *const _,\n        )\n    };\n    let res = unsafe {\n        taos_parse_time(\n            s.as_ptr(),\n            &mut time as _,\n            s.to_bytes().len() as _,\n            Precision::Microsecond,\n            0,\n        )\n    };\n    assert_eq!(res, 0, \"success\");\n    assert_eq!(time, 0, \"parse time\");\n}\n","traces":[],"covered":0,"coverable":0}]}